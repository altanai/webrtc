<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <base data-ice="baseUrl" href="../../../../../">
  <title data-ice="title">src/codemirror/mode/erlang/erlang.js | webrtcdevelopment</title>
  <link type="text/css" rel="stylesheet" href="css/style.css">
  <link type="text/css" rel="stylesheet" href="css/prettify-tomorrow.css">
  <script src="script/prettify/prettify.js"></script>
  <script src="script/manual.js"></script>
<meta name="description" content="webrtc based communication and collaboration client. Contains lot of experiments modules "><meta property="twitter:card" content="summary"><meta property="twitter:title" content="webrtcdevelopment"><meta property="twitter:description" content="webrtc based communication and collaboration client. Contains lot of experiments modules "></head>
<body class="layout-container" data-ice="rootContainer">

<header>
  <a href="./">Home</a>
  
  <a href="identifiers.html">Reference</a>
  <a href="source.html">Source</a>
  
  <div class="search-box">
  <span>
    <img src="./image/search.png">
    <span class="search-input-edge"></span><input class="search-input"><span class="search-input-edge"></span>
  </span>
    <ul class="search-result"></ul>
  </div>
<a style="position:relative; top:3px;" href="https://github.com/altanai/webrtc"><img width="20px" src="./image/github.png"></a></header>

<nav class="navigation" data-ice="nav"><div>
  <ul>
    
  <li data-ice="doc"><a data-ice="dirPath" class="nav-dir-path" href="identifiers.html#scripts">scripts</a><span data-ice="kind" class="kind-typedef">T</span><span data-ice="name"><span><a href="typedef/index.html#static-typedef-CanvasRecorder">CanvasRecorder</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-typedef">T</span><span data-ice="name"><span><a href="typedef/index.html#static-typedef-GetRecorderType">GetRecorderType</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-typedef">T</span><span data-ice="name"><span><a href="typedef/index.html#static-typedef-GifRecorder">GifRecorder</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-typedef">T</span><span data-ice="name"><span><a href="typedef/index.html#static-typedef-MRecordRTC">MRecordRTC</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-typedef">T</span><span data-ice="name"><span><a href="typedef/index.html#static-typedef-MediaStreamRecorder">MediaStreamRecorder</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-typedef">T</span><span data-ice="name"><span><a href="typedef/index.html#static-typedef-RecordRTC">RecordRTC</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-typedef">T</span><span data-ice="name"><span><a href="typedef/index.html#static-typedef-RecordRTCConfiguration">RecordRTCConfiguration</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-typedef">T</span><span data-ice="name"><span><a href="typedef/index.html#static-typedef-StereoAudioRecorder">StereoAudioRecorder</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-typedef">T</span><span data-ice="name"><span><a href="typedef/index.html#static-typedef-Whammy">Whammy</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-typedef">T</span><span data-ice="name"><span><a href="typedef/index.html#static-typedef-WhammyRecorder">WhammyRecorder</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-typedef">T</span><span data-ice="name"><span><a href="typedef/index.html#static-typedef-createFileSharingDiv">createFileSharingDiv</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-typedef">T</span><span data-ice="name"><span><a href="typedef/index.html#static-typedef-_turn.js">_turn.js</a></span></span></li>
<li data-ice="doc"><a data-ice="dirPath" class="nav-dir-path" href="identifiers.html#scripts-rtcconn">scripts/rtcconn</a><span data-ice="kind" class="kind-typedef">T</span><span data-ice="name"><span><a href="typedef/index.html#static-typedef-Whammy">Whammy</a></span></span></li>
</ul>
</div>
</nav>

<div class="content" data-ice="content"><h1 data-ice="title">src/codemirror/mode/erlang/erlang.js</h1>
<pre class="source-code line-number raw-source-code"><code class="prettyprint linenums" data-ice="content">// CodeMirror, copyright (c) by Marijn Haverbeke and others
// Distributed under an MIT license: http://codemirror.net/LICENSE

/*jshint unused:true, eqnull:true, curly:true, bitwise:true */
/*jshint undef:true, latedef:true, trailing:true */
/*global CodeMirror:true */

// erlang mode.
// tokenizer -&gt; token types -&gt; CodeMirror styles
// tokenizer maintains a parse stack
// indenter uses the parse stack

// TODO indenter:
//   bit syntax
//   old guard/bif/conversion clashes (e.g. &quot;float/1&quot;)
//   type/spec/opaque

(function(mod) {
  if (typeof exports == &quot;object&quot; &amp;&amp; typeof module == &quot;object&quot;) // CommonJS
    mod(require(&quot;../../lib/codemirror&quot;));
  else if (typeof define == &quot;function&quot; &amp;&amp; define.amd) // AMD
    define([&quot;../../lib/codemirror&quot;], mod);
  else // Plain browser env
    mod(CodeMirror);
})(function(CodeMirror) {
&quot;use strict&quot;;

CodeMirror.defineMIME(&quot;text/x-erlang&quot;, &quot;erlang&quot;);

CodeMirror.defineMode(&quot;erlang&quot;, function(cmCfg) {
  &quot;use strict&quot;;

/////////////////////////////////////////////////////////////////////////////
// constants

  var typeWords = [
    &quot;-type&quot;, &quot;-spec&quot;, &quot;-export_type&quot;, &quot;-opaque&quot;];

  var keywordWords = [
    &quot;after&quot;,&quot;begin&quot;,&quot;catch&quot;,&quot;case&quot;,&quot;cond&quot;,&quot;end&quot;,&quot;fun&quot;,&quot;if&quot;,
    &quot;let&quot;,&quot;of&quot;,&quot;query&quot;,&quot;receive&quot;,&quot;try&quot;,&quot;when&quot;];

  var separatorRE    = /[\-&gt;,;]/;
  var separatorWords = [
    &quot;-&gt;&quot;,&quot;;&quot;,&quot;,&quot;];

  var operatorAtomWords = [
    &quot;and&quot;,&quot;andalso&quot;,&quot;band&quot;,&quot;bnot&quot;,&quot;bor&quot;,&quot;bsl&quot;,&quot;bsr&quot;,&quot;bxor&quot;,
    &quot;div&quot;,&quot;not&quot;,&quot;or&quot;,&quot;orelse&quot;,&quot;rem&quot;,&quot;xor&quot;];

  var operatorSymbolRE    = /[\+\-\*\/&lt;&gt;=\|:!]/;
  var operatorSymbolWords = [
    &quot;=&quot;,&quot;+&quot;,&quot;-&quot;,&quot;*&quot;,&quot;/&quot;,&quot;&gt;&quot;,&quot;&gt;=&quot;,&quot;&lt;&quot;,&quot;=&lt;&quot;,&quot;=:=&quot;,&quot;==&quot;,&quot;=/=&quot;,&quot;/=&quot;,&quot;||&quot;,&quot;&lt;-&quot;,&quot;!&quot;];

  var openParenRE    = /[&lt;\(\[\{]/;
  var openParenWords = [
    &quot;&lt;&lt;&quot;,&quot;(&quot;,&quot;[&quot;,&quot;{&quot;];

  var closeParenRE    = /[&gt;\)\]\}]/;
  var closeParenWords = [
    &quot;}&quot;,&quot;]&quot;,&quot;)&quot;,&quot;&gt;&gt;&quot;];

  var guardWords = [
    &quot;is_atom&quot;,&quot;is_binary&quot;,&quot;is_bitstring&quot;,&quot;is_boolean&quot;,&quot;is_float&quot;,
    &quot;is_function&quot;,&quot;is_integer&quot;,&quot;is_list&quot;,&quot;is_number&quot;,&quot;is_pid&quot;,
    &quot;is_port&quot;,&quot;is_record&quot;,&quot;is_reference&quot;,&quot;is_tuple&quot;,
    &quot;atom&quot;,&quot;binary&quot;,&quot;bitstring&quot;,&quot;boolean&quot;,&quot;function&quot;,&quot;integer&quot;,&quot;list&quot;,
    &quot;number&quot;,&quot;pid&quot;,&quot;port&quot;,&quot;record&quot;,&quot;reference&quot;,&quot;tuple&quot;];

  var bifWords = [
    &quot;abs&quot;,&quot;adler32&quot;,&quot;adler32_combine&quot;,&quot;alive&quot;,&quot;apply&quot;,&quot;atom_to_binary&quot;,
    &quot;atom_to_list&quot;,&quot;binary_to_atom&quot;,&quot;binary_to_existing_atom&quot;,
    &quot;binary_to_list&quot;,&quot;binary_to_term&quot;,&quot;bit_size&quot;,&quot;bitstring_to_list&quot;,
    &quot;byte_size&quot;,&quot;check_process_code&quot;,&quot;contact_binary&quot;,&quot;crc32&quot;,
    &quot;crc32_combine&quot;,&quot;date&quot;,&quot;decode_packet&quot;,&quot;delete_module&quot;,
    &quot;disconnect_node&quot;,&quot;element&quot;,&quot;erase&quot;,&quot;exit&quot;,&quot;float&quot;,&quot;float_to_list&quot;,
    &quot;garbage_collect&quot;,&quot;get&quot;,&quot;get_keys&quot;,&quot;group_leader&quot;,&quot;halt&quot;,&quot;hd&quot;,
    &quot;integer_to_list&quot;,&quot;internal_bif&quot;,&quot;iolist_size&quot;,&quot;iolist_to_binary&quot;,
    &quot;is_alive&quot;,&quot;is_atom&quot;,&quot;is_binary&quot;,&quot;is_bitstring&quot;,&quot;is_boolean&quot;,
    &quot;is_float&quot;,&quot;is_function&quot;,&quot;is_integer&quot;,&quot;is_list&quot;,&quot;is_number&quot;,&quot;is_pid&quot;,
    &quot;is_port&quot;,&quot;is_process_alive&quot;,&quot;is_record&quot;,&quot;is_reference&quot;,&quot;is_tuple&quot;,
    &quot;length&quot;,&quot;link&quot;,&quot;list_to_atom&quot;,&quot;list_to_binary&quot;,&quot;list_to_bitstring&quot;,
    &quot;list_to_existing_atom&quot;,&quot;list_to_float&quot;,&quot;list_to_integer&quot;,
    &quot;list_to_pid&quot;,&quot;list_to_tuple&quot;,&quot;load_module&quot;,&quot;make_ref&quot;,&quot;module_loaded&quot;,
    &quot;monitor_node&quot;,&quot;node&quot;,&quot;node_link&quot;,&quot;node_unlink&quot;,&quot;nodes&quot;,&quot;notalive&quot;,
    &quot;now&quot;,&quot;open_port&quot;,&quot;pid_to_list&quot;,&quot;port_close&quot;,&quot;port_command&quot;,
    &quot;port_connect&quot;,&quot;port_control&quot;,&quot;pre_loaded&quot;,&quot;process_flag&quot;,
    &quot;process_info&quot;,&quot;processes&quot;,&quot;purge_module&quot;,&quot;put&quot;,&quot;register&quot;,
    &quot;registered&quot;,&quot;round&quot;,&quot;self&quot;,&quot;setelement&quot;,&quot;size&quot;,&quot;spawn&quot;,&quot;spawn_link&quot;,
    &quot;spawn_monitor&quot;,&quot;spawn_opt&quot;,&quot;split_binary&quot;,&quot;statistics&quot;,
    &quot;term_to_binary&quot;,&quot;time&quot;,&quot;throw&quot;,&quot;tl&quot;,&quot;trunc&quot;,&quot;tuple_size&quot;,
    &quot;tuple_to_list&quot;,&quot;unlink&quot;,&quot;unregister&quot;,&quot;whereis&quot;];

// upper case: [A-Z] [&#xD8;-&#xDE;] [&#xC0;-&#xD6;]
// lower case: [a-z] [&#xDF;-&#xF6;] [&#xF8;-&#xFF;]
  var anumRE       = /[\w@&#xD8;-&#xDE;&#xC0;-&#xD6;&#xDF;-&#xF6;&#xF8;-&#xFF;]/;
  var escapesRE    =
    /[0-7]{1,3}|[bdefnrstv\\&quot;&apos;]|\^[a-zA-Z]|x[0-9a-zA-Z]{2}|x{[0-9a-zA-Z]+}/;

/////////////////////////////////////////////////////////////////////////////
// tokenizer

  function tokenizer(stream,state) {
    // in multi-line string
    if (state.in_string) {
      state.in_string = (!doubleQuote(stream));
      return rval(state,stream,&quot;string&quot;);
    }

    // in multi-line atom
    if (state.in_atom) {
      state.in_atom = (!singleQuote(stream));
      return rval(state,stream,&quot;atom&quot;);
    }

    // whitespace
    if (stream.eatSpace()) {
      return rval(state,stream,&quot;whitespace&quot;);
    }

    // attributes and type specs
    if (!peekToken(state) &amp;&amp;
        stream.match(/-\s*[a-z&#xDF;-&#xF6;&#xF8;-&#xFF;][\w&#xD8;-&#xDE;&#xC0;-&#xD6;&#xDF;-&#xF6;&#xF8;-&#xFF;]*/)) {
      if (is_member(stream.current(),typeWords)) {
        return rval(state,stream,&quot;type&quot;);
      }else{
        return rval(state,stream,&quot;attribute&quot;);
      }
    }

    var ch = stream.next();

    // comment
    if (ch == &apos;%&apos;) {
      stream.skipToEnd();
      return rval(state,stream,&quot;comment&quot;);
    }

    // colon
    if (ch == &quot;:&quot;) {
      return rval(state,stream,&quot;colon&quot;);
    }

    // macro
    if (ch == &apos;?&apos;) {
      stream.eatSpace();
      stream.eatWhile(anumRE);
      return rval(state,stream,&quot;macro&quot;);
    }

    // record
    if (ch == &quot;#&quot;) {
      stream.eatSpace();
      stream.eatWhile(anumRE);
      return rval(state,stream,&quot;record&quot;);
    }

    // dollar escape
    if (ch == &quot;$&quot;) {
      if (stream.next() == &quot;\\&quot; &amp;&amp; !stream.match(escapesRE)) {
        return rval(state,stream,&quot;error&quot;);
      }
      return rval(state,stream,&quot;number&quot;);
    }

    // dot
    if (ch == &quot;.&quot;) {
      return rval(state,stream,&quot;dot&quot;);
    }

    // quoted atom
    if (ch == &apos;\&apos;&apos;) {
      if (!(state.in_atom = (!singleQuote(stream)))) {
        if (stream.match(/\s*\/\s*[0-9]/,false)) {
          stream.match(/\s*\/\s*[0-9]/,true);
          return rval(state,stream,&quot;fun&quot;);      // &apos;f&apos;/0 style fun
        }
        if (stream.match(/\s*\(/,false) || stream.match(/\s*:/,false)) {
          return rval(state,stream,&quot;function&quot;);
        }
      }
      return rval(state,stream,&quot;atom&quot;);
    }

    // string
    if (ch == &apos;&quot;&apos;) {
      state.in_string = (!doubleQuote(stream));
      return rval(state,stream,&quot;string&quot;);
    }

    // variable
    if (/[A-Z_&#xD8;-&#xDE;&#xC0;-&#xD6;]/.test(ch)) {
      stream.eatWhile(anumRE);
      return rval(state,stream,&quot;variable&quot;);
    }

    // atom/keyword/BIF/function
    if (/[a-z_&#xDF;-&#xF6;&#xF8;-&#xFF;]/.test(ch)) {
      stream.eatWhile(anumRE);

      if (stream.match(/\s*\/\s*[0-9]/,false)) {
        stream.match(/\s*\/\s*[0-9]/,true);
        return rval(state,stream,&quot;fun&quot;);      // f/0 style fun
      }

      var w = stream.current();

      if (is_member(w,keywordWords)) {
        return rval(state,stream,&quot;keyword&quot;);
      }else if (is_member(w,operatorAtomWords)) {
        return rval(state,stream,&quot;operator&quot;);
      }else if (stream.match(/\s*\(/,false)) {
        // &apos;put&apos; and &apos;erlang:put&apos; are bifs, &apos;foo:put&apos; is not
        if (is_member(w,bifWords) &amp;&amp;
            ((peekToken(state).token != &quot;:&quot;) ||
             (peekToken(state,2).token == &quot;erlang&quot;))) {
          return rval(state,stream,&quot;builtin&quot;);
        }else if (is_member(w,guardWords)) {
          return rval(state,stream,&quot;guard&quot;);
        }else{
          return rval(state,stream,&quot;function&quot;);
        }
      }else if (is_member(w,operatorAtomWords)) {
        return rval(state,stream,&quot;operator&quot;);
      }else if (lookahead(stream) == &quot;:&quot;) {
        if (w == &quot;erlang&quot;) {
          return rval(state,stream,&quot;builtin&quot;);
        } else {
          return rval(state,stream,&quot;function&quot;);
        }
      }else if (is_member(w,[&quot;true&quot;,&quot;false&quot;])) {
        return rval(state,stream,&quot;boolean&quot;);
      }else if (is_member(w,[&quot;true&quot;,&quot;false&quot;])) {
        return rval(state,stream,&quot;boolean&quot;);
      }else{
        return rval(state,stream,&quot;atom&quot;);
      }
    }

    // number
    var digitRE      = /[0-9]/;
    var radixRE      = /[0-9a-zA-Z]/;         // 36#zZ style int
    if (digitRE.test(ch)) {
      stream.eatWhile(digitRE);
      if (stream.eat(&apos;#&apos;)) {                // 36#aZ  style integer
        if (!stream.eatWhile(radixRE)) {
          stream.backUp(1);                 //&quot;36#&quot; - syntax error
        }
      } else if (stream.eat(&apos;.&apos;)) {       // float
        if (!stream.eatWhile(digitRE)) {
          stream.backUp(1);        // &quot;3.&quot; - probably end of function
        } else {
          if (stream.eat(/[eE]/)) {        // float with exponent
            if (stream.eat(/[-+]/)) {
              if (!stream.eatWhile(digitRE)) {
                stream.backUp(2);            // &quot;2e-&quot; - syntax error
              }
            } else {
              if (!stream.eatWhile(digitRE)) {
                stream.backUp(1);            // &quot;2e&quot; - syntax error
              }
            }
          }
        }
      }
      return rval(state,stream,&quot;number&quot;);   // normal integer
    }

    // open parens
    if (nongreedy(stream,openParenRE,openParenWords)) {
      return rval(state,stream,&quot;open_paren&quot;);
    }

    // close parens
    if (nongreedy(stream,closeParenRE,closeParenWords)) {
      return rval(state,stream,&quot;close_paren&quot;);
    }

    // separators
    if (greedy(stream,separatorRE,separatorWords)) {
      return rval(state,stream,&quot;separator&quot;);
    }

    // operators
    if (greedy(stream,operatorSymbolRE,operatorSymbolWords)) {
      return rval(state,stream,&quot;operator&quot;);
    }

    return rval(state,stream,null);
  }

/////////////////////////////////////////////////////////////////////////////
// utilities
  function nongreedy(stream,re,words) {
    if (stream.current().length == 1 &amp;&amp; re.test(stream.current())) {
      stream.backUp(1);
      while (re.test(stream.peek())) {
        stream.next();
        if (is_member(stream.current(),words)) {
          return true;
        }
      }
      stream.backUp(stream.current().length-1);
    }
    return false;
  }

  function greedy(stream,re,words) {
    if (stream.current().length == 1 &amp;&amp; re.test(stream.current())) {
      while (re.test(stream.peek())) {
        stream.next();
      }
      while (0 &lt; stream.current().length) {
        if (is_member(stream.current(),words)) {
          return true;
        }else{
          stream.backUp(1);
        }
      }
      stream.next();
    }
    return false;
  }

  function doubleQuote(stream) {
    return quote(stream, &apos;&quot;&apos;, &apos;\\&apos;);
  }

  function singleQuote(stream) {
    return quote(stream,&apos;\&apos;&apos;,&apos;\\&apos;);
  }

  function quote(stream,quoteChar,escapeChar) {
    while (!stream.eol()) {
      var ch = stream.next();
      if (ch == quoteChar) {
        return true;
      }else if (ch == escapeChar) {
        stream.next();
      }
    }
    return false;
  }

  function lookahead(stream) {
    var m = stream.match(/([\n\s]+|%[^\n]*\n)*(.)/,false);
    return m ? m.pop() : &quot;&quot;;
  }

  function is_member(element,list) {
    return (-1 &lt; list.indexOf(element));
  }

  function rval(state,stream,type) {

    // parse stack
    pushToken(state,realToken(type,stream));

    // map erlang token type to CodeMirror style class
    //     erlang             -&gt; CodeMirror tag
    switch (type) {
      case &quot;atom&quot;:        return &quot;atom&quot;;
      case &quot;attribute&quot;:   return &quot;attribute&quot;;
      case &quot;boolean&quot;:     return &quot;atom&quot;;
      case &quot;builtin&quot;:     return &quot;builtin&quot;;
      case &quot;close_paren&quot;: return null;
      case &quot;colon&quot;:       return null;
      case &quot;comment&quot;:     return &quot;comment&quot;;
      case &quot;dot&quot;:         return null;
      case &quot;error&quot;:       return &quot;error&quot;;
      case &quot;fun&quot;:         return &quot;meta&quot;;
      case &quot;function&quot;:    return &quot;tag&quot;;
      case &quot;guard&quot;:       return &quot;property&quot;;
      case &quot;keyword&quot;:     return &quot;keyword&quot;;
      case &quot;macro&quot;:       return &quot;variable-2&quot;;
      case &quot;number&quot;:      return &quot;number&quot;;
      case &quot;open_paren&quot;:  return null;
      case &quot;operator&quot;:    return &quot;operator&quot;;
      case &quot;record&quot;:      return &quot;bracket&quot;;
      case &quot;separator&quot;:   return null;
      case &quot;string&quot;:      return &quot;string&quot;;
      case &quot;type&quot;:        return &quot;def&quot;;
      case &quot;variable&quot;:    return &quot;variable&quot;;
      default:            return null;
    }
  }

  function aToken(tok,col,ind,typ) {
    return {token:  tok,
            column: col,
            indent: ind,
            type:   typ};
  }

  function realToken(type,stream) {
    return aToken(stream.current(),
                 stream.column(),
                 stream.indentation(),
                 type);
  }

  function fakeToken(type) {
    return aToken(type,0,0,type);
  }

  function peekToken(state,depth) {
    var len = state.tokenStack.length;
    var dep = (depth ? depth : 1);

    if (len &lt; dep) {
      return false;
    }else{
      return state.tokenStack[len-dep];
    }
  }

  function pushToken(state,token) {

    if (!(token.type == &quot;comment&quot; || token.type == &quot;whitespace&quot;)) {
      state.tokenStack = maybe_drop_pre(state.tokenStack,token);
      state.tokenStack = maybe_drop_post(state.tokenStack);
    }
  }

  function maybe_drop_pre(s,token) {
    var last = s.length-1;

    if (0 &lt; last &amp;&amp; s[last].type === &quot;record&quot; &amp;&amp; token.type === &quot;dot&quot;) {
      s.pop();
    }else if (0 &lt; last &amp;&amp; s[last].type === &quot;group&quot;) {
      s.pop();
      s.push(token);
    }else{
      s.push(token);
    }
    return s;
  }

  function maybe_drop_post(s) {
    var last = s.length-1;

    if (s[last].type === &quot;dot&quot;) {
      return [];
    }
    if (s[last].type === &quot;fun&quot; &amp;&amp; s[last-1].token === &quot;fun&quot;) {
      return s.slice(0,last-1);
    }
    switch (s[s.length-1].token) {
      case &quot;}&quot;:    return d(s,{g:[&quot;{&quot;]});
      case &quot;]&quot;:    return d(s,{i:[&quot;[&quot;]});
      case &quot;)&quot;:    return d(s,{i:[&quot;(&quot;]});
      case &quot;&gt;&gt;&quot;:   return d(s,{i:[&quot;&lt;&lt;&quot;]});
      case &quot;end&quot;:  return d(s,{i:[&quot;begin&quot;,&quot;case&quot;,&quot;fun&quot;,&quot;if&quot;,&quot;receive&quot;,&quot;try&quot;]});
      case &quot;,&quot;:    return d(s,{e:[&quot;begin&quot;,&quot;try&quot;,&quot;when&quot;,&quot;-&gt;&quot;,
                                  &quot;,&quot;,&quot;(&quot;,&quot;[&quot;,&quot;{&quot;,&quot;&lt;&lt;&quot;]});
      case &quot;-&gt;&quot;:   return d(s,{r:[&quot;when&quot;],
                               m:[&quot;try&quot;,&quot;if&quot;,&quot;case&quot;,&quot;receive&quot;]});
      case &quot;;&quot;:    return d(s,{E:[&quot;case&quot;,&quot;fun&quot;,&quot;if&quot;,&quot;receive&quot;,&quot;try&quot;,&quot;when&quot;]});
      case &quot;catch&quot;:return d(s,{e:[&quot;try&quot;]});
      case &quot;of&quot;:   return d(s,{e:[&quot;case&quot;]});
      case &quot;after&quot;:return d(s,{e:[&quot;receive&quot;,&quot;try&quot;]});
      default:     return s;
    }
  }

  function d(stack,tt) {
    // stack is a stack of Token objects.
    // tt is an object; {type:tokens}
    // type is a char, tokens is a list of token strings.
    // The function returns (possibly truncated) stack.
    // It will descend the stack, looking for a Token such that Token.token
    //  is a member of tokens. If it does not find that, it will normally (but
    //  see &quot;E&quot; below) return stack. If it does find a match, it will remove
    //  all the Tokens between the top and the matched Token.
    // If type is &quot;m&quot;, that is all it does.
    // If type is &quot;i&quot;, it will also remove the matched Token and the top Token.
    // If type is &quot;g&quot;, like &quot;i&quot;, but add a fake &quot;group&quot; token at the top.
    // If type is &quot;r&quot;, it will remove the matched Token, but not the top Token.
    // If type is &quot;e&quot;, it will keep the matched Token but not the top Token.
    // If type is &quot;E&quot;, it behaves as for type &quot;e&quot;, except if there is no match,
    //  in which case it will return an empty stack.

    for (var type in tt) {
      var len = stack.length-1;
      var tokens = tt[type];
      for (var i = len-1; -1 &lt; i ; i--) {
        if (is_member(stack[i].token,tokens)) {
          var ss = stack.slice(0,i);
          switch (type) {
              case &quot;m&quot;: return ss.concat(stack[i]).concat(stack[len]);
              case &quot;r&quot;: return ss.concat(stack[len]);
              case &quot;i&quot;: return ss;
              case &quot;g&quot;: return ss.concat(fakeToken(&quot;group&quot;));
              case &quot;E&quot;: return ss.concat(stack[i]);
              case &quot;e&quot;: return ss.concat(stack[i]);
          }
        }
      }
    }
    return (type == &quot;E&quot; ? [] : stack);
  }

/////////////////////////////////////////////////////////////////////////////
// indenter

  function indenter(state,textAfter) {
    var t;
    var unit = cmCfg.indentUnit;
    var wordAfter = wordafter(textAfter);
    var currT = peekToken(state,1);
    var prevT = peekToken(state,2);

    if (state.in_string || state.in_atom) {
      return CodeMirror.Pass;
    }else if (!prevT) {
      return 0;
    }else if (currT.token == &quot;when&quot;) {
      return currT.column+unit;
    }else if (wordAfter === &quot;when&quot; &amp;&amp; prevT.type === &quot;function&quot;) {
      return prevT.indent+unit;
    }else if (wordAfter === &quot;(&quot; &amp;&amp; currT.token === &quot;fun&quot;) {
      return  currT.column+3;
    }else if (wordAfter === &quot;catch&quot; &amp;&amp; (t = getToken(state,[&quot;try&quot;]))) {
      return t.column;
    }else if (is_member(wordAfter,[&quot;end&quot;,&quot;after&quot;,&quot;of&quot;])) {
      t = getToken(state,[&quot;begin&quot;,&quot;case&quot;,&quot;fun&quot;,&quot;if&quot;,&quot;receive&quot;,&quot;try&quot;]);
      return t ? t.column : CodeMirror.Pass;
    }else if (is_member(wordAfter,closeParenWords)) {
      t = getToken(state,openParenWords);
      return t ? t.column : CodeMirror.Pass;
    }else if (is_member(currT.token,[&quot;,&quot;,&quot;|&quot;,&quot;||&quot;]) ||
              is_member(wordAfter,[&quot;,&quot;,&quot;|&quot;,&quot;||&quot;])) {
      t = postcommaToken(state);
      return t ? t.column+t.token.length : unit;
    }else if (currT.token == &quot;-&gt;&quot;) {
      if (is_member(prevT.token, [&quot;receive&quot;,&quot;case&quot;,&quot;if&quot;,&quot;try&quot;])) {
        return prevT.column+unit+unit;
      }else{
        return prevT.column+unit;
      }
    }else if (is_member(currT.token,openParenWords)) {
      return currT.column+currT.token.length;
    }else{
      t = defaultToken(state);
      return truthy(t) ? t.column+unit : 0;
    }
  }

  function wordafter(str) {
    var m = str.match(/,|[a-z]+|\}|\]|\)|&gt;&gt;|\|+|\(/);

    return truthy(m) &amp;&amp; (m.index === 0) ? m[0] : &quot;&quot;;
  }

  function postcommaToken(state) {
    var objs = state.tokenStack.slice(0,-1);
    var i = getTokenIndex(objs,&quot;type&quot;,[&quot;open_paren&quot;]);

    return truthy(objs[i]) ? objs[i] : false;
  }

  function defaultToken(state) {
    var objs = state.tokenStack;
    var stop = getTokenIndex(objs,&quot;type&quot;,[&quot;open_paren&quot;,&quot;separator&quot;,&quot;keyword&quot;]);
    var oper = getTokenIndex(objs,&quot;type&quot;,[&quot;operator&quot;]);

    if (truthy(stop) &amp;&amp; truthy(oper) &amp;&amp; stop &lt; oper) {
      return objs[stop+1];
    } else if (truthy(stop)) {
      return objs[stop];
    } else {
      return false;
    }
  }

  function getToken(state,tokens) {
    var objs = state.tokenStack;
    var i = getTokenIndex(objs,&quot;token&quot;,tokens);

    return truthy(objs[i]) ? objs[i] : false;
  }

  function getTokenIndex(objs,propname,propvals) {

    for (var i = objs.length-1; -1 &lt; i ; i--) {
      if (is_member(objs[i][propname],propvals)) {
        return i;
      }
    }
    return false;
  }

  function truthy(x) {
    return (x !== false) &amp;&amp; (x != null);
  }

/////////////////////////////////////////////////////////////////////////////
// this object defines the mode

  return {
    startState:
      function() {
        return {tokenStack: [],
                in_string:  false,
                in_atom:    false};
      },

    token:
      function(stream, state) {
        return tokenizer(stream, state);
      },

    indent:
      function(state, textAfter) {
        return indenter(state,textAfter);
      },

    lineComment: &quot;%&quot;
  };
});

});
</code></pre>

</div>

<footer class="footer">
  Generated by <a href="https://esdoc.org">ESDoc<span data-ice="esdocVersion">(1.1.0)</span><img src="./image/esdoc-logo-mini-black.png"></a>
</footer>

<script src="script/search_index.js"></script>
<script src="script/search.js"></script>
<script src="script/pretty-print.js"></script>
<script src="script/inherited-summary.js"></script>
<script src="script/test-summary.js"></script>
<script src="script/inner-link.js"></script>
<script src="script/patch-for-local.js"></script>
</body>
</html>
