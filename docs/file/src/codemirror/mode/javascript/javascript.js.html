<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <base data-ice="baseUrl" href="../../../../../">
  <title data-ice="title">src/codemirror/mode/javascript/javascript.js | webrtcdevelopment</title>
  <link type="text/css" rel="stylesheet" href="css/style.css">
  <link type="text/css" rel="stylesheet" href="css/prettify-tomorrow.css">
  <script src="script/prettify/prettify.js"></script>
  <script src="script/manual.js"></script>
<meta name="description" content="webrtc based communication and collaboration client. Contains lot of experiments modules "><meta property="twitter:card" content="summary"><meta property="twitter:title" content="webrtcdevelopment"><meta property="twitter:description" content="webrtc based communication and collaboration client. Contains lot of experiments modules "></head>
<body class="layout-container" data-ice="rootContainer">

<header>
  <a href="./">Home</a>
  
  <a href="identifiers.html">Reference</a>
  <a href="source.html">Source</a>
  
  <div class="search-box">
  <span>
    <img src="./image/search.png">
    <span class="search-input-edge"></span><input class="search-input"><span class="search-input-edge"></span>
  </span>
    <ul class="search-result"></ul>
  </div>
<a style="position:relative; top:3px;" href="https://github.com/altanai/webrtc"><img width="20px" src="./image/github.png"></a></header>

<nav class="navigation" data-ice="nav"><div>
  <ul>
    
  <li data-ice="doc"><a data-ice="dirPath" class="nav-dir-path" href="identifiers.html#scripts">scripts</a><span data-ice="kind" class="kind-typedef">T</span><span data-ice="name"><span><a href="typedef/index.html#static-typedef-CanvasRecorder">CanvasRecorder</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-typedef">T</span><span data-ice="name"><span><a href="typedef/index.html#static-typedef-GetRecorderType">GetRecorderType</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-typedef">T</span><span data-ice="name"><span><a href="typedef/index.html#static-typedef-GifRecorder">GifRecorder</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-typedef">T</span><span data-ice="name"><span><a href="typedef/index.html#static-typedef-MRecordRTC">MRecordRTC</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-typedef">T</span><span data-ice="name"><span><a href="typedef/index.html#static-typedef-MediaStreamRecorder">MediaStreamRecorder</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-typedef">T</span><span data-ice="name"><span><a href="typedef/index.html#static-typedef-RecordRTC">RecordRTC</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-typedef">T</span><span data-ice="name"><span><a href="typedef/index.html#static-typedef-RecordRTCConfiguration">RecordRTCConfiguration</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-typedef">T</span><span data-ice="name"><span><a href="typedef/index.html#static-typedef-StereoAudioRecorder">StereoAudioRecorder</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-typedef">T</span><span data-ice="name"><span><a href="typedef/index.html#static-typedef-Whammy">Whammy</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-typedef">T</span><span data-ice="name"><span><a href="typedef/index.html#static-typedef-WhammyRecorder">WhammyRecorder</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-typedef">T</span><span data-ice="name"><span><a href="typedef/index.html#static-typedef-createFileSharingDiv">createFileSharingDiv</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-typedef">T</span><span data-ice="name"><span><a href="typedef/index.html#static-typedef-_turn.js">_turn.js</a></span></span></li>
<li data-ice="doc"><a data-ice="dirPath" class="nav-dir-path" href="identifiers.html#scripts-rtcconn">scripts/rtcconn</a><span data-ice="kind" class="kind-typedef">T</span><span data-ice="name"><span><a href="typedef/index.html#static-typedef-Whammy">Whammy</a></span></span></li>
</ul>
</div>
</nav>

<div class="content" data-ice="content"><h1 data-ice="title">src/codemirror/mode/javascript/javascript.js</h1>
<pre class="source-code line-number raw-source-code"><code class="prettyprint linenums" data-ice="content">// CodeMirror, copyright (c) by Marijn Haverbeke and others
// Distributed under an MIT license: http://codemirror.net/LICENSE

// TODO actually recognize syntax of TypeScript constructs

(function(mod) {
  if (typeof exports == &quot;object&quot; &amp;&amp; typeof module == &quot;object&quot;) // CommonJS
    mod(require(&quot;../../lib/codemirror&quot;));
  else if (typeof define == &quot;function&quot; &amp;&amp; define.amd) // AMD
    define([&quot;../../lib/codemirror&quot;], mod);
  else // Plain browser env
    mod(CodeMirror);
})(function(CodeMirror) {
&quot;use strict&quot;;

CodeMirror.defineMode(&quot;javascript&quot;, function(config, parserConfig) {
  var indentUnit = config.indentUnit;
  var statementIndent = parserConfig.statementIndent;
  var jsonldMode = parserConfig.jsonld;
  var jsonMode = parserConfig.json || jsonldMode;
  var isTS = parserConfig.typescript;
  var wordRE = parserConfig.wordCharacters || /[\w$\xa1-\uffff]/;

  // Tokenizer

  var keywords = function(){
    function kw(type) {return {type: type, style: &quot;keyword&quot;};}
    var A = kw(&quot;keyword a&quot;), B = kw(&quot;keyword b&quot;), C = kw(&quot;keyword c&quot;);
    var operator = kw(&quot;operator&quot;), atom = {type: &quot;atom&quot;, style: &quot;atom&quot;};

    var jsKeywords = {
      &quot;if&quot;: kw(&quot;if&quot;), &quot;while&quot;: A, &quot;with&quot;: A, &quot;else&quot;: B, &quot;do&quot;: B, &quot;try&quot;: B, &quot;finally&quot;: B,
      &quot;return&quot;: C, &quot;break&quot;: C, &quot;continue&quot;: C, &quot;new&quot;: C, &quot;delete&quot;: C, &quot;throw&quot;: C, &quot;debugger&quot;: C,
      &quot;var&quot;: kw(&quot;var&quot;), &quot;const&quot;: kw(&quot;var&quot;), &quot;let&quot;: kw(&quot;var&quot;),
      &quot;function&quot;: kw(&quot;function&quot;), &quot;catch&quot;: kw(&quot;catch&quot;),
      &quot;for&quot;: kw(&quot;for&quot;), &quot;switch&quot;: kw(&quot;switch&quot;), &quot;case&quot;: kw(&quot;case&quot;), &quot;default&quot;: kw(&quot;default&quot;),
      &quot;in&quot;: operator, &quot;typeof&quot;: operator, &quot;instanceof&quot;: operator,
      &quot;true&quot;: atom, &quot;false&quot;: atom, &quot;null&quot;: atom, &quot;undefined&quot;: atom, &quot;NaN&quot;: atom, &quot;Infinity&quot;: atom,
      &quot;this&quot;: kw(&quot;this&quot;), &quot;module&quot;: kw(&quot;module&quot;), &quot;class&quot;: kw(&quot;class&quot;), &quot;super&quot;: kw(&quot;atom&quot;),
      &quot;yield&quot;: C, &quot;export&quot;: kw(&quot;export&quot;), &quot;import&quot;: kw(&quot;import&quot;), &quot;extends&quot;: C
    };

    // Extend the &apos;normal&apos; keywords with the TypeScript language extensions
    if (isTS) {
      var type = {type: &quot;variable&quot;, style: &quot;variable-3&quot;};
      var tsKeywords = {
        // object-like things
        &quot;interface&quot;: kw(&quot;interface&quot;),
        &quot;extends&quot;: kw(&quot;extends&quot;),
        &quot;constructor&quot;: kw(&quot;constructor&quot;),

        // scope modifiers
        &quot;public&quot;: kw(&quot;public&quot;),
        &quot;private&quot;: kw(&quot;private&quot;),
        &quot;protected&quot;: kw(&quot;protected&quot;),
        &quot;static&quot;: kw(&quot;static&quot;),

        // types
        &quot;string&quot;: type, &quot;number&quot;: type, &quot;bool&quot;: type, &quot;any&quot;: type
      };

      for (var attr in tsKeywords) {
        jsKeywords[attr] = tsKeywords[attr];
      }
    }

    return jsKeywords;
  }();

  var isOperatorChar = /[+\-*&amp;%=&lt;&gt;!?|~^]/;
  var isJsonldKeyword = /^@(context|id|value|language|type|container|list|set|reverse|index|base|vocab|graph)&quot;/;

  function readRegexp(stream) {
    var escaped = false, next, inSet = false;
    while ((next = stream.next()) != null) {
      if (!escaped) {
        if (next == &quot;/&quot; &amp;&amp; !inSet) return;
        if (next == &quot;[&quot;) inSet = true;
        else if (inSet &amp;&amp; next == &quot;]&quot;) inSet = false;
      }
      escaped = !escaped &amp;&amp; next == &quot;\\&quot;;
    }
  }

  // Used as scratch variables to communicate multiple values without
  // consing up tons of objects.
  var type, content;
  function ret(tp, style, cont) {
    type = tp; content = cont;
    return style;
  }
  function tokenBase(stream, state) {
    var ch = stream.next();
    if (ch == &apos;&quot;&apos; || ch == &quot;&apos;&quot;) {
      state.tokenize = tokenString(ch);
      return state.tokenize(stream, state);
    } else if (ch == &quot;.&quot; &amp;&amp; stream.match(/^\d+(?:[eE][+\-]?\d+)?/)) {
      return ret(&quot;number&quot;, &quot;number&quot;);
    } else if (ch == &quot;.&quot; &amp;&amp; stream.match(&quot;..&quot;)) {
      return ret(&quot;spread&quot;, &quot;meta&quot;);
    } else if (/[\[\]{}\(\),;\:\.]/.test(ch)) {
      return ret(ch);
    } else if (ch == &quot;=&quot; &amp;&amp; stream.eat(&quot;&gt;&quot;)) {
      return ret(&quot;=&gt;&quot;, &quot;operator&quot;);
    } else if (ch == &quot;0&quot; &amp;&amp; stream.eat(/x/i)) {
      stream.eatWhile(/[\da-f]/i);
      return ret(&quot;number&quot;, &quot;number&quot;);
    } else if (/\d/.test(ch)) {
      stream.match(/^\d*(?:\.\d*)?(?:[eE][+\-]?\d+)?/);
      return ret(&quot;number&quot;, &quot;number&quot;);
    } else if (ch == &quot;/&quot;) {
      if (stream.eat(&quot;*&quot;)) {
        state.tokenize = tokenComment;
        return tokenComment(stream, state);
      } else if (stream.eat(&quot;/&quot;)) {
        stream.skipToEnd();
        return ret(&quot;comment&quot;, &quot;comment&quot;);
      } else if (state.lastType == &quot;operator&quot; || state.lastType == &quot;keyword c&quot; ||
               state.lastType == &quot;sof&quot; || /^[\[{}\(,;:]$/.test(state.lastType)) {
        readRegexp(stream);
        stream.eatWhile(/[gimy]/); // &apos;y&apos; is &quot;sticky&quot; option in Mozilla
        return ret(&quot;regexp&quot;, &quot;string-2&quot;);
      } else {
        stream.eatWhile(isOperatorChar);
        return ret(&quot;operator&quot;, &quot;operator&quot;, stream.current());
      }
    } else if (ch == &quot;`&quot;) {
      state.tokenize = tokenQuasi;
      return tokenQuasi(stream, state);
    } else if (ch == &quot;#&quot;) {
      stream.skipToEnd();
      return ret(&quot;error&quot;, &quot;error&quot;);
    } else if (isOperatorChar.test(ch)) {
      stream.eatWhile(isOperatorChar);
      return ret(&quot;operator&quot;, &quot;operator&quot;, stream.current());
    } else if (wordRE.test(ch)) {
      stream.eatWhile(wordRE);
      var word = stream.current(), known = keywords.propertyIsEnumerable(word) &amp;&amp; keywords[word];
      return (known &amp;&amp; state.lastType != &quot;.&quot;) ? ret(known.type, known.style, word) :
                     ret(&quot;variable&quot;, &quot;variable&quot;, word);
    }
  }

  function tokenString(quote) {
    return function(stream, state) {
      var escaped = false, next;
      if (jsonldMode &amp;&amp; stream.peek() == &quot;@&quot; &amp;&amp; stream.match(isJsonldKeyword)){
        state.tokenize = tokenBase;
        return ret(&quot;jsonld-keyword&quot;, &quot;meta&quot;);
      }
      while ((next = stream.next()) != null) {
        if (next == quote &amp;&amp; !escaped) break;
        escaped = !escaped &amp;&amp; next == &quot;\\&quot;;
      }
      if (!escaped) state.tokenize = tokenBase;
      return ret(&quot;string&quot;, &quot;string&quot;);
    };
  }

  function tokenComment(stream, state) {
    var maybeEnd = false, ch;
    while (ch = stream.next()) {
      if (ch == &quot;/&quot; &amp;&amp; maybeEnd) {
        state.tokenize = tokenBase;
        break;
      }
      maybeEnd = (ch == &quot;*&quot;);
    }
    return ret(&quot;comment&quot;, &quot;comment&quot;);
  }

  function tokenQuasi(stream, state) {
    var escaped = false, next;
    while ((next = stream.next()) != null) {
      if (!escaped &amp;&amp; (next == &quot;`&quot; || next == &quot;$&quot; &amp;&amp; stream.eat(&quot;{&quot;))) {
        state.tokenize = tokenBase;
        break;
      }
      escaped = !escaped &amp;&amp; next == &quot;\\&quot;;
    }
    return ret(&quot;quasi&quot;, &quot;string-2&quot;, stream.current());
  }

  var brackets = &quot;([{}])&quot;;
  // This is a crude lookahead trick to try and notice that we&apos;re
  // parsing the argument patterns for a fat-arrow function before we
  // actually hit the arrow token. It only works if the arrow is on
  // the same line as the arguments and there&apos;s no strange noise
  // (comments) in between. Fallback is to only notice when we hit the
  // arrow, and not declare the arguments as locals for the arrow
  // body.
  function findFatArrow(stream, state) {
    if (state.fatArrowAt) state.fatArrowAt = null;
    var arrow = stream.string.indexOf(&quot;=&gt;&quot;, stream.start);
    if (arrow &lt; 0) return;

    var depth = 0, sawSomething = false;
    for (var pos = arrow - 1; pos &gt;= 0; --pos) {
      var ch = stream.string.charAt(pos);
      var bracket = brackets.indexOf(ch);
      if (bracket &gt;= 0 &amp;&amp; bracket &lt; 3) {
        if (!depth) { ++pos; break; }
        if (--depth == 0) break;
      } else if (bracket &gt;= 3 &amp;&amp; bracket &lt; 6) {
        ++depth;
      } else if (wordRE.test(ch)) {
        sawSomething = true;
      } else if (sawSomething &amp;&amp; !depth) {
        ++pos;
        break;
      }
    }
    if (sawSomething &amp;&amp; !depth) state.fatArrowAt = pos;
  }

  // Parser

  var atomicTypes = {&quot;atom&quot;: true, &quot;number&quot;: true, &quot;variable&quot;: true, &quot;string&quot;: true, &quot;regexp&quot;: true, &quot;this&quot;: true, &quot;jsonld-keyword&quot;: true};

  function JSLexical(indented, column, type, align, prev, info) {
    this.indented = indented;
    this.column = column;
    this.type = type;
    this.prev = prev;
    this.info = info;
    if (align != null) this.align = align;
  }

  function inScope(state, varname) {
    for (var v = state.localVars; v; v = v.next)
      if (v.name == varname) return true;
    for (var cx = state.context; cx; cx = cx.prev) {
      for (var v = cx.vars; v; v = v.next)
        if (v.name == varname) return true;
    }
  }

  function parseJS(state, style, type, content, stream) {
    var cc = state.cc;
    // Communicate our context to the combinators.
    // (Less wasteful than consing up a hundred closures on every call.)
    cx.state = state; cx.stream = stream; cx.marked = null, cx.cc = cc; cx.style = style;

    if (!state.lexical.hasOwnProperty(&quot;align&quot;))
      state.lexical.align = true;

    while(true) {
      var combinator = cc.length ? cc.pop() : jsonMode ? expression : statement;
      if (combinator(type, content)) {
        while(cc.length &amp;&amp; cc[cc.length - 1].lex)
          cc.pop()();
        if (cx.marked) return cx.marked;
        if (type == &quot;variable&quot; &amp;&amp; inScope(state, content)) return &quot;variable-2&quot;;
        return style;
      }
    }
  }

  // Combinator utils

  var cx = {state: null, column: null, marked: null, cc: null};
  function pass() {
    for (var i = arguments.length - 1; i &gt;= 0; i--) cx.cc.push(arguments[i]);
  }
  function cont() {
    pass.apply(null, arguments);
    return true;
  }
  function register(varname) {
    function inList(list) {
      for (var v = list; v; v = v.next)
        if (v.name == varname) return true;
      return false;
    }
    var state = cx.state;
    if (state.context) {
      cx.marked = &quot;def&quot;;
      if (inList(state.localVars)) return;
      state.localVars = {name: varname, next: state.localVars};
    } else {
      if (inList(state.globalVars)) return;
      if (parserConfig.globalVars)
        state.globalVars = {name: varname, next: state.globalVars};
    }
  }

  // Combinators

  var defaultVars = {name: &quot;this&quot;, next: {name: &quot;arguments&quot;}};
  function pushcontext() {
    cx.state.context = {prev: cx.state.context, vars: cx.state.localVars};
    cx.state.localVars = defaultVars;
  }
  function popcontext() {
    cx.state.localVars = cx.state.context.vars;
    cx.state.context = cx.state.context.prev;
  }
  function pushlex(type, info) {
    var result = function() {
      var state = cx.state, indent = state.indented;
      if (state.lexical.type == &quot;stat&quot;) indent = state.lexical.indented;
      else for (var outer = state.lexical; outer &amp;&amp; outer.type == &quot;)&quot; &amp;&amp; outer.align; outer = outer.prev)
        indent = outer.indented;
      state.lexical = new JSLexical(indent, cx.stream.column(), type, null, state.lexical, info);
    };
    result.lex = true;
    return result;
  }
  function poplex() {
    var state = cx.state;
    if (state.lexical.prev) {
      if (state.lexical.type == &quot;)&quot;)
        state.indented = state.lexical.indented;
      state.lexical = state.lexical.prev;
    }
  }
  poplex.lex = true;

  function expect(wanted) {
    function exp(type) {
      if (type == wanted) return cont();
      else if (wanted == &quot;;&quot;) return pass();
      else return cont(exp);
    };
    return exp;
  }

  function statement(type, value) {
    if (type == &quot;var&quot;) return cont(pushlex(&quot;vardef&quot;, value.length), vardef, expect(&quot;;&quot;), poplex);
    if (type == &quot;keyword a&quot;) return cont(pushlex(&quot;form&quot;), expression, statement, poplex);
    if (type == &quot;keyword b&quot;) return cont(pushlex(&quot;form&quot;), statement, poplex);
    if (type == &quot;{&quot;) return cont(pushlex(&quot;}&quot;), block, poplex);
    if (type == &quot;;&quot;) return cont();
    if (type == &quot;if&quot;) {
      if (cx.state.lexical.info == &quot;else&quot; &amp;&amp; cx.state.cc[cx.state.cc.length - 1] == poplex)
        cx.state.cc.pop()();
      return cont(pushlex(&quot;form&quot;), expression, statement, poplex, maybeelse);
    }
    if (type == &quot;function&quot;) return cont(functiondef);
    if (type == &quot;for&quot;) return cont(pushlex(&quot;form&quot;), forspec, statement, poplex);
    if (type == &quot;variable&quot;) return cont(pushlex(&quot;stat&quot;), maybelabel);
    if (type == &quot;switch&quot;) return cont(pushlex(&quot;form&quot;), expression, pushlex(&quot;}&quot;, &quot;switch&quot;), expect(&quot;{&quot;),
                                      block, poplex, poplex);
    if (type == &quot;case&quot;) return cont(expression, expect(&quot;:&quot;));
    if (type == &quot;default&quot;) return cont(expect(&quot;:&quot;));
    if (type == &quot;catch&quot;) return cont(pushlex(&quot;form&quot;), pushcontext, expect(&quot;(&quot;), funarg, expect(&quot;)&quot;),
                                     statement, poplex, popcontext);
    if (type == &quot;module&quot;) return cont(pushlex(&quot;form&quot;), pushcontext, afterModule, popcontext, poplex);
    if (type == &quot;class&quot;) return cont(pushlex(&quot;form&quot;), className, poplex);
    if (type == &quot;export&quot;) return cont(pushlex(&quot;form&quot;), afterExport, poplex);
    if (type == &quot;import&quot;) return cont(pushlex(&quot;form&quot;), afterImport, poplex);
    return pass(pushlex(&quot;stat&quot;), expression, expect(&quot;;&quot;), poplex);
  }
  function expression(type) {
    return expressionInner(type, false);
  }
  function expressionNoComma(type) {
    return expressionInner(type, true);
  }
  function expressionInner(type, noComma) {
    if (cx.state.fatArrowAt == cx.stream.start) {
      var body = noComma ? arrowBodyNoComma : arrowBody;
      if (type == &quot;(&quot;) return cont(pushcontext, pushlex(&quot;)&quot;), commasep(pattern, &quot;)&quot;), poplex, expect(&quot;=&gt;&quot;), body, popcontext);
      else if (type == &quot;variable&quot;) return pass(pushcontext, pattern, expect(&quot;=&gt;&quot;), body, popcontext);
    }

    var maybeop = noComma ? maybeoperatorNoComma : maybeoperatorComma;
    if (atomicTypes.hasOwnProperty(type)) return cont(maybeop);
    if (type == &quot;function&quot;) return cont(functiondef, maybeop);
    if (type == &quot;keyword c&quot;) return cont(noComma ? maybeexpressionNoComma : maybeexpression);
    if (type == &quot;(&quot;) return cont(pushlex(&quot;)&quot;), maybeexpression, comprehension, expect(&quot;)&quot;), poplex, maybeop);
    if (type == &quot;operator&quot; || type == &quot;spread&quot;) return cont(noComma ? expressionNoComma : expression);
    if (type == &quot;[&quot;) return cont(pushlex(&quot;]&quot;), arrayLiteral, poplex, maybeop);
    if (type == &quot;{&quot;) return contCommasep(objprop, &quot;}&quot;, null, maybeop);
    if (type == &quot;quasi&quot;) { return pass(quasi, maybeop); }
    return cont();
  }
  function maybeexpression(type) {
    if (type.match(/[;\}\)\],]/)) return pass();
    return pass(expression);
  }
  function maybeexpressionNoComma(type) {
    if (type.match(/[;\}\)\],]/)) return pass();
    return pass(expressionNoComma);
  }

  function maybeoperatorComma(type, value) {
    if (type == &quot;,&quot;) return cont(expression);
    return maybeoperatorNoComma(type, value, false);
  }
  function maybeoperatorNoComma(type, value, noComma) {
    var me = noComma == false ? maybeoperatorComma : maybeoperatorNoComma;
    var expr = noComma == false ? expression : expressionNoComma;
    if (type == &quot;=&gt;&quot;) return cont(pushcontext, noComma ? arrowBodyNoComma : arrowBody, popcontext);
    if (type == &quot;operator&quot;) {
      if (/\+\+|--/.test(value)) return cont(me);
      if (value == &quot;?&quot;) return cont(expression, expect(&quot;:&quot;), expr);
      return cont(expr);
    }
    if (type == &quot;quasi&quot;) { return pass(quasi, me); }
    if (type == &quot;;&quot;) return;
    if (type == &quot;(&quot;) return contCommasep(expressionNoComma, &quot;)&quot;, &quot;call&quot;, me);
    if (type == &quot;.&quot;) return cont(property, me);
    if (type == &quot;[&quot;) return cont(pushlex(&quot;]&quot;), maybeexpression, expect(&quot;]&quot;), poplex, me);
  }
  function quasi(type, value) {
    if (type != &quot;quasi&quot;) return pass();
    if (value.slice(value.length - 2) != &quot;${&quot;) return cont(quasi);
    return cont(expression, continueQuasi);
  }
  function continueQuasi(type) {
    if (type == &quot;}&quot;) {
      cx.marked = &quot;string-2&quot;;
      cx.state.tokenize = tokenQuasi;
      return cont(quasi);
    }
  }
  function arrowBody(type) {
    findFatArrow(cx.stream, cx.state);
    return pass(type == &quot;{&quot; ? statement : expression);
  }
  function arrowBodyNoComma(type) {
    findFatArrow(cx.stream, cx.state);
    return pass(type == &quot;{&quot; ? statement : expressionNoComma);
  }
  function maybelabel(type) {
    if (type == &quot;:&quot;) return cont(poplex, statement);
    return pass(maybeoperatorComma, expect(&quot;;&quot;), poplex);
  }
  function property(type) {
    if (type == &quot;variable&quot;) {cx.marked = &quot;property&quot;; return cont();}
  }
  function objprop(type, value) {
    if (type == &quot;variable&quot; || cx.style == &quot;keyword&quot;) {
      cx.marked = &quot;property&quot;;
      if (value == &quot;get&quot; || value == &quot;set&quot;) return cont(getterSetter);
      return cont(afterprop);
    } else if (type == &quot;number&quot; || type == &quot;string&quot;) {
      cx.marked = jsonldMode ? &quot;property&quot; : (cx.style + &quot; property&quot;);
      return cont(afterprop);
    } else if (type == &quot;jsonld-keyword&quot;) {
      return cont(afterprop);
    } else if (type == &quot;[&quot;) {
      return cont(expression, expect(&quot;]&quot;), afterprop);
    }
  }
  function getterSetter(type) {
    if (type != &quot;variable&quot;) return pass(afterprop);
    cx.marked = &quot;property&quot;;
    return cont(functiondef);
  }
  function afterprop(type) {
    if (type == &quot;:&quot;) return cont(expressionNoComma);
    if (type == &quot;(&quot;) return pass(functiondef);
  }
  function commasep(what, end) {
    function proceed(type) {
      if (type == &quot;,&quot;) {
        var lex = cx.state.lexical;
        if (lex.info == &quot;call&quot;) lex.pos = (lex.pos || 0) + 1;
        return cont(what, proceed);
      }
      if (type == end) return cont();
      return cont(expect(end));
    }
    return function(type) {
      if (type == end) return cont();
      return pass(what, proceed);
    };
  }
  function contCommasep(what, end, info) {
    for (var i = 3; i &lt; arguments.length; i++)
      cx.cc.push(arguments[i]);
    return cont(pushlex(end, info), commasep(what, end), poplex);
  }
  function block(type) {
    if (type == &quot;}&quot;) return cont();
    return pass(statement, block);
  }
  function maybetype(type) {
    if (isTS &amp;&amp; type == &quot;:&quot;) return cont(typedef);
  }
  function typedef(type) {
    if (type == &quot;variable&quot;){cx.marked = &quot;variable-3&quot;; return cont();}
  }
  function vardef() {
    return pass(pattern, maybetype, maybeAssign, vardefCont);
  }
  function pattern(type, value) {
    if (type == &quot;variable&quot;) { register(value); return cont(); }
    if (type == &quot;[&quot;) return contCommasep(pattern, &quot;]&quot;);
    if (type == &quot;{&quot;) return contCommasep(proppattern, &quot;}&quot;);
  }
  function proppattern(type, value) {
    if (type == &quot;variable&quot; &amp;&amp; !cx.stream.match(/^\s*:/, false)) {
      register(value);
      return cont(maybeAssign);
    }
    if (type == &quot;variable&quot;) cx.marked = &quot;property&quot;;
    return cont(expect(&quot;:&quot;), pattern, maybeAssign);
  }
  function maybeAssign(_type, value) {
    if (value == &quot;=&quot;) return cont(expressionNoComma);
  }
  function vardefCont(type) {
    if (type == &quot;,&quot;) return cont(vardef);
  }
  function maybeelse(type, value) {
    if (type == &quot;keyword b&quot; &amp;&amp; value == &quot;else&quot;) return cont(pushlex(&quot;form&quot;, &quot;else&quot;), statement, poplex);
  }
  function forspec(type) {
    if (type == &quot;(&quot;) return cont(pushlex(&quot;)&quot;), forspec1, expect(&quot;)&quot;), poplex);
  }
  function forspec1(type) {
    if (type == &quot;var&quot;) return cont(vardef, expect(&quot;;&quot;), forspec2);
    if (type == &quot;;&quot;) return cont(forspec2);
    if (type == &quot;variable&quot;) return cont(formaybeinof);
    return pass(expression, expect(&quot;;&quot;), forspec2);
  }
  function formaybeinof(_type, value) {
    if (value == &quot;in&quot; || value == &quot;of&quot;) { cx.marked = &quot;keyword&quot;; return cont(expression); }
    return cont(maybeoperatorComma, forspec2);
  }
  function forspec2(type, value) {
    if (type == &quot;;&quot;) return cont(forspec3);
    if (value == &quot;in&quot; || value == &quot;of&quot;) { cx.marked = &quot;keyword&quot;; return cont(expression); }
    return pass(expression, expect(&quot;;&quot;), forspec3);
  }
  function forspec3(type) {
    if (type != &quot;)&quot;) cont(expression);
  }
  function functiondef(type, value) {
    if (value == &quot;*&quot;) {cx.marked = &quot;keyword&quot;; return cont(functiondef);}
    if (type == &quot;variable&quot;) {register(value); return cont(functiondef);}
    if (type == &quot;(&quot;) return cont(pushcontext, pushlex(&quot;)&quot;), commasep(funarg, &quot;)&quot;), poplex, statement, popcontext);
  }
  function funarg(type) {
    if (type == &quot;spread&quot;) return cont(funarg);
    return pass(pattern, maybetype);
  }
  function className(type, value) {
    if (type == &quot;variable&quot;) {register(value); return cont(classNameAfter);}
  }
  function classNameAfter(type, value) {
    if (value == &quot;extends&quot;) return cont(expression, classNameAfter);
    if (type == &quot;{&quot;) return cont(pushlex(&quot;}&quot;), classBody, poplex);
  }
  function classBody(type, value) {
    if (type == &quot;variable&quot; || cx.style == &quot;keyword&quot;) {
      cx.marked = &quot;property&quot;;
      if (value == &quot;get&quot; || value == &quot;set&quot;) return cont(classGetterSetter, functiondef, classBody);
      return cont(functiondef, classBody);
    }
    if (value == &quot;*&quot;) {
      cx.marked = &quot;keyword&quot;;
      return cont(classBody);
    }
    if (type == &quot;;&quot;) return cont(classBody);
    if (type == &quot;}&quot;) return cont();
  }
  function classGetterSetter(type) {
    if (type != &quot;variable&quot;) return pass();
    cx.marked = &quot;property&quot;;
    return cont();
  }
  function afterModule(type, value) {
    if (type == &quot;string&quot;) return cont(statement);
    if (type == &quot;variable&quot;) { register(value); return cont(maybeFrom); }
  }
  function afterExport(_type, value) {
    if (value == &quot;*&quot;) { cx.marked = &quot;keyword&quot;; return cont(maybeFrom, expect(&quot;;&quot;)); }
    if (value == &quot;default&quot;) { cx.marked = &quot;keyword&quot;; return cont(expression, expect(&quot;;&quot;)); }
    return pass(statement);
  }
  function afterImport(type) {
    if (type == &quot;string&quot;) return cont();
    return pass(importSpec, maybeFrom);
  }
  function importSpec(type, value) {
    if (type == &quot;{&quot;) return contCommasep(importSpec, &quot;}&quot;);
    if (type == &quot;variable&quot;) register(value);
    return cont();
  }
  function maybeFrom(_type, value) {
    if (value == &quot;from&quot;) { cx.marked = &quot;keyword&quot;; return cont(expression); }
  }
  function arrayLiteral(type) {
    if (type == &quot;]&quot;) return cont();
    return pass(expressionNoComma, maybeArrayComprehension);
  }
  function maybeArrayComprehension(type) {
    if (type == &quot;for&quot;) return pass(comprehension, expect(&quot;]&quot;));
    if (type == &quot;,&quot;) return cont(commasep(maybeexpressionNoComma, &quot;]&quot;));
    return pass(commasep(expressionNoComma, &quot;]&quot;));
  }
  function comprehension(type) {
    if (type == &quot;for&quot;) return cont(forspec, comprehension);
    if (type == &quot;if&quot;) return cont(expression, comprehension);
  }

  // Interface

  return {
    startState: function(basecolumn) {
      var state = {
        tokenize: tokenBase,
        lastType: &quot;sof&quot;,
        cc: [],
        lexical: new JSLexical((basecolumn || 0) - indentUnit, 0, &quot;block&quot;, false),
        localVars: parserConfig.localVars,
        context: parserConfig.localVars &amp;&amp; {vars: parserConfig.localVars},
        indented: 0
      };
      if (parserConfig.globalVars &amp;&amp; typeof parserConfig.globalVars == &quot;object&quot;)
        state.globalVars = parserConfig.globalVars;
      return state;
    },

    token: function(stream, state) {
      if (stream.sol()) {
        if (!state.lexical.hasOwnProperty(&quot;align&quot;))
          state.lexical.align = false;
        state.indented = stream.indentation();
        findFatArrow(stream, state);
      }
      if (state.tokenize != tokenComment &amp;&amp; stream.eatSpace()) return null;
      var style = state.tokenize(stream, state);
      if (type == &quot;comment&quot;) return style;
      state.lastType = type == &quot;operator&quot; &amp;&amp; (content == &quot;++&quot; || content == &quot;--&quot;) ? &quot;incdec&quot; : type;
      return parseJS(state, style, type, content, stream);
    },

    indent: function(state, textAfter) {
      if (state.tokenize == tokenComment) return CodeMirror.Pass;
      if (state.tokenize != tokenBase) return 0;
      var firstChar = textAfter &amp;&amp; textAfter.charAt(0), lexical = state.lexical;
      // Kludge to prevent &apos;maybelse&apos; from blocking lexical scope pops
      if (!/^\s*else\b/.test(textAfter)) for (var i = state.cc.length - 1; i &gt;= 0; --i) {
        var c = state.cc[i];
        if (c == poplex) lexical = lexical.prev;
        else if (c != maybeelse) break;
      }
      if (lexical.type == &quot;stat&quot; &amp;&amp; firstChar == &quot;}&quot;) lexical = lexical.prev;
      if (statementIndent &amp;&amp; lexical.type == &quot;)&quot; &amp;&amp; lexical.prev.type == &quot;stat&quot;)
        lexical = lexical.prev;
      var type = lexical.type, closing = firstChar == type;

      if (type == &quot;vardef&quot;) return lexical.indented + (state.lastType == &quot;operator&quot; || state.lastType == &quot;,&quot; ? lexical.info + 1 : 0);
      else if (type == &quot;form&quot; &amp;&amp; firstChar == &quot;{&quot;) return lexical.indented;
      else if (type == &quot;form&quot;) return lexical.indented + indentUnit;
      else if (type == &quot;stat&quot;)
        return lexical.indented + (state.lastType == &quot;operator&quot; || state.lastType == &quot;,&quot; ? statementIndent || indentUnit : 0);
      else if (lexical.info == &quot;switch&quot; &amp;&amp; !closing &amp;&amp; parserConfig.doubleIndentSwitch != false)
        return lexical.indented + (/^(?:case|default)\b/.test(textAfter) ? indentUnit : 2 * indentUnit);
      else if (lexical.align) return lexical.column + (closing ? 0 : 1);
      else return lexical.indented + (closing ? 0 : indentUnit);
    },

    electricInput: /^\s*(?:case .*?:|default:|\{|\})$/,
    blockCommentStart: jsonMode ? null : &quot;/*&quot;,
    blockCommentEnd: jsonMode ? null : &quot;*/&quot;,
    lineComment: jsonMode ? null : &quot;//&quot;,
    fold: &quot;brace&quot;,

    helperType: jsonMode ? &quot;json&quot; : &quot;javascript&quot;,
    jsonldMode: jsonldMode,
    jsonMode: jsonMode
  };
});

CodeMirror.registerHelper(&quot;wordChars&quot;, &quot;javascript&quot;, /[\w$]/);

CodeMirror.defineMIME(&quot;text/javascript&quot;, &quot;javascript&quot;);
CodeMirror.defineMIME(&quot;text/ecmascript&quot;, &quot;javascript&quot;);
CodeMirror.defineMIME(&quot;application/javascript&quot;, &quot;javascript&quot;);
CodeMirror.defineMIME(&quot;application/x-javascript&quot;, &quot;javascript&quot;);
CodeMirror.defineMIME(&quot;application/ecmascript&quot;, &quot;javascript&quot;);
CodeMirror.defineMIME(&quot;application/json&quot;, {name: &quot;javascript&quot;, json: true});
CodeMirror.defineMIME(&quot;application/x-json&quot;, {name: &quot;javascript&quot;, json: true});
CodeMirror.defineMIME(&quot;application/ld+json&quot;, {name: &quot;javascript&quot;, jsonld: true});
CodeMirror.defineMIME(&quot;text/typescript&quot;, { name: &quot;javascript&quot;, typescript: true });
CodeMirror.defineMIME(&quot;application/typescript&quot;, { name: &quot;javascript&quot;, typescript: true });

});
</code></pre>

</div>

<footer class="footer">
  Generated by <a href="https://esdoc.org">ESDoc<span data-ice="esdocVersion">(1.1.0)</span><img src="./image/esdoc-logo-mini-black.png"></a>
</footer>

<script src="script/search_index.js"></script>
<script src="script/search.js"></script>
<script src="script/pretty-print.js"></script>
<script src="script/inherited-summary.js"></script>
<script src="script/test-summary.js"></script>
<script src="script/inner-link.js"></script>
<script src="script/patch-for-local.js"></script>
</body>
</html>
