<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <base data-ice="baseUrl" href="../../../../../">
  <title data-ice="title">src/codemirror/mode/livescript/livescript.js | webrtcdevelopment</title>
  <link type="text/css" rel="stylesheet" href="css/style.css">
  <link type="text/css" rel="stylesheet" href="css/prettify-tomorrow.css">
  <script src="script/prettify/prettify.js"></script>
  <script src="script/manual.js"></script>
<meta name="description" content="webrtc based communication and collaboration client. Contains lot of experiments modules "><meta property="twitter:card" content="summary"><meta property="twitter:title" content="webrtcdevelopment"><meta property="twitter:description" content="webrtc based communication and collaboration client. Contains lot of experiments modules "></head>
<body class="layout-container" data-ice="rootContainer">

<header>
  <a href="./">Home</a>
  
  <a href="identifiers.html">Reference</a>
  <a href="source.html">Source</a>
  
  <div class="search-box">
  <span>
    <img src="./image/search.png">
    <span class="search-input-edge"></span><input class="search-input"><span class="search-input-edge"></span>
  </span>
    <ul class="search-result"></ul>
  </div>
<a style="position:relative; top:3px;" href="https://github.com/altanai/webrtc"><img width="20px" src="./image/github.png"></a></header>

<nav class="navigation" data-ice="nav"><div>
  <ul>
    
  <li data-ice="doc"><a data-ice="dirPath" class="nav-dir-path" href="identifiers.html#scripts">scripts</a><span data-ice="kind" class="kind-typedef">T</span><span data-ice="name"><span><a href="typedef/index.html#static-typedef-CanvasRecorder">CanvasRecorder</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-typedef">T</span><span data-ice="name"><span><a href="typedef/index.html#static-typedef-GetRecorderType">GetRecorderType</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-typedef">T</span><span data-ice="name"><span><a href="typedef/index.html#static-typedef-GifRecorder">GifRecorder</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-typedef">T</span><span data-ice="name"><span><a href="typedef/index.html#static-typedef-MRecordRTC">MRecordRTC</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-typedef">T</span><span data-ice="name"><span><a href="typedef/index.html#static-typedef-MediaStreamRecorder">MediaStreamRecorder</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-typedef">T</span><span data-ice="name"><span><a href="typedef/index.html#static-typedef-RecordRTC">RecordRTC</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-typedef">T</span><span data-ice="name"><span><a href="typedef/index.html#static-typedef-RecordRTCConfiguration">RecordRTCConfiguration</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-typedef">T</span><span data-ice="name"><span><a href="typedef/index.html#static-typedef-StereoAudioRecorder">StereoAudioRecorder</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-typedef">T</span><span data-ice="name"><span><a href="typedef/index.html#static-typedef-Whammy">Whammy</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-typedef">T</span><span data-ice="name"><span><a href="typedef/index.html#static-typedef-WhammyRecorder">WhammyRecorder</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-typedef">T</span><span data-ice="name"><span><a href="typedef/index.html#static-typedef-createFileSharingDiv">createFileSharingDiv</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-typedef">T</span><span data-ice="name"><span><a href="typedef/index.html#static-typedef-_turn.js">_turn.js</a></span></span></li>
<li data-ice="doc"><a data-ice="dirPath" class="nav-dir-path" href="identifiers.html#scripts-rtcconn">scripts/rtcconn</a><span data-ice="kind" class="kind-typedef">T</span><span data-ice="name"><span><a href="typedef/index.html#static-typedef-Whammy">Whammy</a></span></span></li>
</ul>
</div>
</nav>

<div class="content" data-ice="content"><h1 data-ice="title">src/codemirror/mode/livescript/livescript.js</h1>
<pre class="source-code line-number raw-source-code"><code class="prettyprint linenums" data-ice="content">// CodeMirror, copyright (c) by Marijn Haverbeke and others
// Distributed under an MIT license: http://codemirror.net/LICENSE

/**
 * Link to the project&apos;s GitHub page:
 * https://github.com/duralog/CodeMirror
 */

(function(mod) {
  if (typeof exports == &quot;object&quot; &amp;&amp; typeof module == &quot;object&quot;) // CommonJS
    mod(require(&quot;../../lib/codemirror&quot;));
  else if (typeof define == &quot;function&quot; &amp;&amp; define.amd) // AMD
    define([&quot;../../lib/codemirror&quot;], mod);
  else // Plain browser env
    mod(CodeMirror);
})(function(CodeMirror) {
  &quot;use strict&quot;;

  CodeMirror.defineMode(&apos;livescript&apos;, function(){
    var tokenBase = function(stream, state) {
      var next_rule = state.next || &quot;start&quot;;
      if (next_rule) {
        state.next = state.next;
        var nr = Rules[next_rule];
        if (nr.splice) {
          for (var i$ = 0; i$ &lt; nr.length; ++i$) {
            var r = nr[i$], m;
            if (r.regex &amp;&amp; (m = stream.match(r.regex))) {
              state.next = r.next || state.next;
              return r.token;
            }
          }
          stream.next();
          return &apos;error&apos;;
        }
        if (stream.match(r = Rules[next_rule])) {
          if (r.regex &amp;&amp; stream.match(r.regex)) {
            state.next = r.next;
            return r.token;
          } else {
            stream.next();
            return &apos;error&apos;;
          }
        }
      }
      stream.next();
      return &apos;error&apos;;
    };
    var external = {
      startState: function(){
        return {
          next: &apos;start&apos;,
          lastToken: null
        };
      },
      token: function(stream, state){
        while (stream.pos == stream.start)
          var style = tokenBase(stream, state);
        state.lastToken = {
          style: style,
          indent: stream.indentation(),
          content: stream.current()
        };
        return style.replace(/\./g, &apos; &apos;);
      },
      indent: function(state){
        var indentation = state.lastToken.indent;
        if (state.lastToken.content.match(indenter)) {
          indentation += 2;
        }
        return indentation;
      }
    };
    return external;
  });

  var identifier = &apos;(?![\\d\\s])[$\\w\\xAA-\\uFFDC](?:(?!\\s)[$\\w\\xAA-\\uFFDC]|-[A-Za-z])*&apos;;
  var indenter = RegExp(&apos;(?:[({[=:]|[-~]&gt;|\\b(?:e(?:lse|xport)|d(?:o|efault)|t(?:ry|hen)|finally|import(?:\\s*all)?|const|var|let|new|catch(?:\\s*&apos; + identifier + &apos;)?))\\s*$&apos;);
  var keywordend = &apos;(?![$\\w]|-[A-Za-z]|\\s*:(?![:=]))&apos;;
  var stringfill = {
    token: &apos;string&apos;,
    regex: &apos;.+&apos;
  };
  var Rules = {
    start: [
      {
        token: &apos;comment.doc&apos;,
        regex: &apos;/\\*&apos;,
        next: &apos;comment&apos;
      }, {
        token: &apos;comment&apos;,
        regex: &apos;#.*&apos;
      }, {
        token: &apos;keyword&apos;,
        regex: &apos;(?:t(?:h(?:is|row|en)|ry|ypeof!?)|c(?:on(?:tinue|st)|a(?:se|tch)|lass)|i(?:n(?:stanceof)?|mp(?:ort(?:\\s+all)?|lements)|[fs])|d(?:e(?:fault|lete|bugger)|o)|f(?:or(?:\\s+own)?|inally|unction)|s(?:uper|witch)|e(?:lse|x(?:tends|port)|val)|a(?:nd|rguments)|n(?:ew|ot)|un(?:less|til)|w(?:hile|ith)|o[fr]|return|break|let|var|loop)&apos; + keywordend
      }, {
        token: &apos;constant.language&apos;,
        regex: &apos;(?:true|false|yes|no|on|off|null|void|undefined)&apos; + keywordend
      }, {
        token: &apos;invalid.illegal&apos;,
        regex: &apos;(?:p(?:ackage|r(?:ivate|otected)|ublic)|i(?:mplements|nterface)|enum|static|yield)&apos; + keywordend
      }, {
        token: &apos;language.support.class&apos;,
        regex: &apos;(?:R(?:e(?:gExp|ferenceError)|angeError)|S(?:tring|yntaxError)|E(?:rror|valError)|Array|Boolean|Date|Function|Number|Object|TypeError|URIError)&apos; + keywordend
      }, {
        token: &apos;language.support.function&apos;,
        regex: &apos;(?:is(?:NaN|Finite)|parse(?:Int|Float)|Math|JSON|(?:en|de)codeURI(?:Component)?)&apos; + keywordend
      }, {
        token: &apos;variable.language&apos;,
        regex: &apos;(?:t(?:hat|il|o)|f(?:rom|allthrough)|it|by|e)&apos; + keywordend
      }, {
        token: &apos;identifier&apos;,
        regex: identifier + &apos;\\s*:(?![:=])&apos;
      }, {
        token: &apos;variable&apos;,
        regex: identifier
      }, {
        token: &apos;keyword.operator&apos;,
        regex: &apos;(?:\\.{3}|\\s+\\?)&apos;
      }, {
        token: &apos;keyword.variable&apos;,
        regex: &apos;(?:@+|::|\\.\\.)&apos;,
        next: &apos;key&apos;
      }, {
        token: &apos;keyword.operator&apos;,
        regex: &apos;\\.\\s*&apos;,
        next: &apos;key&apos;
      }, {
        token: &apos;string&apos;,
        regex: &apos;\\\\\\S[^\\s,;)}\\]]*&apos;
      }, {
        token: &apos;string.doc&apos;,
        regex: &apos;\&apos;\&apos;\&apos;&apos;,
        next: &apos;qdoc&apos;
      }, {
        token: &apos;string.doc&apos;,
        regex: &apos;&quot;&quot;&quot;&apos;,
        next: &apos;qqdoc&apos;
      }, {
        token: &apos;string&apos;,
        regex: &apos;\&apos;&apos;,
        next: &apos;qstring&apos;
      }, {
        token: &apos;string&apos;,
        regex: &apos;&quot;&apos;,
        next: &apos;qqstring&apos;
      }, {
        token: &apos;string&apos;,
        regex: &apos;`&apos;,
        next: &apos;js&apos;
      }, {
        token: &apos;string&apos;,
        regex: &apos;&lt;\\[&apos;,
        next: &apos;words&apos;
      }, {
        token: &apos;string.regex&apos;,
        regex: &apos;//&apos;,
        next: &apos;heregex&apos;
      }, {
        token: &apos;string.regex&apos;,
        regex: &apos;\\/(?:[^[\\/\\n\\\\]*(?:(?:\\\\.|\\[[^\\]\\n\\\\]*(?:\\\\.[^\\]\\n\\\\]*)*\\])[^[\\/\\n\\\\]*)*)\\/[gimy$]{0,4}&apos;,
        next: &apos;key&apos;
      }, {
        token: &apos;constant.numeric&apos;,
        regex: &apos;(?:0x[\\da-fA-F][\\da-fA-F_]*|(?:[2-9]|[12]\\d|3[0-6])r[\\da-zA-Z][\\da-zA-Z_]*|(?:\\d[\\d_]*(?:\\.\\d[\\d_]*)?|\\.\\d[\\d_]*)(?:e[+-]?\\d[\\d_]*)?[\\w$]*)&apos;
      }, {
        token: &apos;lparen&apos;,
        regex: &apos;[({[]&apos;
      }, {
        token: &apos;rparen&apos;,
        regex: &apos;[)}\\]]&apos;,
        next: &apos;key&apos;
      }, {
        token: &apos;keyword.operator&apos;,
        regex: &apos;\\S+&apos;
      }, {
        token: &apos;text&apos;,
        regex: &apos;\\s+&apos;
      }
    ],
    heregex: [
      {
        token: &apos;string.regex&apos;,
        regex: &apos;.*?//[gimy$?]{0,4}&apos;,
        next: &apos;start&apos;
      }, {
        token: &apos;string.regex&apos;,
        regex: &apos;\\s*#{&apos;
      }, {
        token: &apos;comment.regex&apos;,
        regex: &apos;\\s+(?:#.*)?&apos;
      }, {
        token: &apos;string.regex&apos;,
        regex: &apos;\\S+&apos;
      }
    ],
    key: [
      {
        token: &apos;keyword.operator&apos;,
        regex: &apos;[.?@!]+&apos;
      }, {
        token: &apos;identifier&apos;,
        regex: identifier,
        next: &apos;start&apos;
      }, {
        token: &apos;text&apos;,
        regex: &apos;&apos;,
        next: &apos;start&apos;
      }
    ],
    comment: [
      {
        token: &apos;comment.doc&apos;,
        regex: &apos;.*?\\*/&apos;,
        next: &apos;start&apos;
      }, {
        token: &apos;comment.doc&apos;,
        regex: &apos;.+&apos;
      }
    ],
    qdoc: [
      {
        token: &apos;string&apos;,
        regex: &quot;.*?&apos;&apos;&apos;&quot;,
        next: &apos;key&apos;
      }, stringfill
    ],
    qqdoc: [
      {
        token: &apos;string&apos;,
        regex: &apos;.*?&quot;&quot;&quot;&apos;,
        next: &apos;key&apos;
      }, stringfill
    ],
    qstring: [
      {
        token: &apos;string&apos;,
        regex: &apos;[^\\\\\&apos;]*(?:\\\\.[^\\\\\&apos;]*)*\&apos;&apos;,
        next: &apos;key&apos;
      }, stringfill
    ],
    qqstring: [
      {
        token: &apos;string&apos;,
        regex: &apos;[^\\\\&quot;]*(?:\\\\.[^\\\\&quot;]*)*&quot;&apos;,
        next: &apos;key&apos;
      }, stringfill
    ],
    js: [
      {
        token: &apos;string&apos;,
        regex: &apos;[^\\\\`]*(?:\\\\.[^\\\\`]*)*`&apos;,
        next: &apos;key&apos;
      }, stringfill
    ],
    words: [
      {
        token: &apos;string&apos;,
        regex: &apos;.*?\\]&gt;&apos;,
        next: &apos;key&apos;
      }, stringfill
    ]
  };
  for (var idx in Rules) {
    var r = Rules[idx];
    if (r.splice) {
      for (var i = 0, len = r.length; i &lt; len; ++i) {
        var rr = r[i];
        if (typeof rr.regex === &apos;string&apos;) {
          Rules[idx][i].regex = new RegExp(&apos;^&apos; + rr.regex);
        }
      }
    } else if (typeof rr.regex === &apos;string&apos;) {
      Rules[idx].regex = new RegExp(&apos;^&apos; + r.regex);
    }
  }

  CodeMirror.defineMIME(&apos;text/x-livescript&apos;, &apos;livescript&apos;);

});
</code></pre>

</div>

<footer class="footer">
  Generated by <a href="https://esdoc.org">ESDoc<span data-ice="esdocVersion">(1.1.0)</span><img src="./image/esdoc-logo-mini-black.png"></a>
</footer>

<script src="script/search_index.js"></script>
<script src="script/search.js"></script>
<script src="script/pretty-print.js"></script>
<script src="script/inherited-summary.js"></script>
<script src="script/test-summary.js"></script>
<script src="script/inner-link.js"></script>
<script src="script/patch-for-local.js"></script>
</body>
</html>
