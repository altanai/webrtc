<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <base data-ice="baseUrl" href="../../../../../">
  <title data-ice="title">src/codemirror/mode/haxe/haxe.js | webrtcdevelopment</title>
  <link type="text/css" rel="stylesheet" href="css/style.css">
  <link type="text/css" rel="stylesheet" href="css/prettify-tomorrow.css">
  <script src="script/prettify/prettify.js"></script>
  <script src="script/manual.js"></script>
<meta name="description" content="webrtc based communication and collaboration client. Contains lot of experiments modules "><meta property="twitter:card" content="summary"><meta property="twitter:title" content="webrtcdevelopment"><meta property="twitter:description" content="webrtc based communication and collaboration client. Contains lot of experiments modules "></head>
<body class="layout-container" data-ice="rootContainer">

<header>
  <a href="./">Home</a>
  
  <a href="identifiers.html">Reference</a>
  <a href="source.html">Source</a>
  
  <div class="search-box">
  <span>
    <img src="./image/search.png">
    <span class="search-input-edge"></span><input class="search-input"><span class="search-input-edge"></span>
  </span>
    <ul class="search-result"></ul>
  </div>
<a style="position:relative; top:3px;" href="https://github.com/altanai/webrtc"><img width="20px" src="./image/github.png"></a></header>

<nav class="navigation" data-ice="nav"><div>
  <ul>
    
  <li data-ice="doc"><a data-ice="dirPath" class="nav-dir-path" href="identifiers.html#scripts">scripts</a><span data-ice="kind" class="kind-typedef">T</span><span data-ice="name"><span><a href="typedef/index.html#static-typedef-CanvasRecorder">CanvasRecorder</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-typedef">T</span><span data-ice="name"><span><a href="typedef/index.html#static-typedef-GetRecorderType">GetRecorderType</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-typedef">T</span><span data-ice="name"><span><a href="typedef/index.html#static-typedef-GifRecorder">GifRecorder</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-typedef">T</span><span data-ice="name"><span><a href="typedef/index.html#static-typedef-MRecordRTC">MRecordRTC</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-typedef">T</span><span data-ice="name"><span><a href="typedef/index.html#static-typedef-MediaStreamRecorder">MediaStreamRecorder</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-typedef">T</span><span data-ice="name"><span><a href="typedef/index.html#static-typedef-RecordRTC">RecordRTC</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-typedef">T</span><span data-ice="name"><span><a href="typedef/index.html#static-typedef-RecordRTCConfiguration">RecordRTCConfiguration</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-typedef">T</span><span data-ice="name"><span><a href="typedef/index.html#static-typedef-StereoAudioRecorder">StereoAudioRecorder</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-typedef">T</span><span data-ice="name"><span><a href="typedef/index.html#static-typedef-Whammy">Whammy</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-typedef">T</span><span data-ice="name"><span><a href="typedef/index.html#static-typedef-WhammyRecorder">WhammyRecorder</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-typedef">T</span><span data-ice="name"><span><a href="typedef/index.html#static-typedef-createFileSharingDiv">createFileSharingDiv</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-typedef">T</span><span data-ice="name"><span><a href="typedef/index.html#static-typedef-_turn.js">_turn.js</a></span></span></li>
<li data-ice="doc"><a data-ice="dirPath" class="nav-dir-path" href="identifiers.html#scripts-rtcconn">scripts/rtcconn</a><span data-ice="kind" class="kind-typedef">T</span><span data-ice="name"><span><a href="typedef/index.html#static-typedef-Whammy">Whammy</a></span></span></li>
</ul>
</div>
</nav>

<div class="content" data-ice="content"><h1 data-ice="title">src/codemirror/mode/haxe/haxe.js</h1>
<pre class="source-code line-number raw-source-code"><code class="prettyprint linenums" data-ice="content">// CodeMirror, copyright (c) by Marijn Haverbeke and others
// Distributed under an MIT license: http://codemirror.net/LICENSE

(function(mod) {
  if (typeof exports == &quot;object&quot; &amp;&amp; typeof module == &quot;object&quot;) // CommonJS
    mod(require(&quot;../../lib/codemirror&quot;));
  else if (typeof define == &quot;function&quot; &amp;&amp; define.amd) // AMD
    define([&quot;../../lib/codemirror&quot;], mod);
  else // Plain browser env
    mod(CodeMirror);
})(function(CodeMirror) {
&quot;use strict&quot;;

CodeMirror.defineMode(&quot;haxe&quot;, function(config, parserConfig) {
  var indentUnit = config.indentUnit;

  // Tokenizer

  var keywords = function(){
    function kw(type) {return {type: type, style: &quot;keyword&quot;};}
    var A = kw(&quot;keyword a&quot;), B = kw(&quot;keyword b&quot;), C = kw(&quot;keyword c&quot;);
    var operator = kw(&quot;operator&quot;), atom = {type: &quot;atom&quot;, style: &quot;atom&quot;}, attribute = {type:&quot;attribute&quot;, style: &quot;attribute&quot;};
  var type = kw(&quot;typedef&quot;);
    return {
      &quot;if&quot;: A, &quot;while&quot;: A, &quot;else&quot;: B, &quot;do&quot;: B, &quot;try&quot;: B,
      &quot;return&quot;: C, &quot;break&quot;: C, &quot;continue&quot;: C, &quot;new&quot;: C, &quot;throw&quot;: C,
      &quot;var&quot;: kw(&quot;var&quot;), &quot;inline&quot;:attribute, &quot;static&quot;: attribute, &quot;using&quot;:kw(&quot;import&quot;),
    &quot;public&quot;: attribute, &quot;private&quot;: attribute, &quot;cast&quot;: kw(&quot;cast&quot;), &quot;import&quot;: kw(&quot;import&quot;), &quot;macro&quot;: kw(&quot;macro&quot;),
      &quot;function&quot;: kw(&quot;function&quot;), &quot;catch&quot;: kw(&quot;catch&quot;), &quot;untyped&quot;: kw(&quot;untyped&quot;), &quot;callback&quot;: kw(&quot;cb&quot;),
      &quot;for&quot;: kw(&quot;for&quot;), &quot;switch&quot;: kw(&quot;switch&quot;), &quot;case&quot;: kw(&quot;case&quot;), &quot;default&quot;: kw(&quot;default&quot;),
      &quot;in&quot;: operator, &quot;never&quot;: kw(&quot;property_access&quot;), &quot;trace&quot;:kw(&quot;trace&quot;),
    &quot;class&quot;: type, &quot;abstract&quot;:type, &quot;enum&quot;:type, &quot;interface&quot;:type, &quot;typedef&quot;:type, &quot;extends&quot;:type, &quot;implements&quot;:type, &quot;dynamic&quot;:type,
      &quot;true&quot;: atom, &quot;false&quot;: atom, &quot;null&quot;: atom
    };
  }();

  var isOperatorChar = /[+\-*&amp;%=&lt;&gt;!?|]/;

  function chain(stream, state, f) {
    state.tokenize = f;
    return f(stream, state);
  }

  function nextUntilUnescaped(stream, end) {
    var escaped = false, next;
    while ((next = stream.next()) != null) {
      if (next == end &amp;&amp; !escaped)
        return false;
      escaped = !escaped &amp;&amp; next == &quot;\\&quot;;
    }
    return escaped;
  }

  // Used as scratch variables to communicate multiple values without
  // consing up tons of objects.
  var type, content;
  function ret(tp, style, cont) {
    type = tp; content = cont;
    return style;
  }

  function haxeTokenBase(stream, state) {
    var ch = stream.next();
    if (ch == &apos;&quot;&apos; || ch == &quot;&apos;&quot;)
      return chain(stream, state, haxeTokenString(ch));
    else if (/[\[\]{}\(\),;\:\.]/.test(ch))
      return ret(ch);
    else if (ch == &quot;0&quot; &amp;&amp; stream.eat(/x/i)) {
      stream.eatWhile(/[\da-f]/i);
      return ret(&quot;number&quot;, &quot;number&quot;);
    }
    else if (/\d/.test(ch) || ch == &quot;-&quot; &amp;&amp; stream.eat(/\d/)) {
      stream.match(/^\d*(?:\.\d*)?(?:[eE][+\-]?\d+)?/);
      return ret(&quot;number&quot;, &quot;number&quot;);
    }
    else if (state.reAllowed &amp;&amp; (ch == &quot;~&quot; &amp;&amp; stream.eat(/\//))) {
      nextUntilUnescaped(stream, &quot;/&quot;);
      stream.eatWhile(/[gimsu]/);
      return ret(&quot;regexp&quot;, &quot;string-2&quot;);
    }
    else if (ch == &quot;/&quot;) {
      if (stream.eat(&quot;*&quot;)) {
        return chain(stream, state, haxeTokenComment);
      }
      else if (stream.eat(&quot;/&quot;)) {
        stream.skipToEnd();
        return ret(&quot;comment&quot;, &quot;comment&quot;);
      }
      else {
        stream.eatWhile(isOperatorChar);
        return ret(&quot;operator&quot;, null, stream.current());
      }
    }
    else if (ch == &quot;#&quot;) {
        stream.skipToEnd();
        return ret(&quot;conditional&quot;, &quot;meta&quot;);
    }
    else if (ch == &quot;@&quot;) {
      stream.eat(/:/);
      stream.eatWhile(/[\w_]/);
      return ret (&quot;metadata&quot;, &quot;meta&quot;);
    }
    else if (isOperatorChar.test(ch)) {
      stream.eatWhile(isOperatorChar);
      return ret(&quot;operator&quot;, null, stream.current());
    }
    else {
    var word;
    if(/[A-Z]/.test(ch))
    {
      stream.eatWhile(/[\w_&lt;&gt;]/);
      word = stream.current();
      return ret(&quot;type&quot;, &quot;variable-3&quot;, word);
    }
    else
    {
        stream.eatWhile(/[\w_]/);
        var word = stream.current(), known = keywords.propertyIsEnumerable(word) &amp;&amp; keywords[word];
        return (known &amp;&amp; state.kwAllowed) ? ret(known.type, known.style, word) :
                       ret(&quot;variable&quot;, &quot;variable&quot;, word);
    }
    }
  }

  function haxeTokenString(quote) {
    return function(stream, state) {
      if (!nextUntilUnescaped(stream, quote))
        state.tokenize = haxeTokenBase;
      return ret(&quot;string&quot;, &quot;string&quot;);
    };
  }

  function haxeTokenComment(stream, state) {
    var maybeEnd = false, ch;
    while (ch = stream.next()) {
      if (ch == &quot;/&quot; &amp;&amp; maybeEnd) {
        state.tokenize = haxeTokenBase;
        break;
      }
      maybeEnd = (ch == &quot;*&quot;);
    }
    return ret(&quot;comment&quot;, &quot;comment&quot;);
  }

  // Parser

  var atomicTypes = {&quot;atom&quot;: true, &quot;number&quot;: true, &quot;variable&quot;: true, &quot;string&quot;: true, &quot;regexp&quot;: true};

  function HaxeLexical(indented, column, type, align, prev, info) {
    this.indented = indented;
    this.column = column;
    this.type = type;
    this.prev = prev;
    this.info = info;
    if (align != null) this.align = align;
  }

  function inScope(state, varname) {
    for (var v = state.localVars; v; v = v.next)
      if (v.name == varname) return true;
  }

  function parseHaxe(state, style, type, content, stream) {
    var cc = state.cc;
    // Communicate our context to the combinators.
    // (Less wasteful than consing up a hundred closures on every call.)
    cx.state = state; cx.stream = stream; cx.marked = null, cx.cc = cc;

    if (!state.lexical.hasOwnProperty(&quot;align&quot;))
      state.lexical.align = true;

    while(true) {
      var combinator = cc.length ? cc.pop() : statement;
      if (combinator(type, content)) {
        while(cc.length &amp;&amp; cc[cc.length - 1].lex)
          cc.pop()();
        if (cx.marked) return cx.marked;
        if (type == &quot;variable&quot; &amp;&amp; inScope(state, content)) return &quot;variable-2&quot;;
    if (type == &quot;variable&quot; &amp;&amp; imported(state, content)) return &quot;variable-3&quot;;
        return style;
      }
    }
  }

  function imported(state, typename)
  {
  if (/[a-z]/.test(typename.charAt(0)))
    return false;
  var len = state.importedtypes.length;
  for (var i = 0; i&lt;len; i++)
    if(state.importedtypes[i]==typename) return true;
  }


  function registerimport(importname) {
  var state = cx.state;
  for (var t = state.importedtypes; t; t = t.next)
    if(t.name == importname) return;
  state.importedtypes = { name: importname, next: state.importedtypes };
  }
  // Combinator utils

  var cx = {state: null, column: null, marked: null, cc: null};
  function pass() {
    for (var i = arguments.length - 1; i &gt;= 0; i--) cx.cc.push(arguments[i]);
  }
  function cont() {
    pass.apply(null, arguments);
    return true;
  }
  function register(varname) {
    var state = cx.state;
    if (state.context) {
      cx.marked = &quot;def&quot;;
      for (var v = state.localVars; v; v = v.next)
        if (v.name == varname) return;
      state.localVars = {name: varname, next: state.localVars};
    }
  }

  // Combinators

  var defaultVars = {name: &quot;this&quot;, next: null};
  function pushcontext() {
    if (!cx.state.context) cx.state.localVars = defaultVars;
    cx.state.context = {prev: cx.state.context, vars: cx.state.localVars};
  }
  function popcontext() {
    cx.state.localVars = cx.state.context.vars;
    cx.state.context = cx.state.context.prev;
  }
  function pushlex(type, info) {
    var result = function() {
      var state = cx.state;
      state.lexical = new HaxeLexical(state.indented, cx.stream.column(), type, null, state.lexical, info);
    };
    result.lex = true;
    return result;
  }
  function poplex() {
    var state = cx.state;
    if (state.lexical.prev) {
      if (state.lexical.type == &quot;)&quot;)
        state.indented = state.lexical.indented;
      state.lexical = state.lexical.prev;
    }
  }
  poplex.lex = true;

  function expect(wanted) {
    function f(type) {
      if (type == wanted) return cont();
      else if (wanted == &quot;;&quot;) return pass();
      else return cont(f);
    };
    return f;
  }

  function statement(type) {
    if (type == &quot;@&quot;) return cont(metadef);
    if (type == &quot;var&quot;) return cont(pushlex(&quot;vardef&quot;), vardef1, expect(&quot;;&quot;), poplex);
    if (type == &quot;keyword a&quot;) return cont(pushlex(&quot;form&quot;), expression, statement, poplex);
    if (type == &quot;keyword b&quot;) return cont(pushlex(&quot;form&quot;), statement, poplex);
    if (type == &quot;{&quot;) return cont(pushlex(&quot;}&quot;), pushcontext, block, poplex, popcontext);
    if (type == &quot;;&quot;) return cont();
    if (type == &quot;attribute&quot;) return cont(maybeattribute);
    if (type == &quot;function&quot;) return cont(functiondef);
    if (type == &quot;for&quot;) return cont(pushlex(&quot;form&quot;), expect(&quot;(&quot;), pushlex(&quot;)&quot;), forspec1, expect(&quot;)&quot;),
                                      poplex, statement, poplex);
    if (type == &quot;variable&quot;) return cont(pushlex(&quot;stat&quot;), maybelabel);
    if (type == &quot;switch&quot;) return cont(pushlex(&quot;form&quot;), expression, pushlex(&quot;}&quot;, &quot;switch&quot;), expect(&quot;{&quot;),
                                         block, poplex, poplex);
    if (type == &quot;case&quot;) return cont(expression, expect(&quot;:&quot;));
    if (type == &quot;default&quot;) return cont(expect(&quot;:&quot;));
    if (type == &quot;catch&quot;) return cont(pushlex(&quot;form&quot;), pushcontext, expect(&quot;(&quot;), funarg, expect(&quot;)&quot;),
                                        statement, poplex, popcontext);
    if (type == &quot;import&quot;) return cont(importdef, expect(&quot;;&quot;));
    if (type == &quot;typedef&quot;) return cont(typedef);
    return pass(pushlex(&quot;stat&quot;), expression, expect(&quot;;&quot;), poplex);
  }
  function expression(type) {
    if (atomicTypes.hasOwnProperty(type)) return cont(maybeoperator);
    if (type == &quot;function&quot;) return cont(functiondef);
    if (type == &quot;keyword c&quot;) return cont(maybeexpression);
    if (type == &quot;(&quot;) return cont(pushlex(&quot;)&quot;), maybeexpression, expect(&quot;)&quot;), poplex, maybeoperator);
    if (type == &quot;operator&quot;) return cont(expression);
    if (type == &quot;[&quot;) return cont(pushlex(&quot;]&quot;), commasep(expression, &quot;]&quot;), poplex, maybeoperator);
    if (type == &quot;{&quot;) return cont(pushlex(&quot;}&quot;), commasep(objprop, &quot;}&quot;), poplex, maybeoperator);
    return cont();
  }
  function maybeexpression(type) {
    if (type.match(/[;\}\)\],]/)) return pass();
    return pass(expression);
  }

  function maybeoperator(type, value) {
    if (type == &quot;operator&quot; &amp;&amp; /\+\+|--/.test(value)) return cont(maybeoperator);
    if (type == &quot;operator&quot; || type == &quot;:&quot;) return cont(expression);
    if (type == &quot;;&quot;) return;
    if (type == &quot;(&quot;) return cont(pushlex(&quot;)&quot;), commasep(expression, &quot;)&quot;), poplex, maybeoperator);
    if (type == &quot;.&quot;) return cont(property, maybeoperator);
    if (type == &quot;[&quot;) return cont(pushlex(&quot;]&quot;), expression, expect(&quot;]&quot;), poplex, maybeoperator);
  }

  function maybeattribute(type) {
    if (type == &quot;attribute&quot;) return cont(maybeattribute);
    if (type == &quot;function&quot;) return cont(functiondef);
    if (type == &quot;var&quot;) return cont(vardef1);
  }

  function metadef(type) {
    if(type == &quot;:&quot;) return cont(metadef);
    if(type == &quot;variable&quot;) return cont(metadef);
    if(type == &quot;(&quot;) return cont(pushlex(&quot;)&quot;), commasep(metaargs, &quot;)&quot;), poplex, statement);
  }
  function metaargs(type) {
    if(type == &quot;variable&quot;) return cont();
  }

  function importdef (type, value) {
  if(type == &quot;variable&quot; &amp;&amp; /[A-Z]/.test(value.charAt(0))) { registerimport(value); return cont(); }
  else if(type == &quot;variable&quot; || type == &quot;property&quot; || type == &quot;.&quot; || value == &quot;*&quot;) return cont(importdef);
  }

  function typedef (type, value)
  {
  if(type == &quot;variable&quot; &amp;&amp; /[A-Z]/.test(value.charAt(0))) { registerimport(value); return cont(); }
  else if (type == &quot;type&quot; &amp;&amp; /[A-Z]/.test(value.charAt(0))) { return cont(); }
  }

  function maybelabel(type) {
    if (type == &quot;:&quot;) return cont(poplex, statement);
    return pass(maybeoperator, expect(&quot;;&quot;), poplex);
  }
  function property(type) {
    if (type == &quot;variable&quot;) {cx.marked = &quot;property&quot;; return cont();}
  }
  function objprop(type) {
    if (type == &quot;variable&quot;) cx.marked = &quot;property&quot;;
    if (atomicTypes.hasOwnProperty(type)) return cont(expect(&quot;:&quot;), expression);
  }
  function commasep(what, end) {
    function proceed(type) {
      if (type == &quot;,&quot;) return cont(what, proceed);
      if (type == end) return cont();
      return cont(expect(end));
    }
    return function(type) {
      if (type == end) return cont();
      else return pass(what, proceed);
    };
  }
  function block(type) {
    if (type == &quot;}&quot;) return cont();
    return pass(statement, block);
  }
  function vardef1(type, value) {
    if (type == &quot;variable&quot;){register(value); return cont(typeuse, vardef2);}
    return cont();
  }
  function vardef2(type, value) {
    if (value == &quot;=&quot;) return cont(expression, vardef2);
    if (type == &quot;,&quot;) return cont(vardef1);
  }
  function forspec1(type, value) {
  if (type == &quot;variable&quot;) {
    register(value);
  }
  return cont(pushlex(&quot;)&quot;), pushcontext, forin, expression, poplex, statement, popcontext);
  }
  function forin(_type, value) {
    if (value == &quot;in&quot;) return cont();
  }
  function functiondef(type, value) {
    if (type == &quot;variable&quot;) {register(value); return cont(functiondef);}
    if (value == &quot;new&quot;) return cont(functiondef);
    if (type == &quot;(&quot;) return cont(pushlex(&quot;)&quot;), pushcontext, commasep(funarg, &quot;)&quot;), poplex, typeuse, statement, popcontext);
  }
  function typeuse(type) {
    if(type == &quot;:&quot;) return cont(typestring);
  }
  function typestring(type) {
    if(type == &quot;type&quot;) return cont();
    if(type == &quot;variable&quot;) return cont();
    if(type == &quot;{&quot;) return cont(pushlex(&quot;}&quot;), commasep(typeprop, &quot;}&quot;), poplex);
  }
  function typeprop(type) {
    if(type == &quot;variable&quot;) return cont(typeuse);
  }
  function funarg(type, value) {
    if (type == &quot;variable&quot;) {register(value); return cont(typeuse);}
  }

  // Interface

  return {
    startState: function(basecolumn) {
    var defaulttypes = [&quot;Int&quot;, &quot;Float&quot;, &quot;String&quot;, &quot;Void&quot;, &quot;Std&quot;, &quot;Bool&quot;, &quot;Dynamic&quot;, &quot;Array&quot;];
      return {
        tokenize: haxeTokenBase,
        reAllowed: true,
        kwAllowed: true,
        cc: [],
        lexical: new HaxeLexical((basecolumn || 0) - indentUnit, 0, &quot;block&quot;, false),
        localVars: parserConfig.localVars,
    importedtypes: defaulttypes,
        context: parserConfig.localVars &amp;&amp; {vars: parserConfig.localVars},
        indented: 0
      };
    },

    token: function(stream, state) {
      if (stream.sol()) {
        if (!state.lexical.hasOwnProperty(&quot;align&quot;))
          state.lexical.align = false;
        state.indented = stream.indentation();
      }
      if (stream.eatSpace()) return null;
      var style = state.tokenize(stream, state);
      if (type == &quot;comment&quot;) return style;
      state.reAllowed = !!(type == &quot;operator&quot; || type == &quot;keyword c&quot; || type.match(/^[\[{}\(,;:]$/));
      state.kwAllowed = type != &apos;.&apos;;
      return parseHaxe(state, style, type, content, stream);
    },

    indent: function(state, textAfter) {
      if (state.tokenize != haxeTokenBase) return 0;
      var firstChar = textAfter &amp;&amp; textAfter.charAt(0), lexical = state.lexical;
      if (lexical.type == &quot;stat&quot; &amp;&amp; firstChar == &quot;}&quot;) lexical = lexical.prev;
      var type = lexical.type, closing = firstChar == type;
      if (type == &quot;vardef&quot;) return lexical.indented + 4;
      else if (type == &quot;form&quot; &amp;&amp; firstChar == &quot;{&quot;) return lexical.indented;
      else if (type == &quot;stat&quot; || type == &quot;form&quot;) return lexical.indented + indentUnit;
      else if (lexical.info == &quot;switch&quot; &amp;&amp; !closing)
        return lexical.indented + (/^(?:case|default)\b/.test(textAfter) ? indentUnit : 2 * indentUnit);
      else if (lexical.align) return lexical.column + (closing ? 0 : 1);
      else return lexical.indented + (closing ? 0 : indentUnit);
    },

    electricChars: &quot;{}&quot;,
    blockCommentStart: &quot;/*&quot;,
    blockCommentEnd: &quot;*/&quot;,
    lineComment: &quot;//&quot;
  };
});

CodeMirror.defineMIME(&quot;text/x-haxe&quot;, &quot;haxe&quot;);

CodeMirror.defineMode(&quot;hxml&quot;, function () {

  return {
    startState: function () {
      return {
        define: false,
        inString: false
      };
    },
    token: function (stream, state) {
      var ch = stream.peek();
      var sol = stream.sol();

      ///* comments */
      if (ch == &quot;#&quot;) {
        stream.skipToEnd();
        return &quot;comment&quot;;
      }
      if (sol &amp;&amp; ch == &quot;-&quot;) {
        var style = &quot;variable-2&quot;;

        stream.eat(/-/);

        if (stream.peek() == &quot;-&quot;) {
          stream.eat(/-/);
          style = &quot;keyword a&quot;;
        }

        if (stream.peek() == &quot;D&quot;) {
          stream.eat(/[D]/);
          style = &quot;keyword c&quot;;
          state.define = true;
        }

        stream.eatWhile(/[A-Z]/i);
        return style;
      }

      var ch = stream.peek();

      if (state.inString == false &amp;&amp; ch == &quot;&apos;&quot;) {
        state.inString = true;
        ch = stream.next();
      }

      if (state.inString == true) {
        if (stream.skipTo(&quot;&apos;&quot;)) {

        } else {
          stream.skipToEnd();
        }

        if (stream.peek() == &quot;&apos;&quot;) {
          stream.next();
          state.inString = false;
        }

        return &quot;string&quot;;
      }

      stream.next();
      return null;
    },
    lineComment: &quot;#&quot;
  };
});

CodeMirror.defineMIME(&quot;text/x-hxml&quot;, &quot;hxml&quot;);

});
</code></pre>

</div>

<footer class="footer">
  Generated by <a href="https://esdoc.org">ESDoc<span data-ice="esdocVersion">(1.1.0)</span><img src="./image/esdoc-logo-mini-black.png"></a>
</footer>

<script src="script/search_index.js"></script>
<script src="script/search.js"></script>
<script src="script/pretty-print.js"></script>
<script src="script/inherited-summary.js"></script>
<script src="script/test-summary.js"></script>
<script src="script/inner-link.js"></script>
<script src="script/patch-for-local.js"></script>
</body>
</html>
