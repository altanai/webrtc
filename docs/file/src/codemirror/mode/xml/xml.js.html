<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <base data-ice="baseUrl" href="../../../../../">
  <title data-ice="title">src/codemirror/mode/xml/xml.js | webrtcdevelopment</title>
  <link type="text/css" rel="stylesheet" href="css/style.css">
  <link type="text/css" rel="stylesheet" href="css/prettify-tomorrow.css">
  <script src="script/prettify/prettify.js"></script>
  <script src="script/manual.js"></script>
<meta name="description" content="webrtc based communication and collaboration client. Contains lot of experiments modules "><meta property="twitter:card" content="summary"><meta property="twitter:title" content="webrtcdevelopment"><meta property="twitter:description" content="webrtc based communication and collaboration client. Contains lot of experiments modules "></head>
<body class="layout-container" data-ice="rootContainer">

<header>
  <a href="./">Home</a>
  
  <a href="identifiers.html">Reference</a>
  <a href="source.html">Source</a>
  
  <div class="search-box">
  <span>
    <img src="./image/search.png">
    <span class="search-input-edge"></span><input class="search-input"><span class="search-input-edge"></span>
  </span>
    <ul class="search-result"></ul>
  </div>
<a style="position:relative; top:3px;" href="https://github.com/altanai/webrtc"><img width="20px" src="./image/github.png"></a></header>

<nav class="navigation" data-ice="nav"><div>
  <ul>
    
  <li data-ice="doc"><a data-ice="dirPath" class="nav-dir-path" href="identifiers.html#scripts">scripts</a><span data-ice="kind" class="kind-typedef">T</span><span data-ice="name"><span><a href="typedef/index.html#static-typedef-CanvasRecorder">CanvasRecorder</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-typedef">T</span><span data-ice="name"><span><a href="typedef/index.html#static-typedef-GetRecorderType">GetRecorderType</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-typedef">T</span><span data-ice="name"><span><a href="typedef/index.html#static-typedef-GifRecorder">GifRecorder</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-typedef">T</span><span data-ice="name"><span><a href="typedef/index.html#static-typedef-MRecordRTC">MRecordRTC</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-typedef">T</span><span data-ice="name"><span><a href="typedef/index.html#static-typedef-MediaStreamRecorder">MediaStreamRecorder</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-typedef">T</span><span data-ice="name"><span><a href="typedef/index.html#static-typedef-RecordRTC">RecordRTC</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-typedef">T</span><span data-ice="name"><span><a href="typedef/index.html#static-typedef-RecordRTCConfiguration">RecordRTCConfiguration</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-typedef">T</span><span data-ice="name"><span><a href="typedef/index.html#static-typedef-StereoAudioRecorder">StereoAudioRecorder</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-typedef">T</span><span data-ice="name"><span><a href="typedef/index.html#static-typedef-Whammy">Whammy</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-typedef">T</span><span data-ice="name"><span><a href="typedef/index.html#static-typedef-WhammyRecorder">WhammyRecorder</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-typedef">T</span><span data-ice="name"><span><a href="typedef/index.html#static-typedef-createFileSharingDiv">createFileSharingDiv</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-typedef">T</span><span data-ice="name"><span><a href="typedef/index.html#static-typedef-_turn.js">_turn.js</a></span></span></li>
<li data-ice="doc"><a data-ice="dirPath" class="nav-dir-path" href="identifiers.html#scripts-rtcconn">scripts/rtcconn</a><span data-ice="kind" class="kind-typedef">T</span><span data-ice="name"><span><a href="typedef/index.html#static-typedef-Whammy">Whammy</a></span></span></li>
</ul>
</div>
</nav>

<div class="content" data-ice="content"><h1 data-ice="title">src/codemirror/mode/xml/xml.js</h1>
<pre class="source-code line-number raw-source-code"><code class="prettyprint linenums" data-ice="content">// CodeMirror, copyright (c) by Marijn Haverbeke and others
// Distributed under an MIT license: http://codemirror.net/LICENSE

(function(mod) {
  if (typeof exports == &quot;object&quot; &amp;&amp; typeof module == &quot;object&quot;) // CommonJS
    mod(require(&quot;../../lib/codemirror&quot;));
  else if (typeof define == &quot;function&quot; &amp;&amp; define.amd) // AMD
    define([&quot;../../lib/codemirror&quot;], mod);
  else // Plain browser env
    mod(CodeMirror);
})(function(CodeMirror) {
&quot;use strict&quot;;

CodeMirror.defineMode(&quot;xml&quot;, function(config, parserConfig) {
  var indentUnit = config.indentUnit;
  var multilineTagIndentFactor = parserConfig.multilineTagIndentFactor || 1;
  var multilineTagIndentPastTag = parserConfig.multilineTagIndentPastTag;
  if (multilineTagIndentPastTag == null) multilineTagIndentPastTag = true;

  var Kludges = parserConfig.htmlMode ? {
    autoSelfClosers: {&apos;area&apos;: true, &apos;base&apos;: true, &apos;br&apos;: true, &apos;col&apos;: true, &apos;command&apos;: true,
                      &apos;embed&apos;: true, &apos;frame&apos;: true, &apos;hr&apos;: true, &apos;img&apos;: true, &apos;input&apos;: true,
                      &apos;keygen&apos;: true, &apos;link&apos;: true, &apos;meta&apos;: true, &apos;param&apos;: true, &apos;source&apos;: true,
                      &apos;track&apos;: true, &apos;wbr&apos;: true, &apos;menuitem&apos;: true},
    implicitlyClosed: {&apos;dd&apos;: true, &apos;li&apos;: true, &apos;optgroup&apos;: true, &apos;option&apos;: true, &apos;p&apos;: true,
                       &apos;rp&apos;: true, &apos;rt&apos;: true, &apos;tbody&apos;: true, &apos;td&apos;: true, &apos;tfoot&apos;: true,
                       &apos;th&apos;: true, &apos;tr&apos;: true},
    contextGrabbers: {
      &apos;dd&apos;: {&apos;dd&apos;: true, &apos;dt&apos;: true},
      &apos;dt&apos;: {&apos;dd&apos;: true, &apos;dt&apos;: true},
      &apos;li&apos;: {&apos;li&apos;: true},
      &apos;option&apos;: {&apos;option&apos;: true, &apos;optgroup&apos;: true},
      &apos;optgroup&apos;: {&apos;optgroup&apos;: true},
      &apos;p&apos;: {&apos;address&apos;: true, &apos;article&apos;: true, &apos;aside&apos;: true, &apos;blockquote&apos;: true, &apos;dir&apos;: true,
            &apos;div&apos;: true, &apos;dl&apos;: true, &apos;fieldset&apos;: true, &apos;footer&apos;: true, &apos;form&apos;: true,
            &apos;h1&apos;: true, &apos;h2&apos;: true, &apos;h3&apos;: true, &apos;h4&apos;: true, &apos;h5&apos;: true, &apos;h6&apos;: true,
            &apos;header&apos;: true, &apos;hgroup&apos;: true, &apos;hr&apos;: true, &apos;menu&apos;: true, &apos;nav&apos;: true, &apos;ol&apos;: true,
            &apos;p&apos;: true, &apos;pre&apos;: true, &apos;section&apos;: true, &apos;table&apos;: true, &apos;ul&apos;: true},
      &apos;rp&apos;: {&apos;rp&apos;: true, &apos;rt&apos;: true},
      &apos;rt&apos;: {&apos;rp&apos;: true, &apos;rt&apos;: true},
      &apos;tbody&apos;: {&apos;tbody&apos;: true, &apos;tfoot&apos;: true},
      &apos;td&apos;: {&apos;td&apos;: true, &apos;th&apos;: true},
      &apos;tfoot&apos;: {&apos;tbody&apos;: true},
      &apos;th&apos;: {&apos;td&apos;: true, &apos;th&apos;: true},
      &apos;thead&apos;: {&apos;tbody&apos;: true, &apos;tfoot&apos;: true},
      &apos;tr&apos;: {&apos;tr&apos;: true}
    },
    doNotIndent: {&quot;pre&quot;: true},
    allowUnquoted: true,
    allowMissing: true,
    caseFold: true
  } : {
    autoSelfClosers: {},
    implicitlyClosed: {},
    contextGrabbers: {},
    doNotIndent: {},
    allowUnquoted: false,
    allowMissing: false,
    caseFold: false
  };
  var alignCDATA = parserConfig.alignCDATA;

  // Return variables for tokenizers
  var type, setStyle;

  function inText(stream, state) {
    function chain(parser) {
      state.tokenize = parser;
      return parser(stream, state);
    }

    var ch = stream.next();
    if (ch == &quot;&lt;&quot;) {
      if (stream.eat(&quot;!&quot;)) {
        if (stream.eat(&quot;[&quot;)) {
          if (stream.match(&quot;CDATA[&quot;)) return chain(inBlock(&quot;atom&quot;, &quot;]]&gt;&quot;));
          else return null;
        } else if (stream.match(&quot;--&quot;)) {
          return chain(inBlock(&quot;comment&quot;, &quot;--&gt;&quot;));
        } else if (stream.match(&quot;DOCTYPE&quot;, true, true)) {
          stream.eatWhile(/[\w\._\-]/);
          return chain(doctype(1));
        } else {
          return null;
        }
      } else if (stream.eat(&quot;?&quot;)) {
        stream.eatWhile(/[\w\._\-]/);
        state.tokenize = inBlock(&quot;meta&quot;, &quot;?&gt;&quot;);
        return &quot;meta&quot;;
      } else {
        type = stream.eat(&quot;/&quot;) ? &quot;closeTag&quot; : &quot;openTag&quot;;
        state.tokenize = inTag;
        return &quot;tag bracket&quot;;
      }
    } else if (ch == &quot;&amp;&quot;) {
      var ok;
      if (stream.eat(&quot;#&quot;)) {
        if (stream.eat(&quot;x&quot;)) {
          ok = stream.eatWhile(/[a-fA-F\d]/) &amp;&amp; stream.eat(&quot;;&quot;);
        } else {
          ok = stream.eatWhile(/[\d]/) &amp;&amp; stream.eat(&quot;;&quot;);
        }
      } else {
        ok = stream.eatWhile(/[\w\.\-:]/) &amp;&amp; stream.eat(&quot;;&quot;);
      }
      return ok ? &quot;atom&quot; : &quot;error&quot;;
    } else {
      stream.eatWhile(/[^&amp;&lt;]/);
      return null;
    }
  }

  function inTag(stream, state) {
    var ch = stream.next();
    if (ch == &quot;&gt;&quot; || (ch == &quot;/&quot; &amp;&amp; stream.eat(&quot;&gt;&quot;))) {
      state.tokenize = inText;
      type = ch == &quot;&gt;&quot; ? &quot;endTag&quot; : &quot;selfcloseTag&quot;;
      return &quot;tag bracket&quot;;
    } else if (ch == &quot;=&quot;) {
      type = &quot;equals&quot;;
      return null;
    } else if (ch == &quot;&lt;&quot;) {
      state.tokenize = inText;
      state.state = baseState;
      state.tagName = state.tagStart = null;
      var next = state.tokenize(stream, state);
      return next ? next + &quot; tag error&quot; : &quot;tag error&quot;;
    } else if (/[\&apos;\&quot;]/.test(ch)) {
      state.tokenize = inAttribute(ch);
      state.stringStartCol = stream.column();
      return state.tokenize(stream, state);
    } else {
      stream.match(/^[^\s\u00a0=&lt;&gt;\&quot;\&apos;]*[^\s\u00a0=&lt;&gt;\&quot;\&apos;\/]/);
      return &quot;word&quot;;
    }
  }

  function inAttribute(quote) {
    var closure = function(stream, state) {
      while (!stream.eol()) {
        if (stream.next() == quote) {
          state.tokenize = inTag;
          break;
        }
      }
      return &quot;string&quot;;
    };
    closure.isInAttribute = true;
    return closure;
  }

  function inBlock(style, terminator) {
    return function(stream, state) {
      while (!stream.eol()) {
        if (stream.match(terminator)) {
          state.tokenize = inText;
          break;
        }
        stream.next();
      }
      return style;
    };
  }
  function doctype(depth) {
    return function(stream, state) {
      var ch;
      while ((ch = stream.next()) != null) {
        if (ch == &quot;&lt;&quot;) {
          state.tokenize = doctype(depth + 1);
          return state.tokenize(stream, state);
        } else if (ch == &quot;&gt;&quot;) {
          if (depth == 1) {
            state.tokenize = inText;
            break;
          } else {
            state.tokenize = doctype(depth - 1);
            return state.tokenize(stream, state);
          }
        }
      }
      return &quot;meta&quot;;
    };
  }

  function Context(state, tagName, startOfLine) {
    this.prev = state.context;
    this.tagName = tagName;
    this.indent = state.indented;
    this.startOfLine = startOfLine;
    if (Kludges.doNotIndent.hasOwnProperty(tagName) || (state.context &amp;&amp; state.context.noIndent))
      this.noIndent = true;
  }
  function popContext(state) {
    if (state.context) state.context = state.context.prev;
  }
  function maybePopContext(state, nextTagName) {
    var parentTagName;
    while (true) {
      if (!state.context) {
        return;
      }
      parentTagName = state.context.tagName;
      if (!Kludges.contextGrabbers.hasOwnProperty(parentTagName) ||
          !Kludges.contextGrabbers[parentTagName].hasOwnProperty(nextTagName)) {
        return;
      }
      popContext(state);
    }
  }

  function baseState(type, stream, state) {
    if (type == &quot;openTag&quot;) {
      state.tagStart = stream.column();
      return tagNameState;
    } else if (type == &quot;closeTag&quot;) {
      return closeTagNameState;
    } else {
      return baseState;
    }
  }
  function tagNameState(type, stream, state) {
    if (type == &quot;word&quot;) {
      state.tagName = stream.current();
      setStyle = &quot;tag&quot;;
      return attrState;
    } else {
      setStyle = &quot;error&quot;;
      return tagNameState;
    }
  }
  function closeTagNameState(type, stream, state) {
    if (type == &quot;word&quot;) {
      var tagName = stream.current();
      if (state.context &amp;&amp; state.context.tagName != tagName &amp;&amp;
          Kludges.implicitlyClosed.hasOwnProperty(state.context.tagName))
        popContext(state);
      if (state.context &amp;&amp; state.context.tagName == tagName) {
        setStyle = &quot;tag&quot;;
        return closeState;
      } else {
        setStyle = &quot;tag error&quot;;
        return closeStateErr;
      }
    } else {
      setStyle = &quot;error&quot;;
      return closeStateErr;
    }
  }

  function closeState(type, _stream, state) {
    if (type != &quot;endTag&quot;) {
      setStyle = &quot;error&quot;;
      return closeState;
    }
    popContext(state);
    return baseState;
  }
  function closeStateErr(type, stream, state) {
    setStyle = &quot;error&quot;;
    return closeState(type, stream, state);
  }

  function attrState(type, _stream, state) {
    if (type == &quot;word&quot;) {
      setStyle = &quot;attribute&quot;;
      return attrEqState;
    } else if (type == &quot;endTag&quot; || type == &quot;selfcloseTag&quot;) {
      var tagName = state.tagName, tagStart = state.tagStart;
      state.tagName = state.tagStart = null;
      if (type == &quot;selfcloseTag&quot; ||
          Kludges.autoSelfClosers.hasOwnProperty(tagName)) {
        maybePopContext(state, tagName);
      } else {
        maybePopContext(state, tagName);
        state.context = new Context(state, tagName, tagStart == state.indented);
      }
      return baseState;
    }
    setStyle = &quot;error&quot;;
    return attrState;
  }
  function attrEqState(type, stream, state) {
    if (type == &quot;equals&quot;) return attrValueState;
    if (!Kludges.allowMissing) setStyle = &quot;error&quot;;
    return attrState(type, stream, state);
  }
  function attrValueState(type, stream, state) {
    if (type == &quot;string&quot;) return attrContinuedState;
    if (type == &quot;word&quot; &amp;&amp; Kludges.allowUnquoted) {setStyle = &quot;string&quot;; return attrState;}
    setStyle = &quot;error&quot;;
    return attrState(type, stream, state);
  }
  function attrContinuedState(type, stream, state) {
    if (type == &quot;string&quot;) return attrContinuedState;
    return attrState(type, stream, state);
  }

  return {
    startState: function() {
      return {tokenize: inText,
              state: baseState,
              indented: 0,
              tagName: null, tagStart: null,
              context: null};
    },

    token: function(stream, state) {
      if (!state.tagName &amp;&amp; stream.sol())
        state.indented = stream.indentation();

      if (stream.eatSpace()) return null;
      type = null;
      var style = state.tokenize(stream, state);
      if ((style || type) &amp;&amp; style != &quot;comment&quot;) {
        setStyle = null;
        state.state = state.state(type || style, stream, state);
        if (setStyle)
          style = setStyle == &quot;error&quot; ? style + &quot; error&quot; : setStyle;
      }
      return style;
    },

    indent: function(state, textAfter, fullLine) {
      var context = state.context;
      // Indent multi-line strings (e.g. css).
      if (state.tokenize.isInAttribute) {
        if (state.tagStart == state.indented)
          return state.stringStartCol + 1;
        else
          return state.indented + indentUnit;
      }
      if (context &amp;&amp; context.noIndent) return CodeMirror.Pass;
      if (state.tokenize != inTag &amp;&amp; state.tokenize != inText)
        return fullLine ? fullLine.match(/^(\s*)/)[0].length : 0;
      // Indent the starts of attribute names.
      if (state.tagName) {
        if (multilineTagIndentPastTag)
          return state.tagStart + state.tagName.length + 2;
        else
          return state.tagStart + indentUnit * multilineTagIndentFactor;
      }
      if (alignCDATA &amp;&amp; /&lt;!\[CDATA\[/.test(textAfter)) return 0;
      var tagAfter = textAfter &amp;&amp; /^&lt;(\/)?([\w_:\.-]*)/.exec(textAfter);
      if (tagAfter &amp;&amp; tagAfter[1]) { // Closing tag spotted
        while (context) {
          if (context.tagName == tagAfter[2]) {
            context = context.prev;
            break;
          } else if (Kludges.implicitlyClosed.hasOwnProperty(context.tagName)) {
            context = context.prev;
          } else {
            break;
          }
        }
      } else if (tagAfter) { // Opening tag spotted
        while (context) {
          var grabbers = Kludges.contextGrabbers[context.tagName];
          if (grabbers &amp;&amp; grabbers.hasOwnProperty(tagAfter[2]))
            context = context.prev;
          else
            break;
        }
      }
      while (context &amp;&amp; !context.startOfLine)
        context = context.prev;
      if (context) return context.indent + indentUnit;
      else return 0;
    },

    electricInput: /&lt;\/[\s\w:]+&gt;$/,
    blockCommentStart: &quot;&lt;!--&quot;,
    blockCommentEnd: &quot;--&gt;&quot;,

    configuration: parserConfig.htmlMode ? &quot;html&quot; : &quot;xml&quot;,
    helperType: parserConfig.htmlMode ? &quot;html&quot; : &quot;xml&quot;
  };
});

CodeMirror.defineMIME(&quot;text/xml&quot;, &quot;xml&quot;);
CodeMirror.defineMIME(&quot;application/xml&quot;, &quot;xml&quot;);
if (!CodeMirror.mimeModes.hasOwnProperty(&quot;text/html&quot;))
  CodeMirror.defineMIME(&quot;text/html&quot;, {name: &quot;xml&quot;, htmlMode: true});

});
</code></pre>

</div>

<footer class="footer">
  Generated by <a href="https://esdoc.org">ESDoc<span data-ice="esdocVersion">(1.1.0)</span><img src="./image/esdoc-logo-mini-black.png"></a>
</footer>

<script src="script/search_index.js"></script>
<script src="script/search.js"></script>
<script src="script/pretty-print.js"></script>
<script src="script/inherited-summary.js"></script>
<script src="script/test-summary.js"></script>
<script src="script/inner-link.js"></script>
<script src="script/patch-for-local.js"></script>
</body>
</html>
