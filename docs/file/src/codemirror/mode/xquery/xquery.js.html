<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <base data-ice="baseUrl" href="../../../../../">
  <title data-ice="title">src/codemirror/mode/xquery/xquery.js | webrtcdevelopment</title>
  <link type="text/css" rel="stylesheet" href="css/style.css">
  <link type="text/css" rel="stylesheet" href="css/prettify-tomorrow.css">
  <script src="script/prettify/prettify.js"></script>
  <script src="script/manual.js"></script>
<meta name="description" content="webrtc based communication and collaboration client. Contains lot of experiments modules "><meta property="twitter:card" content="summary"><meta property="twitter:title" content="webrtcdevelopment"><meta property="twitter:description" content="webrtc based communication and collaboration client. Contains lot of experiments modules "></head>
<body class="layout-container" data-ice="rootContainer">

<header>
  <a href="./">Home</a>
  
  <a href="identifiers.html">Reference</a>
  <a href="source.html">Source</a>
  
  <div class="search-box">
  <span>
    <img src="./image/search.png">
    <span class="search-input-edge"></span><input class="search-input"><span class="search-input-edge"></span>
  </span>
    <ul class="search-result"></ul>
  </div>
<a style="position:relative; top:3px;" href="https://github.com/altanai/webrtc"><img width="20px" src="./image/github.png"></a></header>

<nav class="navigation" data-ice="nav"><div>
  <ul>
    
  <li data-ice="doc"><a data-ice="dirPath" class="nav-dir-path" href="identifiers.html#scripts">scripts</a><span data-ice="kind" class="kind-typedef">T</span><span data-ice="name"><span><a href="typedef/index.html#static-typedef-CanvasRecorder">CanvasRecorder</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-typedef">T</span><span data-ice="name"><span><a href="typedef/index.html#static-typedef-GetRecorderType">GetRecorderType</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-typedef">T</span><span data-ice="name"><span><a href="typedef/index.html#static-typedef-GifRecorder">GifRecorder</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-typedef">T</span><span data-ice="name"><span><a href="typedef/index.html#static-typedef-MRecordRTC">MRecordRTC</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-typedef">T</span><span data-ice="name"><span><a href="typedef/index.html#static-typedef-MediaStreamRecorder">MediaStreamRecorder</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-typedef">T</span><span data-ice="name"><span><a href="typedef/index.html#static-typedef-RecordRTC">RecordRTC</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-typedef">T</span><span data-ice="name"><span><a href="typedef/index.html#static-typedef-RecordRTCConfiguration">RecordRTCConfiguration</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-typedef">T</span><span data-ice="name"><span><a href="typedef/index.html#static-typedef-StereoAudioRecorder">StereoAudioRecorder</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-typedef">T</span><span data-ice="name"><span><a href="typedef/index.html#static-typedef-Whammy">Whammy</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-typedef">T</span><span data-ice="name"><span><a href="typedef/index.html#static-typedef-WhammyRecorder">WhammyRecorder</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-typedef">T</span><span data-ice="name"><span><a href="typedef/index.html#static-typedef-createFileSharingDiv">createFileSharingDiv</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-typedef">T</span><span data-ice="name"><span><a href="typedef/index.html#static-typedef-_turn.js">_turn.js</a></span></span></li>
<li data-ice="doc"><a data-ice="dirPath" class="nav-dir-path" href="identifiers.html#scripts-rtcconn">scripts/rtcconn</a><span data-ice="kind" class="kind-typedef">T</span><span data-ice="name"><span><a href="typedef/index.html#static-typedef-Whammy">Whammy</a></span></span></li>
</ul>
</div>
</nav>

<div class="content" data-ice="content"><h1 data-ice="title">src/codemirror/mode/xquery/xquery.js</h1>
<pre class="source-code line-number raw-source-code"><code class="prettyprint linenums" data-ice="content">// CodeMirror, copyright (c) by Marijn Haverbeke and others
// Distributed under an MIT license: http://codemirror.net/LICENSE

(function(mod) {
  if (typeof exports == &quot;object&quot; &amp;&amp; typeof module == &quot;object&quot;) // CommonJS
    mod(require(&quot;../../lib/codemirror&quot;));
  else if (typeof define == &quot;function&quot; &amp;&amp; define.amd) // AMD
    define([&quot;../../lib/codemirror&quot;], mod);
  else // Plain browser env
    mod(CodeMirror);
})(function(CodeMirror) {
&quot;use strict&quot;;

CodeMirror.defineMode(&quot;xquery&quot;, function() {

  // The keywords object is set to the result of this self executing
  // function. Each keyword is a property of the keywords object whose
  // value is {type: atype, style: astyle}
  var keywords = function(){
    // conveinence functions used to build keywords object
    function kw(type) {return {type: type, style: &quot;keyword&quot;};}
    var A = kw(&quot;keyword a&quot;)
      , B = kw(&quot;keyword b&quot;)
      , C = kw(&quot;keyword c&quot;)
      , operator = kw(&quot;operator&quot;)
      , atom = {type: &quot;atom&quot;, style: &quot;atom&quot;}
      , punctuation = {type: &quot;punctuation&quot;, style: null}
      , qualifier = {type: &quot;axis_specifier&quot;, style: &quot;qualifier&quot;};

    // kwObj is what is return from this function at the end
    var kwObj = {
      &apos;if&apos;: A, &apos;switch&apos;: A, &apos;while&apos;: A, &apos;for&apos;: A,
      &apos;else&apos;: B, &apos;then&apos;: B, &apos;try&apos;: B, &apos;finally&apos;: B, &apos;catch&apos;: B,
      &apos;element&apos;: C, &apos;attribute&apos;: C, &apos;let&apos;: C, &apos;implements&apos;: C, &apos;import&apos;: C, &apos;module&apos;: C, &apos;namespace&apos;: C,
      &apos;return&apos;: C, &apos;super&apos;: C, &apos;this&apos;: C, &apos;throws&apos;: C, &apos;where&apos;: C, &apos;private&apos;: C,
      &apos;,&apos;: punctuation,
      &apos;null&apos;: atom, &apos;fn:false()&apos;: atom, &apos;fn:true()&apos;: atom
    };

    // a list of &apos;basic&apos; keywords. For each add a property to kwObj with the value of
    // {type: basic[i], style: &quot;keyword&quot;} e.g. &apos;after&apos; --&gt; {type: &quot;after&quot;, style: &quot;keyword&quot;}
    var basic = [&apos;after&apos;,&apos;ancestor&apos;,&apos;ancestor-or-self&apos;,&apos;and&apos;,&apos;as&apos;,&apos;ascending&apos;,&apos;assert&apos;,&apos;attribute&apos;,&apos;before&apos;,
    &apos;by&apos;,&apos;case&apos;,&apos;cast&apos;,&apos;child&apos;,&apos;comment&apos;,&apos;declare&apos;,&apos;default&apos;,&apos;define&apos;,&apos;descendant&apos;,&apos;descendant-or-self&apos;,
    &apos;descending&apos;,&apos;document&apos;,&apos;document-node&apos;,&apos;element&apos;,&apos;else&apos;,&apos;eq&apos;,&apos;every&apos;,&apos;except&apos;,&apos;external&apos;,&apos;following&apos;,
    &apos;following-sibling&apos;,&apos;follows&apos;,&apos;for&apos;,&apos;function&apos;,&apos;if&apos;,&apos;import&apos;,&apos;in&apos;,&apos;instance&apos;,&apos;intersect&apos;,&apos;item&apos;,
    &apos;let&apos;,&apos;module&apos;,&apos;namespace&apos;,&apos;node&apos;,&apos;node&apos;,&apos;of&apos;,&apos;only&apos;,&apos;or&apos;,&apos;order&apos;,&apos;parent&apos;,&apos;precedes&apos;,&apos;preceding&apos;,
    &apos;preceding-sibling&apos;,&apos;processing-instruction&apos;,&apos;ref&apos;,&apos;return&apos;,&apos;returns&apos;,&apos;satisfies&apos;,&apos;schema&apos;,&apos;schema-element&apos;,
    &apos;self&apos;,&apos;some&apos;,&apos;sortby&apos;,&apos;stable&apos;,&apos;text&apos;,&apos;then&apos;,&apos;to&apos;,&apos;treat&apos;,&apos;typeswitch&apos;,&apos;union&apos;,&apos;variable&apos;,&apos;version&apos;,&apos;where&apos;,
    &apos;xquery&apos;, &apos;empty-sequence&apos;];
    for(var i=0, l=basic.length; i &lt; l; i++) { kwObj[basic[i]] = kw(basic[i]);};

    // a list of types. For each add a property to kwObj with the value of
    // {type: &quot;atom&quot;, style: &quot;atom&quot;}
    var types = [&apos;xs:string&apos;, &apos;xs:float&apos;, &apos;xs:decimal&apos;, &apos;xs:double&apos;, &apos;xs:integer&apos;, &apos;xs:boolean&apos;, &apos;xs:date&apos;, &apos;xs:dateTime&apos;,
    &apos;xs:time&apos;, &apos;xs:duration&apos;, &apos;xs:dayTimeDuration&apos;, &apos;xs:time&apos;, &apos;xs:yearMonthDuration&apos;, &apos;numeric&apos;, &apos;xs:hexBinary&apos;,
    &apos;xs:base64Binary&apos;, &apos;xs:anyURI&apos;, &apos;xs:QName&apos;, &apos;xs:byte&apos;,&apos;xs:boolean&apos;,&apos;xs:anyURI&apos;,&apos;xf:yearMonthDuration&apos;];
    for(var i=0, l=types.length; i &lt; l; i++) { kwObj[types[i]] = atom;};

    // each operator will add a property to kwObj with value of {type: &quot;operator&quot;, style: &quot;keyword&quot;}
    var operators = [&apos;eq&apos;, &apos;ne&apos;, &apos;lt&apos;, &apos;le&apos;, &apos;gt&apos;, &apos;ge&apos;, &apos;:=&apos;, &apos;=&apos;, &apos;&gt;&apos;, &apos;&gt;=&apos;, &apos;&lt;&apos;, &apos;&lt;=&apos;, &apos;.&apos;, &apos;|&apos;, &apos;?&apos;, &apos;and&apos;, &apos;or&apos;, &apos;div&apos;, &apos;idiv&apos;, &apos;mod&apos;, &apos;*&apos;, &apos;/&apos;, &apos;+&apos;, &apos;-&apos;];
    for(var i=0, l=operators.length; i &lt; l; i++) { kwObj[operators[i]] = operator;};

    // each axis_specifiers will add a property to kwObj with value of {type: &quot;axis_specifier&quot;, style: &quot;qualifier&quot;}
    var axis_specifiers = [&quot;self::&quot;, &quot;attribute::&quot;, &quot;child::&quot;, &quot;descendant::&quot;, &quot;descendant-or-self::&quot;, &quot;parent::&quot;,
    &quot;ancestor::&quot;, &quot;ancestor-or-self::&quot;, &quot;following::&quot;, &quot;preceding::&quot;, &quot;following-sibling::&quot;, &quot;preceding-sibling::&quot;];
    for(var i=0, l=axis_specifiers.length; i &lt; l; i++) { kwObj[axis_specifiers[i]] = qualifier; };

    return kwObj;
  }();

  // Used as scratch variables to communicate multiple values without
  // consing up tons of objects.
  var type, content;

  function ret(tp, style, cont) {
    type = tp; content = cont;
    return style;
  }

  function chain(stream, state, f) {
    state.tokenize = f;
    return f(stream, state);
  }

  // the primary mode tokenizer
  function tokenBase(stream, state) {
    var ch = stream.next(),
        mightBeFunction = false,
        isEQName = isEQNameAhead(stream);

    // an XML tag (if not in some sub, chained tokenizer)
    if (ch == &quot;&lt;&quot;) {
      if(stream.match(&quot;!--&quot;, true))
        return chain(stream, state, tokenXMLComment);

      if(stream.match(&quot;![CDATA&quot;, false)) {
        state.tokenize = tokenCDATA;
        return ret(&quot;tag&quot;, &quot;tag&quot;);
      }

      if(stream.match(&quot;?&quot;, false)) {
        return chain(stream, state, tokenPreProcessing);
      }

      var isclose = stream.eat(&quot;/&quot;);
      stream.eatSpace();
      var tagName = &quot;&quot;, c;
      while ((c = stream.eat(/[^\s\u00a0=&lt;&gt;\&quot;\&apos;\/?]/))) tagName += c;

      return chain(stream, state, tokenTag(tagName, isclose));
    }
    // start code block
    else if(ch == &quot;{&quot;) {
      pushStateStack(state,{ type: &quot;codeblock&quot;});
      return ret(&quot;&quot;, null);
    }
    // end code block
    else if(ch == &quot;}&quot;) {
      popStateStack(state);
      return ret(&quot;&quot;, null);
    }
    // if we&apos;re in an XML block
    else if(isInXmlBlock(state)) {
      if(ch == &quot;&gt;&quot;)
        return ret(&quot;tag&quot;, &quot;tag&quot;);
      else if(ch == &quot;/&quot; &amp;&amp; stream.eat(&quot;&gt;&quot;)) {
        popStateStack(state);
        return ret(&quot;tag&quot;, &quot;tag&quot;);
      }
      else
        return ret(&quot;word&quot;, &quot;variable&quot;);
    }
    // if a number
    else if (/\d/.test(ch)) {
      stream.match(/^\d*(?:\.\d*)?(?:E[+\-]?\d+)?/);
      return ret(&quot;number&quot;, &quot;atom&quot;);
    }
    // comment start
    else if (ch === &quot;(&quot; &amp;&amp; stream.eat(&quot;:&quot;)) {
      pushStateStack(state, { type: &quot;comment&quot;});
      return chain(stream, state, tokenComment);
    }
    // quoted string
    else if (  !isEQName &amp;&amp; (ch === &apos;&quot;&apos; || ch === &quot;&apos;&quot;))
      return chain(stream, state, tokenString(ch));
    // variable
    else if(ch === &quot;$&quot;) {
      return chain(stream, state, tokenVariable);
    }
    // assignment
    else if(ch ===&quot;:&quot; &amp;&amp; stream.eat(&quot;=&quot;)) {
      return ret(&quot;operator&quot;, &quot;keyword&quot;);
    }
    // open paren
    else if(ch === &quot;(&quot;) {
      pushStateStack(state, { type: &quot;paren&quot;});
      return ret(&quot;&quot;, null);
    }
    // close paren
    else if(ch === &quot;)&quot;) {
      popStateStack(state);
      return ret(&quot;&quot;, null);
    }
    // open paren
    else if(ch === &quot;[&quot;) {
      pushStateStack(state, { type: &quot;bracket&quot;});
      return ret(&quot;&quot;, null);
    }
    // close paren
    else if(ch === &quot;]&quot;) {
      popStateStack(state);
      return ret(&quot;&quot;, null);
    }
    else {
      var known = keywords.propertyIsEnumerable(ch) &amp;&amp; keywords[ch];

      // if there&apos;s a EQName ahead, consume the rest of the string portion, it&apos;s likely a function
      if(isEQName &amp;&amp; ch === &apos;\&quot;&apos;) while(stream.next() !== &apos;&quot;&apos;){}
      if(isEQName &amp;&amp; ch === &apos;\&apos;&apos;) while(stream.next() !== &apos;\&apos;&apos;){}

      // gobble up a word if the character is not known
      if(!known) stream.eatWhile(/[\w\$_-]/);

      // gobble a colon in the case that is a lib func type call fn:doc
      var foundColon = stream.eat(&quot;:&quot;);

      // if there&apos;s not a second colon, gobble another word. Otherwise, it&apos;s probably an axis specifier
      // which should get matched as a keyword
      if(!stream.eat(&quot;:&quot;) &amp;&amp; foundColon) {
        stream.eatWhile(/[\w\$_-]/);
      }
      // if the next non whitespace character is an open paren, this is probably a function (if not a keyword of other sort)
      if(stream.match(/^[ \t]*\(/, false)) {
        mightBeFunction = true;
      }
      // is the word a keyword?
      var word = stream.current();
      known = keywords.propertyIsEnumerable(word) &amp;&amp; keywords[word];

      // if we think it&apos;s a function call but not yet known,
      // set style to variable for now for lack of something better
      if(mightBeFunction &amp;&amp; !known) known = {type: &quot;function_call&quot;, style: &quot;variable def&quot;};

      // if the previous word was element, attribute, axis specifier, this word should be the name of that
      if(isInXmlConstructor(state)) {
        popStateStack(state);
        return ret(&quot;word&quot;, &quot;variable&quot;, word);
      }
      // as previously checked, if the word is element,attribute, axis specifier, call it an &quot;xmlconstructor&quot; and
      // push the stack so we know to look for it on the next word
      if(word == &quot;element&quot; || word == &quot;attribute&quot; || known.type == &quot;axis_specifier&quot;) pushStateStack(state, {type: &quot;xmlconstructor&quot;});

      // if the word is known, return the details of that else just call this a generic &apos;word&apos;
      return known ? ret(known.type, known.style, word) :
                     ret(&quot;word&quot;, &quot;variable&quot;, word);
    }
  }

  // handle comments, including nested
  function tokenComment(stream, state) {
    var maybeEnd = false, maybeNested = false, nestedCount = 0, ch;
    while (ch = stream.next()) {
      if (ch == &quot;)&quot; &amp;&amp; maybeEnd) {
        if(nestedCount &gt; 0)
          nestedCount--;
        else {
          popStateStack(state);
          break;
        }
      }
      else if(ch == &quot;:&quot; &amp;&amp; maybeNested) {
        nestedCount++;
      }
      maybeEnd = (ch == &quot;:&quot;);
      maybeNested = (ch == &quot;(&quot;);
    }

    return ret(&quot;comment&quot;, &quot;comment&quot;);
  }

  // tokenizer for string literals
  // optionally pass a tokenizer function to set state.tokenize back to when finished
  function tokenString(quote, f) {
    return function(stream, state) {
      var ch;

      if(isInString(state) &amp;&amp; stream.current() == quote) {
        popStateStack(state);
        if(f) state.tokenize = f;
        return ret(&quot;string&quot;, &quot;string&quot;);
      }

      pushStateStack(state, { type: &quot;string&quot;, name: quote, tokenize: tokenString(quote, f) });

      // if we&apos;re in a string and in an XML block, allow an embedded code block
      if(stream.match(&quot;{&quot;, false) &amp;&amp; isInXmlAttributeBlock(state)) {
        state.tokenize = tokenBase;
        return ret(&quot;string&quot;, &quot;string&quot;);
      }


      while (ch = stream.next()) {
        if (ch ==  quote) {
          popStateStack(state);
          if(f) state.tokenize = f;
          break;
        }
        else {
          // if we&apos;re in a string and in an XML block, allow an embedded code block in an attribute
          if(stream.match(&quot;{&quot;, false) &amp;&amp; isInXmlAttributeBlock(state)) {
            state.tokenize = tokenBase;
            return ret(&quot;string&quot;, &quot;string&quot;);
          }

        }
      }

      return ret(&quot;string&quot;, &quot;string&quot;);
    };
  }

  // tokenizer for variables
  function tokenVariable(stream, state) {
    var isVariableChar = /[\w\$_-]/;

    // a variable may start with a quoted EQName so if the next character is quote, consume to the next quote
    if(stream.eat(&quot;\&quot;&quot;)) {
      while(stream.next() !== &apos;\&quot;&apos;){};
      stream.eat(&quot;:&quot;);
    } else {
      stream.eatWhile(isVariableChar);
      if(!stream.match(&quot;:=&quot;, false)) stream.eat(&quot;:&quot;);
    }
    stream.eatWhile(isVariableChar);
    state.tokenize = tokenBase;
    return ret(&quot;variable&quot;, &quot;variable&quot;);
  }

  // tokenizer for XML tags
  function tokenTag(name, isclose) {
    return function(stream, state) {
      stream.eatSpace();
      if(isclose &amp;&amp; stream.eat(&quot;&gt;&quot;)) {
        popStateStack(state);
        state.tokenize = tokenBase;
        return ret(&quot;tag&quot;, &quot;tag&quot;);
      }
      // self closing tag without attributes?
      if(!stream.eat(&quot;/&quot;))
        pushStateStack(state, { type: &quot;tag&quot;, name: name, tokenize: tokenBase});
      if(!stream.eat(&quot;&gt;&quot;)) {
        state.tokenize = tokenAttribute;
        return ret(&quot;tag&quot;, &quot;tag&quot;);
      }
      else {
        state.tokenize = tokenBase;
      }
      return ret(&quot;tag&quot;, &quot;tag&quot;);
    };
  }

  // tokenizer for XML attributes
  function tokenAttribute(stream, state) {
    var ch = stream.next();

    if(ch == &quot;/&quot; &amp;&amp; stream.eat(&quot;&gt;&quot;)) {
      if(isInXmlAttributeBlock(state)) popStateStack(state);
      if(isInXmlBlock(state)) popStateStack(state);
      return ret(&quot;tag&quot;, &quot;tag&quot;);
    }
    if(ch == &quot;&gt;&quot;) {
      if(isInXmlAttributeBlock(state)) popStateStack(state);
      return ret(&quot;tag&quot;, &quot;tag&quot;);
    }
    if(ch == &quot;=&quot;)
      return ret(&quot;&quot;, null);
    // quoted string
    if (ch == &apos;&quot;&apos; || ch == &quot;&apos;&quot;)
      return chain(stream, state, tokenString(ch, tokenAttribute));

    if(!isInXmlAttributeBlock(state))
      pushStateStack(state, { type: &quot;attribute&quot;, tokenize: tokenAttribute});

    stream.eat(/[a-zA-Z_:]/);
    stream.eatWhile(/[-a-zA-Z0-9_:.]/);
    stream.eatSpace();

    // the case where the attribute has not value and the tag was closed
    if(stream.match(&quot;&gt;&quot;, false) || stream.match(&quot;/&quot;, false)) {
      popStateStack(state);
      state.tokenize = tokenBase;
    }

    return ret(&quot;attribute&quot;, &quot;attribute&quot;);
  }

  // handle comments, including nested
  function tokenXMLComment(stream, state) {
    var ch;
    while (ch = stream.next()) {
      if (ch == &quot;-&quot; &amp;&amp; stream.match(&quot;-&gt;&quot;, true)) {
        state.tokenize = tokenBase;
        return ret(&quot;comment&quot;, &quot;comment&quot;);
      }
    }
  }


  // handle CDATA
  function tokenCDATA(stream, state) {
    var ch;
    while (ch = stream.next()) {
      if (ch == &quot;]&quot; &amp;&amp; stream.match(&quot;]&quot;, true)) {
        state.tokenize = tokenBase;
        return ret(&quot;comment&quot;, &quot;comment&quot;);
      }
    }
  }

  // handle preprocessing instructions
  function tokenPreProcessing(stream, state) {
    var ch;
    while (ch = stream.next()) {
      if (ch == &quot;?&quot; &amp;&amp; stream.match(&quot;&gt;&quot;, true)) {
        state.tokenize = tokenBase;
        return ret(&quot;comment&quot;, &quot;comment meta&quot;);
      }
    }
  }


  // functions to test the current context of the state
  function isInXmlBlock(state) { return isIn(state, &quot;tag&quot;); }
  function isInXmlAttributeBlock(state) { return isIn(state, &quot;attribute&quot;); }
  function isInXmlConstructor(state) { return isIn(state, &quot;xmlconstructor&quot;); }
  function isInString(state) { return isIn(state, &quot;string&quot;); }

  function isEQNameAhead(stream) {
    // assume we&apos;ve already eaten a quote (&quot;)
    if(stream.current() === &apos;&quot;&apos;)
      return stream.match(/^[^\&quot;]+\&quot;\:/, false);
    else if(stream.current() === &apos;\&apos;&apos;)
      return stream.match(/^[^\&quot;]+\&apos;\:/, false);
    else
      return false;
  }

  function isIn(state, type) {
    return (state.stack.length &amp;&amp; state.stack[state.stack.length - 1].type == type);
  }

  function pushStateStack(state, newState) {
    state.stack.push(newState);
  }

  function popStateStack(state) {
    state.stack.pop();
    var reinstateTokenize = state.stack.length &amp;&amp; state.stack[state.stack.length-1].tokenize;
    state.tokenize = reinstateTokenize || tokenBase;
  }

  // the interface for the mode API
  return {
    startState: function() {
      return {
        tokenize: tokenBase,
        cc: [],
        stack: []
      };
    },

    token: function(stream, state) {
      if (stream.eatSpace()) return null;
      var style = state.tokenize(stream, state);
      return style;
    },

    blockCommentStart: &quot;(:&quot;,
    blockCommentEnd: &quot;:)&quot;

  };

});

CodeMirror.defineMIME(&quot;application/xquery&quot;, &quot;xquery&quot;);

});
</code></pre>

</div>

<footer class="footer">
  Generated by <a href="https://esdoc.org">ESDoc<span data-ice="esdocVersion">(1.1.0)</span><img src="./image/esdoc-logo-mini-black.png"></a>
</footer>

<script src="script/search_index.js"></script>
<script src="script/search.js"></script>
<script src="script/pretty-print.js"></script>
<script src="script/inherited-summary.js"></script>
<script src="script/test-summary.js"></script>
<script src="script/inner-link.js"></script>
<script src="script/patch-for-local.js"></script>
</body>
</html>
