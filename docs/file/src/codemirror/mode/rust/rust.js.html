<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <base data-ice="baseUrl" href="../../../../../">
  <title data-ice="title">src/codemirror/mode/rust/rust.js | webrtcdevelopment</title>
  <link type="text/css" rel="stylesheet" href="css/style.css">
  <link type="text/css" rel="stylesheet" href="css/prettify-tomorrow.css">
  <script src="script/prettify/prettify.js"></script>
  <script src="script/manual.js"></script>
<meta name="description" content="webrtc based communication and collaboration client. Contains lot of experiments modules "><meta property="twitter:card" content="summary"><meta property="twitter:title" content="webrtcdevelopment"><meta property="twitter:description" content="webrtc based communication and collaboration client. Contains lot of experiments modules "></head>
<body class="layout-container" data-ice="rootContainer">

<header>
  <a href="./">Home</a>
  
  <a href="identifiers.html">Reference</a>
  <a href="source.html">Source</a>
  
  <div class="search-box">
  <span>
    <img src="./image/search.png">
    <span class="search-input-edge"></span><input class="search-input"><span class="search-input-edge"></span>
  </span>
    <ul class="search-result"></ul>
  </div>
<a style="position:relative; top:3px;" href="https://github.com/altanai/webrtc"><img width="20px" src="./image/github.png"></a></header>

<nav class="navigation" data-ice="nav"><div>
  <ul>
    
  <li data-ice="doc"><a data-ice="dirPath" class="nav-dir-path" href="identifiers.html#scripts">scripts</a><span data-ice="kind" class="kind-typedef">T</span><span data-ice="name"><span><a href="typedef/index.html#static-typedef-CanvasRecorder">CanvasRecorder</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-typedef">T</span><span data-ice="name"><span><a href="typedef/index.html#static-typedef-GetRecorderType">GetRecorderType</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-typedef">T</span><span data-ice="name"><span><a href="typedef/index.html#static-typedef-GifRecorder">GifRecorder</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-typedef">T</span><span data-ice="name"><span><a href="typedef/index.html#static-typedef-MRecordRTC">MRecordRTC</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-typedef">T</span><span data-ice="name"><span><a href="typedef/index.html#static-typedef-MediaStreamRecorder">MediaStreamRecorder</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-typedef">T</span><span data-ice="name"><span><a href="typedef/index.html#static-typedef-RecordRTC">RecordRTC</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-typedef">T</span><span data-ice="name"><span><a href="typedef/index.html#static-typedef-RecordRTCConfiguration">RecordRTCConfiguration</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-typedef">T</span><span data-ice="name"><span><a href="typedef/index.html#static-typedef-StereoAudioRecorder">StereoAudioRecorder</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-typedef">T</span><span data-ice="name"><span><a href="typedef/index.html#static-typedef-Whammy">Whammy</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-typedef">T</span><span data-ice="name"><span><a href="typedef/index.html#static-typedef-WhammyRecorder">WhammyRecorder</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-typedef">T</span><span data-ice="name"><span><a href="typedef/index.html#static-typedef-createFileSharingDiv">createFileSharingDiv</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-typedef">T</span><span data-ice="name"><span><a href="typedef/index.html#static-typedef-_turn.js">_turn.js</a></span></span></li>
<li data-ice="doc"><a data-ice="dirPath" class="nav-dir-path" href="identifiers.html#scripts-rtcconn">scripts/rtcconn</a><span data-ice="kind" class="kind-typedef">T</span><span data-ice="name"><span><a href="typedef/index.html#static-typedef-Whammy">Whammy</a></span></span></li>
</ul>
</div>
</nav>

<div class="content" data-ice="content"><h1 data-ice="title">src/codemirror/mode/rust/rust.js</h1>
<pre class="source-code line-number raw-source-code"><code class="prettyprint linenums" data-ice="content">// CodeMirror, copyright (c) by Marijn Haverbeke and others
// Distributed under an MIT license: http://codemirror.net/LICENSE

(function(mod) {
  if (typeof exports == &quot;object&quot; &amp;&amp; typeof module == &quot;object&quot;) // CommonJS
    mod(require(&quot;../../lib/codemirror&quot;));
  else if (typeof define == &quot;function&quot; &amp;&amp; define.amd) // AMD
    define([&quot;../../lib/codemirror&quot;], mod);
  else // Plain browser env
    mod(CodeMirror);
})(function(CodeMirror) {
&quot;use strict&quot;;

CodeMirror.defineMode(&quot;rust&quot;, function() {
  var indentUnit = 4, altIndentUnit = 2;
  var valKeywords = {
    &quot;if&quot;: &quot;if-style&quot;, &quot;while&quot;: &quot;if-style&quot;, &quot;loop&quot;: &quot;else-style&quot;, &quot;else&quot;: &quot;else-style&quot;,
    &quot;do&quot;: &quot;else-style&quot;, &quot;ret&quot;: &quot;else-style&quot;, &quot;fail&quot;: &quot;else-style&quot;,
    &quot;break&quot;: &quot;atom&quot;, &quot;cont&quot;: &quot;atom&quot;, &quot;const&quot;: &quot;let&quot;, &quot;resource&quot;: &quot;fn&quot;,
    &quot;let&quot;: &quot;let&quot;, &quot;fn&quot;: &quot;fn&quot;, &quot;for&quot;: &quot;for&quot;, &quot;alt&quot;: &quot;alt&quot;, &quot;iface&quot;: &quot;iface&quot;,
    &quot;impl&quot;: &quot;impl&quot;, &quot;type&quot;: &quot;type&quot;, &quot;enum&quot;: &quot;enum&quot;, &quot;mod&quot;: &quot;mod&quot;,
    &quot;as&quot;: &quot;op&quot;, &quot;true&quot;: &quot;atom&quot;, &quot;false&quot;: &quot;atom&quot;, &quot;assert&quot;: &quot;op&quot;, &quot;check&quot;: &quot;op&quot;,
    &quot;claim&quot;: &quot;op&quot;, &quot;native&quot;: &quot;ignore&quot;, &quot;unsafe&quot;: &quot;ignore&quot;, &quot;import&quot;: &quot;else-style&quot;,
    &quot;export&quot;: &quot;else-style&quot;, &quot;copy&quot;: &quot;op&quot;, &quot;log&quot;: &quot;op&quot;, &quot;log_err&quot;: &quot;op&quot;,
    &quot;use&quot;: &quot;op&quot;, &quot;bind&quot;: &quot;op&quot;, &quot;self&quot;: &quot;atom&quot;, &quot;struct&quot;: &quot;enum&quot;
  };
  var typeKeywords = function() {
    var keywords = {&quot;fn&quot;: &quot;fn&quot;, &quot;block&quot;: &quot;fn&quot;, &quot;obj&quot;: &quot;obj&quot;};
    var atoms = &quot;bool uint int i8 i16 i32 i64 u8 u16 u32 u64 float f32 f64 str char&quot;.split(&quot; &quot;);
    for (var i = 0, e = atoms.length; i &lt; e; ++i) keywords[atoms[i]] = &quot;atom&quot;;
    return keywords;
  }();
  var operatorChar = /[+\-*&amp;%=&lt;&gt;!?|\.@]/;

  // Tokenizer

  // Used as scratch variable to communicate multiple values without
  // consing up tons of objects.
  var tcat, content;
  function r(tc, style) {
    tcat = tc;
    return style;
  }

  function tokenBase(stream, state) {
    var ch = stream.next();
    if (ch == &apos;&quot;&apos;) {
      state.tokenize = tokenString;
      return state.tokenize(stream, state);
    }
    if (ch == &quot;&apos;&quot;) {
      tcat = &quot;atom&quot;;
      if (stream.eat(&quot;\\&quot;)) {
        if (stream.skipTo(&quot;&apos;&quot;)) { stream.next(); return &quot;string&quot;; }
        else { return &quot;error&quot;; }
      } else {
        stream.next();
        return stream.eat(&quot;&apos;&quot;) ? &quot;string&quot; : &quot;error&quot;;
      }
    }
    if (ch == &quot;/&quot;) {
      if (stream.eat(&quot;/&quot;)) { stream.skipToEnd(); return &quot;comment&quot;; }
      if (stream.eat(&quot;*&quot;)) {
        state.tokenize = tokenComment(1);
        return state.tokenize(stream, state);
      }
    }
    if (ch == &quot;#&quot;) {
      if (stream.eat(&quot;[&quot;)) { tcat = &quot;open-attr&quot;; return null; }
      stream.eatWhile(/\w/);
      return r(&quot;macro&quot;, &quot;meta&quot;);
    }
    if (ch == &quot;:&quot; &amp;&amp; stream.match(&quot;:&lt;&quot;)) {
      return r(&quot;op&quot;, null);
    }
    if (ch.match(/\d/) || (ch == &quot;.&quot; &amp;&amp; stream.eat(/\d/))) {
      var flp = false;
      if (!stream.match(/^x[\da-f]+/i) &amp;&amp; !stream.match(/^b[01]+/)) {
        stream.eatWhile(/\d/);
        if (stream.eat(&quot;.&quot;)) { flp = true; stream.eatWhile(/\d/); }
        if (stream.match(/^e[+\-]?\d+/i)) { flp = true; }
      }
      if (flp) stream.match(/^f(?:32|64)/);
      else stream.match(/^[ui](?:8|16|32|64)/);
      return r(&quot;atom&quot;, &quot;number&quot;);
    }
    if (ch.match(/[()\[\]{}:;,]/)) return r(ch, null);
    if (ch == &quot;-&quot; &amp;&amp; stream.eat(&quot;&gt;&quot;)) return r(&quot;-&gt;&quot;, null);
    if (ch.match(operatorChar)) {
      stream.eatWhile(operatorChar);
      return r(&quot;op&quot;, null);
    }
    stream.eatWhile(/\w/);
    content = stream.current();
    if (stream.match(/^::\w/)) {
      stream.backUp(1);
      return r(&quot;prefix&quot;, &quot;variable-2&quot;);
    }
    if (state.keywords.propertyIsEnumerable(content))
      return r(state.keywords[content], content.match(/true|false/) ? &quot;atom&quot; : &quot;keyword&quot;);
    return r(&quot;name&quot;, &quot;variable&quot;);
  }

  function tokenString(stream, state) {
    var ch, escaped = false;
    while (ch = stream.next()) {
      if (ch == &apos;&quot;&apos; &amp;&amp; !escaped) {
        state.tokenize = tokenBase;
        return r(&quot;atom&quot;, &quot;string&quot;);
      }
      escaped = !escaped &amp;&amp; ch == &quot;\\&quot;;
    }
    // Hack to not confuse the parser when a string is split in
    // pieces.
    return r(&quot;op&quot;, &quot;string&quot;);
  }

  function tokenComment(depth) {
    return function(stream, state) {
      var lastCh = null, ch;
      while (ch = stream.next()) {
        if (ch == &quot;/&quot; &amp;&amp; lastCh == &quot;*&quot;) {
          if (depth == 1) {
            state.tokenize = tokenBase;
            break;
          } else {
            state.tokenize = tokenComment(depth - 1);
            return state.tokenize(stream, state);
          }
        }
        if (ch == &quot;*&quot; &amp;&amp; lastCh == &quot;/&quot;) {
          state.tokenize = tokenComment(depth + 1);
          return state.tokenize(stream, state);
        }
        lastCh = ch;
      }
      return &quot;comment&quot;;
    };
  }

  // Parser

  var cx = {state: null, stream: null, marked: null, cc: null};
  function pass() {
    for (var i = arguments.length - 1; i &gt;= 0; i--) cx.cc.push(arguments[i]);
  }
  function cont() {
    pass.apply(null, arguments);
    return true;
  }

  function pushlex(type, info) {
    var result = function() {
      var state = cx.state;
      state.lexical = {indented: state.indented, column: cx.stream.column(),
                       type: type, prev: state.lexical, info: info};
    };
    result.lex = true;
    return result;
  }
  function poplex() {
    var state = cx.state;
    if (state.lexical.prev) {
      if (state.lexical.type == &quot;)&quot;)
        state.indented = state.lexical.indented;
      state.lexical = state.lexical.prev;
    }
  }
  function typecx() { cx.state.keywords = typeKeywords; }
  function valcx() { cx.state.keywords = valKeywords; }
  poplex.lex = typecx.lex = valcx.lex = true;

  function commasep(comb, end) {
    function more(type) {
      if (type == &quot;,&quot;) return cont(comb, more);
      if (type == end) return cont();
      return cont(more);
    }
    return function(type) {
      if (type == end) return cont();
      return pass(comb, more);
    };
  }

  function stat_of(comb, tag) {
    return cont(pushlex(&quot;stat&quot;, tag), comb, poplex, block);
  }
  function block(type) {
    if (type == &quot;}&quot;) return cont();
    if (type == &quot;let&quot;) return stat_of(letdef1, &quot;let&quot;);
    if (type == &quot;fn&quot;) return stat_of(fndef);
    if (type == &quot;type&quot;) return cont(pushlex(&quot;stat&quot;), tydef, endstatement, poplex, block);
    if (type == &quot;enum&quot;) return stat_of(enumdef);
    if (type == &quot;mod&quot;) return stat_of(mod);
    if (type == &quot;iface&quot;) return stat_of(iface);
    if (type == &quot;impl&quot;) return stat_of(impl);
    if (type == &quot;open-attr&quot;) return cont(pushlex(&quot;]&quot;), commasep(expression, &quot;]&quot;), poplex);
    if (type == &quot;ignore&quot; || type.match(/[\]\);,]/)) return cont(block);
    return pass(pushlex(&quot;stat&quot;), expression, poplex, endstatement, block);
  }
  function endstatement(type) {
    if (type == &quot;;&quot;) return cont();
    return pass();
  }
  function expression(type) {
    if (type == &quot;atom&quot; || type == &quot;name&quot;) return cont(maybeop);
    if (type == &quot;{&quot;) return cont(pushlex(&quot;}&quot;), exprbrace, poplex);
    if (type.match(/[\[\(]/)) return matchBrackets(type, expression);
    if (type.match(/[\]\)\};,]/)) return pass();
    if (type == &quot;if-style&quot;) return cont(expression, expression);
    if (type == &quot;else-style&quot; || type == &quot;op&quot;) return cont(expression);
    if (type == &quot;for&quot;) return cont(pattern, maybetype, inop, expression, expression);
    if (type == &quot;alt&quot;) return cont(expression, altbody);
    if (type == &quot;fn&quot;) return cont(fndef);
    if (type == &quot;macro&quot;) return cont(macro);
    return cont();
  }
  function maybeop(type) {
    if (content == &quot;.&quot;) return cont(maybeprop);
    if (content == &quot;::&lt;&quot;){return cont(typarams, maybeop);}
    if (type == &quot;op&quot; || content == &quot;:&quot;) return cont(expression);
    if (type == &quot;(&quot; || type == &quot;[&quot;) return matchBrackets(type, expression);
    return pass();
  }
  function maybeprop() {
    if (content.match(/^\w+$/)) {cx.marked = &quot;variable&quot;; return cont(maybeop);}
    return pass(expression);
  }
  function exprbrace(type) {
    if (type == &quot;op&quot;) {
      if (content == &quot;|&quot;) return cont(blockvars, poplex, pushlex(&quot;}&quot;, &quot;block&quot;), block);
      if (content == &quot;||&quot;) return cont(poplex, pushlex(&quot;}&quot;, &quot;block&quot;), block);
    }
    if (content == &quot;mutable&quot; || (content.match(/^\w+$/) &amp;&amp; cx.stream.peek() == &quot;:&quot;
                                 &amp;&amp; !cx.stream.match(&quot;::&quot;, false)))
      return pass(record_of(expression));
    return pass(block);
  }
  function record_of(comb) {
    function ro(type) {
      if (content == &quot;mutable&quot; || content == &quot;with&quot;) {cx.marked = &quot;keyword&quot;; return cont(ro);}
      if (content.match(/^\w*$/)) {cx.marked = &quot;variable&quot;; return cont(ro);}
      if (type == &quot;:&quot;) return cont(comb, ro);
      if (type == &quot;}&quot;) return cont();
      return cont(ro);
    }
    return ro;
  }
  function blockvars(type) {
    if (type == &quot;name&quot;) {cx.marked = &quot;def&quot;; return cont(blockvars);}
    if (type == &quot;op&quot; &amp;&amp; content == &quot;|&quot;) return cont();
    return cont(blockvars);
  }

  function letdef1(type) {
    if (type.match(/[\]\)\};]/)) return cont();
    if (content == &quot;=&quot;) return cont(expression, letdef2);
    if (type == &quot;,&quot;) return cont(letdef1);
    return pass(pattern, maybetype, letdef1);
  }
  function letdef2(type) {
    if (type.match(/[\]\)\};,]/)) return pass(letdef1);
    else return pass(expression, letdef2);
  }
  function maybetype(type) {
    if (type == &quot;:&quot;) return cont(typecx, rtype, valcx);
    return pass();
  }
  function inop(type) {
    if (type == &quot;name&quot; &amp;&amp; content == &quot;in&quot;) {cx.marked = &quot;keyword&quot;; return cont();}
    return pass();
  }
  function fndef(type) {
    if (content == &quot;@&quot; || content == &quot;~&quot;) {cx.marked = &quot;keyword&quot;; return cont(fndef);}
    if (type == &quot;name&quot;) {cx.marked = &quot;def&quot;; return cont(fndef);}
    if (content == &quot;&lt;&quot;) return cont(typarams, fndef);
    if (type == &quot;{&quot;) return pass(expression);
    if (type == &quot;(&quot;) return cont(pushlex(&quot;)&quot;), commasep(argdef, &quot;)&quot;), poplex, fndef);
    if (type == &quot;-&gt;&quot;) return cont(typecx, rtype, valcx, fndef);
    if (type == &quot;;&quot;) return cont();
    return cont(fndef);
  }
  function tydef(type) {
    if (type == &quot;name&quot;) {cx.marked = &quot;def&quot;; return cont(tydef);}
    if (content == &quot;&lt;&quot;) return cont(typarams, tydef);
    if (content == &quot;=&quot;) return cont(typecx, rtype, valcx);
    return cont(tydef);
  }
  function enumdef(type) {
    if (type == &quot;name&quot;) {cx.marked = &quot;def&quot;; return cont(enumdef);}
    if (content == &quot;&lt;&quot;) return cont(typarams, enumdef);
    if (content == &quot;=&quot;) return cont(typecx, rtype, valcx, endstatement);
    if (type == &quot;{&quot;) return cont(pushlex(&quot;}&quot;), typecx, enumblock, valcx, poplex);
    return cont(enumdef);
  }
  function enumblock(type) {
    if (type == &quot;}&quot;) return cont();
    if (type == &quot;(&quot;) return cont(pushlex(&quot;)&quot;), commasep(rtype, &quot;)&quot;), poplex, enumblock);
    if (content.match(/^\w+$/)) cx.marked = &quot;def&quot;;
    return cont(enumblock);
  }
  function mod(type) {
    if (type == &quot;name&quot;) {cx.marked = &quot;def&quot;; return cont(mod);}
    if (type == &quot;{&quot;) return cont(pushlex(&quot;}&quot;), block, poplex);
    return pass();
  }
  function iface(type) {
    if (type == &quot;name&quot;) {cx.marked = &quot;def&quot;; return cont(iface);}
    if (content == &quot;&lt;&quot;) return cont(typarams, iface);
    if (type == &quot;{&quot;) return cont(pushlex(&quot;}&quot;), block, poplex);
    return pass();
  }
  function impl(type) {
    if (content == &quot;&lt;&quot;) return cont(typarams, impl);
    if (content == &quot;of&quot; || content == &quot;for&quot;) {cx.marked = &quot;keyword&quot;; return cont(rtype, impl);}
    if (type == &quot;name&quot;) {cx.marked = &quot;def&quot;; return cont(impl);}
    if (type == &quot;{&quot;) return cont(pushlex(&quot;}&quot;), block, poplex);
    return pass();
  }
  function typarams() {
    if (content == &quot;&gt;&quot;) return cont();
    if (content == &quot;,&quot;) return cont(typarams);
    if (content == &quot;:&quot;) return cont(rtype, typarams);
    return pass(rtype, typarams);
  }
  function argdef(type) {
    if (type == &quot;name&quot;) {cx.marked = &quot;def&quot;; return cont(argdef);}
    if (type == &quot;:&quot;) return cont(typecx, rtype, valcx);
    return pass();
  }
  function rtype(type) {
    if (type == &quot;name&quot;) {cx.marked = &quot;variable-3&quot;; return cont(rtypemaybeparam); }
    if (content == &quot;mutable&quot;) {cx.marked = &quot;keyword&quot;; return cont(rtype);}
    if (type == &quot;atom&quot;) return cont(rtypemaybeparam);
    if (type == &quot;op&quot; || type == &quot;obj&quot;) return cont(rtype);
    if (type == &quot;fn&quot;) return cont(fntype);
    if (type == &quot;{&quot;) return cont(pushlex(&quot;{&quot;), record_of(rtype), poplex);
    return matchBrackets(type, rtype);
  }
  function rtypemaybeparam() {
    if (content == &quot;&lt;&quot;) return cont(typarams);
    return pass();
  }
  function fntype(type) {
    if (type == &quot;(&quot;) return cont(pushlex(&quot;(&quot;), commasep(rtype, &quot;)&quot;), poplex, fntype);
    if (type == &quot;-&gt;&quot;) return cont(rtype);
    return pass();
  }
  function pattern(type) {
    if (type == &quot;name&quot;) {cx.marked = &quot;def&quot;; return cont(patternmaybeop);}
    if (type == &quot;atom&quot;) return cont(patternmaybeop);
    if (type == &quot;op&quot;) return cont(pattern);
    if (type.match(/[\]\)\};,]/)) return pass();
    return matchBrackets(type, pattern);
  }
  function patternmaybeop(type) {
    if (type == &quot;op&quot; &amp;&amp; content == &quot;.&quot;) return cont();
    if (content == &quot;to&quot;) {cx.marked = &quot;keyword&quot;; return cont(pattern);}
    else return pass();
  }
  function altbody(type) {
    if (type == &quot;{&quot;) return cont(pushlex(&quot;}&quot;, &quot;alt&quot;), altblock1, poplex);
    return pass();
  }
  function altblock1(type) {
    if (type == &quot;}&quot;) return cont();
    if (type == &quot;|&quot;) return cont(altblock1);
    if (content == &quot;when&quot;) {cx.marked = &quot;keyword&quot;; return cont(expression, altblock2);}
    if (type.match(/[\]\);,]/)) return cont(altblock1);
    return pass(pattern, altblock2);
  }
  function altblock2(type) {
    if (type == &quot;{&quot;) return cont(pushlex(&quot;}&quot;, &quot;alt&quot;), block, poplex, altblock1);
    else return pass(altblock1);
  }

  function macro(type) {
    if (type.match(/[\[\(\{]/)) return matchBrackets(type, expression);
    return pass();
  }
  function matchBrackets(type, comb) {
    if (type == &quot;[&quot;) return cont(pushlex(&quot;]&quot;), commasep(comb, &quot;]&quot;), poplex);
    if (type == &quot;(&quot;) return cont(pushlex(&quot;)&quot;), commasep(comb, &quot;)&quot;), poplex);
    if (type == &quot;{&quot;) return cont(pushlex(&quot;}&quot;), commasep(comb, &quot;}&quot;), poplex);
    return cont();
  }

  function parse(state, stream, style) {
    var cc = state.cc;
    // Communicate our context to the combinators.
    // (Less wasteful than consing up a hundred closures on every call.)
    cx.state = state; cx.stream = stream; cx.marked = null, cx.cc = cc;

    while (true) {
      var combinator = cc.length ? cc.pop() : block;
      if (combinator(tcat)) {
        while(cc.length &amp;&amp; cc[cc.length - 1].lex)
          cc.pop()();
        return cx.marked || style;
      }
    }
  }

  return {
    startState: function() {
      return {
        tokenize: tokenBase,
        cc: [],
        lexical: {indented: -indentUnit, column: 0, type: &quot;top&quot;, align: false},
        keywords: valKeywords,
        indented: 0
      };
    },

    token: function(stream, state) {
      if (stream.sol()) {
        if (!state.lexical.hasOwnProperty(&quot;align&quot;))
          state.lexical.align = false;
        state.indented = stream.indentation();
      }
      if (stream.eatSpace()) return null;
      tcat = content = null;
      var style = state.tokenize(stream, state);
      if (style == &quot;comment&quot;) return style;
      if (!state.lexical.hasOwnProperty(&quot;align&quot;))
        state.lexical.align = true;
      if (tcat == &quot;prefix&quot;) return style;
      if (!content) content = stream.current();
      return parse(state, stream, style);
    },

    indent: function(state, textAfter) {
      if (state.tokenize != tokenBase) return 0;
      var firstChar = textAfter &amp;&amp; textAfter.charAt(0), lexical = state.lexical,
          type = lexical.type, closing = firstChar == type;
      if (type == &quot;stat&quot;) return lexical.indented + indentUnit;
      if (lexical.align) return lexical.column + (closing ? 0 : 1);
      return lexical.indented + (closing ? 0 : (lexical.info == &quot;alt&quot; ? altIndentUnit : indentUnit));
    },

    electricChars: &quot;{}&quot;,
    blockCommentStart: &quot;/*&quot;,
    blockCommentEnd: &quot;*/&quot;,
    lineComment: &quot;//&quot;,
    fold: &quot;brace&quot;
  };
});

CodeMirror.defineMIME(&quot;text/x-rustsrc&quot;, &quot;rust&quot;);

});
</code></pre>

</div>

<footer class="footer">
  Generated by <a href="https://esdoc.org">ESDoc<span data-ice="esdocVersion">(1.1.0)</span><img src="./image/esdoc-logo-mini-black.png"></a>
</footer>

<script src="script/search_index.js"></script>
<script src="script/search.js"></script>
<script src="script/pretty-print.js"></script>
<script src="script/inherited-summary.js"></script>
<script src="script/test-summary.js"></script>
<script src="script/inner-link.js"></script>
<script src="script/patch-for-local.js"></script>
</body>
</html>
