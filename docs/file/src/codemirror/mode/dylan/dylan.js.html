<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <base data-ice="baseUrl" href="../../../../../">
  <title data-ice="title">src/codemirror/mode/dylan/dylan.js | webrtcdevelopment</title>
  <link type="text/css" rel="stylesheet" href="css/style.css">
  <link type="text/css" rel="stylesheet" href="css/prettify-tomorrow.css">
  <script src="script/prettify/prettify.js"></script>
  <script src="script/manual.js"></script>
<meta name="description" content="webrtc based communication and collaboration client. Contains lot of experiments modules "><meta property="twitter:card" content="summary"><meta property="twitter:title" content="webrtcdevelopment"><meta property="twitter:description" content="webrtc based communication and collaboration client. Contains lot of experiments modules "></head>
<body class="layout-container" data-ice="rootContainer">

<header>
  <a href="./">Home</a>
  
  <a href="identifiers.html">Reference</a>
  <a href="source.html">Source</a>
  
  <div class="search-box">
  <span>
    <img src="./image/search.png">
    <span class="search-input-edge"></span><input class="search-input"><span class="search-input-edge"></span>
  </span>
    <ul class="search-result"></ul>
  </div>
<a style="position:relative; top:3px;" href="https://github.com/altanai/webrtc"><img width="20px" src="./image/github.png"></a></header>

<nav class="navigation" data-ice="nav"><div>
  <ul>
    
  <li data-ice="doc"><a data-ice="dirPath" class="nav-dir-path" href="identifiers.html#scripts">scripts</a><span data-ice="kind" class="kind-typedef">T</span><span data-ice="name"><span><a href="typedef/index.html#static-typedef-CanvasRecorder">CanvasRecorder</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-typedef">T</span><span data-ice="name"><span><a href="typedef/index.html#static-typedef-GetRecorderType">GetRecorderType</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-typedef">T</span><span data-ice="name"><span><a href="typedef/index.html#static-typedef-GifRecorder">GifRecorder</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-typedef">T</span><span data-ice="name"><span><a href="typedef/index.html#static-typedef-MRecordRTC">MRecordRTC</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-typedef">T</span><span data-ice="name"><span><a href="typedef/index.html#static-typedef-MediaStreamRecorder">MediaStreamRecorder</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-typedef">T</span><span data-ice="name"><span><a href="typedef/index.html#static-typedef-RecordRTC">RecordRTC</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-typedef">T</span><span data-ice="name"><span><a href="typedef/index.html#static-typedef-RecordRTCConfiguration">RecordRTCConfiguration</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-typedef">T</span><span data-ice="name"><span><a href="typedef/index.html#static-typedef-StereoAudioRecorder">StereoAudioRecorder</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-typedef">T</span><span data-ice="name"><span><a href="typedef/index.html#static-typedef-Whammy">Whammy</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-typedef">T</span><span data-ice="name"><span><a href="typedef/index.html#static-typedef-WhammyRecorder">WhammyRecorder</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-typedef">T</span><span data-ice="name"><span><a href="typedef/index.html#static-typedef-createFileSharingDiv">createFileSharingDiv</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-typedef">T</span><span data-ice="name"><span><a href="typedef/index.html#static-typedef-_turn.js">_turn.js</a></span></span></li>
<li data-ice="doc"><a data-ice="dirPath" class="nav-dir-path" href="identifiers.html#scripts-rtcconn">scripts/rtcconn</a><span data-ice="kind" class="kind-typedef">T</span><span data-ice="name"><span><a href="typedef/index.html#static-typedef-Whammy">Whammy</a></span></span></li>
</ul>
</div>
</nav>

<div class="content" data-ice="content"><h1 data-ice="title">src/codemirror/mode/dylan/dylan.js</h1>
<pre class="source-code line-number raw-source-code"><code class="prettyprint linenums" data-ice="content">// CodeMirror, copyright (c) by Marijn Haverbeke and others
// Distributed under an MIT license: http://codemirror.net/LICENSE

(function(mod) {
  if (typeof exports == &quot;object&quot; &amp;&amp; typeof module == &quot;object&quot;) // CommonJS
    mod(require(&quot;../../lib/codemirror&quot;));
  else if (typeof define == &quot;function&quot; &amp;&amp; define.amd) // AMD
    define([&quot;../../lib/codemirror&quot;], mod);
  else // Plain browser env
    mod(CodeMirror);
})(function(CodeMirror) {
&quot;use strict&quot;;

CodeMirror.defineMode(&quot;dylan&quot;, function(_config) {
  // Words
  var words = {
    // Words that introduce unnamed definitions like &quot;define interface&quot;
    unnamedDefinition: [&quot;interface&quot;],

    // Words that introduce simple named definitions like &quot;define library&quot;
    namedDefinition: [&quot;module&quot;, &quot;library&quot;, &quot;macro&quot;,
                      &quot;C-struct&quot;, &quot;C-union&quot;,
                      &quot;C-function&quot;, &quot;C-callable-wrapper&quot;
                     ],

    // Words that introduce type definitions like &quot;define class&quot;.
    // These are also parameterized like &quot;define method&quot; and are
    // appended to otherParameterizedDefinitionWords
    typeParameterizedDefinition: [&quot;class&quot;, &quot;C-subtype&quot;, &quot;C-mapped-subtype&quot;],

    // Words that introduce trickier definitions like &quot;define method&quot;.
    // These require special definitions to be added to startExpressions
    otherParameterizedDefinition: [&quot;method&quot;, &quot;function&quot;,
                                   &quot;C-variable&quot;, &quot;C-address&quot;
                                  ],

    // Words that introduce module constant definitions.
    // These must also be simple definitions and are
    // appended to otherSimpleDefinitionWords
    constantSimpleDefinition: [&quot;constant&quot;],

    // Words that introduce module variable definitions.
    // These must also be simple definitions and are
    // appended to otherSimpleDefinitionWords
    variableSimpleDefinition: [&quot;variable&quot;],

    // Other words that introduce simple definitions
    // (without implicit bodies).
    otherSimpleDefinition: [&quot;generic&quot;, &quot;domain&quot;,
                            &quot;C-pointer-type&quot;,
                            &quot;table&quot;
                           ],

    // Words that begin statements with implicit bodies.
    statement: [&quot;if&quot;, &quot;block&quot;, &quot;begin&quot;, &quot;method&quot;, &quot;case&quot;,
                &quot;for&quot;, &quot;select&quot;, &quot;when&quot;, &quot;unless&quot;, &quot;until&quot;,
                &quot;while&quot;, &quot;iterate&quot;, &quot;profiling&quot;, &quot;dynamic-bind&quot;
               ],

    // Patterns that act as separators in compound statements.
    // This may include any general pattern that must be indented
    // specially.
    separator: [&quot;finally&quot;, &quot;exception&quot;, &quot;cleanup&quot;, &quot;else&quot;,
                &quot;elseif&quot;, &quot;afterwards&quot;
               ],

    // Keywords that do not require special indentation handling,
    // but which should be highlighted
    other: [&quot;above&quot;, &quot;below&quot;, &quot;by&quot;, &quot;from&quot;, &quot;handler&quot;, &quot;in&quot;,
            &quot;instance&quot;, &quot;let&quot;, &quot;local&quot;, &quot;otherwise&quot;, &quot;slot&quot;,
            &quot;subclass&quot;, &quot;then&quot;, &quot;to&quot;, &quot;keyed-by&quot;, &quot;virtual&quot;
           ],

    // Condition signaling function calls
    signalingCalls: [&quot;signal&quot;, &quot;error&quot;, &quot;cerror&quot;,
                     &quot;break&quot;, &quot;check-type&quot;, &quot;abort&quot;
                    ]
  };

  words[&quot;otherDefinition&quot;] =
    words[&quot;unnamedDefinition&quot;]
    .concat(words[&quot;namedDefinition&quot;])
    .concat(words[&quot;otherParameterizedDefinition&quot;]);

  words[&quot;definition&quot;] =
    words[&quot;typeParameterizedDefinition&quot;]
    .concat(words[&quot;otherDefinition&quot;]);

  words[&quot;parameterizedDefinition&quot;] =
    words[&quot;typeParameterizedDefinition&quot;]
    .concat(words[&quot;otherParameterizedDefinition&quot;]);

  words[&quot;simpleDefinition&quot;] =
    words[&quot;constantSimpleDefinition&quot;]
    .concat(words[&quot;variableSimpleDefinition&quot;])
    .concat(words[&quot;otherSimpleDefinition&quot;]);

  words[&quot;keyword&quot;] =
    words[&quot;statement&quot;]
    .concat(words[&quot;separator&quot;])
    .concat(words[&quot;other&quot;]);

  // Patterns
  var symbolPattern = &quot;[-_a-zA-Z?!*@&lt;&gt;$%]+&quot;;
  var symbol = new RegExp(&quot;^&quot; + symbolPattern);
  var patterns = {
    // Symbols with special syntax
    symbolKeyword: symbolPattern + &quot;:&quot;,
    symbolClass: &quot;&lt;&quot; + symbolPattern + &quot;&gt;&quot;,
    symbolGlobal: &quot;\\*&quot; + symbolPattern + &quot;\\*&quot;,
    symbolConstant: &quot;\\$&quot; + symbolPattern
  };
  var patternStyles = {
    symbolKeyword: &quot;atom&quot;,
    symbolClass: &quot;tag&quot;,
    symbolGlobal: &quot;variable-2&quot;,
    symbolConstant: &quot;variable-3&quot;
  };

  // Compile all patterns to regular expressions
  for (var patternName in patterns)
    if (patterns.hasOwnProperty(patternName))
      patterns[patternName] = new RegExp(&quot;^&quot; + patterns[patternName]);

  // Names beginning &quot;with-&quot; and &quot;without-&quot; are commonly
  // used as statement macro
  patterns[&quot;keyword&quot;] = [/^with(?:out)?-[-_a-zA-Z?!*@&lt;&gt;$%]+/];

  var styles = {};
  styles[&quot;keyword&quot;] = &quot;keyword&quot;;
  styles[&quot;definition&quot;] = &quot;def&quot;;
  styles[&quot;simpleDefinition&quot;] = &quot;def&quot;;
  styles[&quot;signalingCalls&quot;] = &quot;builtin&quot;;

  // protected words lookup table
  var wordLookup = {};
  var styleLookup = {};

  [
    &quot;keyword&quot;,
    &quot;definition&quot;,
    &quot;simpleDefinition&quot;,
    &quot;signalingCalls&quot;
  ].forEach(function(type) {
    words[type].forEach(function(word) {
      wordLookup[word] = type;
      styleLookup[word] = styles[type];
    });
  });


  function chain(stream, state, f) {
    state.tokenize = f;
    return f(stream, state);
  }

  var type, content;

  function ret(_type, style, _content) {
    type = _type;
    content = _content;
    return style;
  }

  function tokenBase(stream, state) {
    // String
    var ch = stream.peek();
    if (ch == &quot;&apos;&quot; || ch == &apos;&quot;&apos;) {
      stream.next();
      return chain(stream, state, tokenString(ch, &quot;string&quot;, &quot;string&quot;));
    }
    // Comment
    else if (ch == &quot;/&quot;) {
      stream.next();
      if (stream.eat(&quot;*&quot;)) {
        return chain(stream, state, tokenComment);
      } else if (stream.eat(&quot;/&quot;)) {
        stream.skipToEnd();
        return ret(&quot;comment&quot;, &quot;comment&quot;);
      } else {
        stream.skipTo(&quot; &quot;);
        return ret(&quot;operator&quot;, &quot;operator&quot;);
      }
    }
    // Decimal
    else if (/\d/.test(ch)) {
      stream.match(/^\d*(?:\.\d*)?(?:e[+\-]?\d+)?/);
      return ret(&quot;number&quot;, &quot;number&quot;);
    }
    // Hash
    else if (ch == &quot;#&quot;) {
      stream.next();
      // Symbol with string syntax
      ch = stream.peek();
      if (ch == &apos;&quot;&apos;) {
        stream.next();
        return chain(stream, state, tokenString(&apos;&quot;&apos;, &quot;symbol&quot;, &quot;string-2&quot;));
      }
      // Binary number
      else if (ch == &quot;b&quot;) {
        stream.next();
        stream.eatWhile(/[01]/);
        return ret(&quot;number&quot;, &quot;number&quot;);
      }
      // Hex number
      else if (ch == &quot;x&quot;) {
        stream.next();
        stream.eatWhile(/[\da-f]/i);
        return ret(&quot;number&quot;, &quot;number&quot;);
      }
      // Octal number
      else if (ch == &quot;o&quot;) {
        stream.next();
        stream.eatWhile(/[0-7]/);
        return ret(&quot;number&quot;, &quot;number&quot;);
      }
      // Hash symbol
      else {
        stream.eatWhile(/[-a-zA-Z]/);
        return ret(&quot;hash&quot;, &quot;keyword&quot;);
      }
    } else if (stream.match(&quot;end&quot;)) {
      return ret(&quot;end&quot;, &quot;keyword&quot;);
    }
    for (var name in patterns) {
      if (patterns.hasOwnProperty(name)) {
        var pattern = patterns[name];
        if ((pattern instanceof Array &amp;&amp; pattern.some(function(p) {
          return stream.match(p);
        })) || stream.match(pattern))
          return ret(name, patternStyles[name], stream.current());
      }
    }
    if (stream.match(&quot;define&quot;)) {
      return ret(&quot;definition&quot;, &quot;def&quot;);
    } else {
      stream.eatWhile(/[\w\-]/);
      // Keyword
      if (wordLookup[stream.current()]) {
        return ret(wordLookup[stream.current()], styleLookup[stream.current()], stream.current());
      } else if (stream.current().match(symbol)) {
        return ret(&quot;variable&quot;, &quot;variable&quot;);
      } else {
        stream.next();
        return ret(&quot;other&quot;, &quot;variable-2&quot;);
      }
    }
  }

  function tokenComment(stream, state) {
    var maybeEnd = false,
    ch;
    while ((ch = stream.next())) {
      if (ch == &quot;/&quot; &amp;&amp; maybeEnd) {
        state.tokenize = tokenBase;
        break;
      }
      maybeEnd = (ch == &quot;*&quot;);
    }
    return ret(&quot;comment&quot;, &quot;comment&quot;);
  }

  function tokenString(quote, type, style) {
    return function(stream, state) {
      var next, end = false;
      while ((next = stream.next()) != null) {
        if (next == quote) {
          end = true;
          break;
        }
      }
      if (end)
        state.tokenize = tokenBase;
      return ret(type, style);
    };
  }

  // Interface
  return {
    startState: function() {
      return {
        tokenize: tokenBase,
        currentIndent: 0
      };
    },
    token: function(stream, state) {
      if (stream.eatSpace())
        return null;
      var style = state.tokenize(stream, state);
      return style;
    },
    blockCommentStart: &quot;/*&quot;,
    blockCommentEnd: &quot;*/&quot;
  };
});

CodeMirror.defineMIME(&quot;text/x-dylan&quot;, &quot;dylan&quot;);

});
</code></pre>

</div>

<footer class="footer">
  Generated by <a href="https://esdoc.org">ESDoc<span data-ice="esdocVersion">(1.1.0)</span><img src="./image/esdoc-logo-mini-black.png"></a>
</footer>

<script src="script/search_index.js"></script>
<script src="script/search.js"></script>
<script src="script/pretty-print.js"></script>
<script src="script/inherited-summary.js"></script>
<script src="script/test-summary.js"></script>
<script src="script/inner-link.js"></script>
<script src="script/patch-for-local.js"></script>
</body>
</html>
