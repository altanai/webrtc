<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <base data-ice="baseUrl" href="../../../../">
  <title data-ice="title">src/codemirror/keymap/vim.js | webrtcdevelopment</title>
  <link type="text/css" rel="stylesheet" href="css/style.css">
  <link type="text/css" rel="stylesheet" href="css/prettify-tomorrow.css">
  <script src="script/prettify/prettify.js"></script>
  <script src="script/manual.js"></script>
<meta name="description" content="webrtc based communication and collaboration client. Contains lot of experiments modules "><meta property="twitter:card" content="summary"><meta property="twitter:title" content="webrtcdevelopment"><meta property="twitter:description" content="webrtc based communication and collaboration client. Contains lot of experiments modules "></head>
<body class="layout-container" data-ice="rootContainer">

<header>
  <a href="./">Home</a>
  
  <a href="identifiers.html">Reference</a>
  <a href="source.html">Source</a>
  
  <div class="search-box">
  <span>
    <img src="./image/search.png">
    <span class="search-input-edge"></span><input class="search-input"><span class="search-input-edge"></span>
  </span>
    <ul class="search-result"></ul>
  </div>
<a style="position:relative; top:3px;" href="https://github.com/altanai/webrtc"><img width="20px" src="./image/github.png"></a></header>

<nav class="navigation" data-ice="nav"><div>
  <ul>
    
  <li data-ice="doc"><a data-ice="dirPath" class="nav-dir-path" href="identifiers.html#scripts">scripts</a><span data-ice="kind" class="kind-typedef">T</span><span data-ice="name"><span><a href="typedef/index.html#static-typedef-CanvasRecorder">CanvasRecorder</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-typedef">T</span><span data-ice="name"><span><a href="typedef/index.html#static-typedef-GetRecorderType">GetRecorderType</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-typedef">T</span><span data-ice="name"><span><a href="typedef/index.html#static-typedef-GifRecorder">GifRecorder</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-typedef">T</span><span data-ice="name"><span><a href="typedef/index.html#static-typedef-MRecordRTC">MRecordRTC</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-typedef">T</span><span data-ice="name"><span><a href="typedef/index.html#static-typedef-MediaStreamRecorder">MediaStreamRecorder</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-typedef">T</span><span data-ice="name"><span><a href="typedef/index.html#static-typedef-RecordRTC">RecordRTC</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-typedef">T</span><span data-ice="name"><span><a href="typedef/index.html#static-typedef-RecordRTCConfiguration">RecordRTCConfiguration</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-typedef">T</span><span data-ice="name"><span><a href="typedef/index.html#static-typedef-StereoAudioRecorder">StereoAudioRecorder</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-typedef">T</span><span data-ice="name"><span><a href="typedef/index.html#static-typedef-Whammy">Whammy</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-typedef">T</span><span data-ice="name"><span><a href="typedef/index.html#static-typedef-WhammyRecorder">WhammyRecorder</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-typedef">T</span><span data-ice="name"><span><a href="typedef/index.html#static-typedef-createFileSharingDiv">createFileSharingDiv</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-typedef">T</span><span data-ice="name"><span><a href="typedef/index.html#static-typedef-_turn.js">_turn.js</a></span></span></li>
<li data-ice="doc"><a data-ice="dirPath" class="nav-dir-path" href="identifiers.html#scripts-rtcconn">scripts/rtcconn</a><span data-ice="kind" class="kind-typedef">T</span><span data-ice="name"><span><a href="typedef/index.html#static-typedef-Whammy">Whammy</a></span></span></li>
</ul>
</div>
</nav>

<div class="content" data-ice="content"><h1 data-ice="title">src/codemirror/keymap/vim.js</h1>
<pre class="source-code line-number raw-source-code"><code class="prettyprint linenums" data-ice="content">// CodeMirror, copyright (c) by Marijn Haverbeke and others
// Distributed under an MIT license: http://codemirror.net/LICENSE

/**
 * Supported keybindings:
 *
 *   Motion:
 *   h, j, k, l
 *   gj, gk
 *   e, E, w, W, b, B, ge, gE
 *   f&lt;character&gt;, F&lt;character&gt;, t&lt;character&gt;, T&lt;character&gt;
 *   $, ^, 0, -, +, _
 *   gg, G
 *   %
 *   &apos;&lt;character&gt;, `&lt;character&gt;
 *
 *   Operator:
 *   d, y, c
 *   dd, yy, cc
 *   g~, g~g~
 *   &gt;, &lt;, &gt;&gt;, &lt;&lt;
 *
 *   Operator-Motion:
 *   x, X, D, Y, C, ~
 *
 *   Action:
 *   a, i, s, A, I, S, o, O
 *   zz, z., z&lt;CR&gt;, zt, zb, z-
 *   J
 *   u, Ctrl-r
 *   m&lt;character&gt;
 *   r&lt;character&gt;
 *
 *   Modes:
 *   ESC - leave insert mode, visual mode, and clear input state.
 *   Ctrl-[, Ctrl-c - same as ESC.
 *
 * Registers: unnamed, -, a-z, A-Z, 0-9
 *   (Does not respect the special case for number registers when delete
 *    operator is made with these commands: %, (, ),  , /, ?, n, N, {, } )
 *   TODO: Implement the remaining registers.
 * Marks: a-z, A-Z, and 0-9
 *   TODO: Implement the remaining special marks. They have more complex
 *       behavior.
 *
 * Events:
 *  &apos;vim-mode-change&apos; - raised on the editor anytime the current mode changes,
 *                      Event object: {mode: &quot;visual&quot;, subMode: &quot;linewise&quot;}
 *
 * Code structure:
 *  1. Default keymap
 *  2. Variable declarations and short basic helpers
 *  3. Instance (External API) implementation
 *  4. Internal state tracking objects (input state, counter) implementation
 *     and instanstiation
 *  5. Key handler (the main command dispatcher) implementation
 *  6. Motion, operator, and action implementations
 *  7. Helper functions for the key handler, motions, operators, and actions
 *  8. Set up Vim to work as a keymap for CodeMirror.
 */

(function(mod) {
  if (typeof exports == &quot;object&quot; &amp;&amp; typeof module == &quot;object&quot;) // CommonJS
    mod(require(&quot;../lib/codemirror&quot;), require(&quot;../addon/search/searchcursor&quot;), require(&quot;../addon/dialog/dialog&quot;), require(&quot;../addon/edit/matchbrackets.js&quot;));
  else if (typeof define == &quot;function&quot; &amp;&amp; define.amd) // AMD
    define([&quot;../lib/codemirror&quot;, &quot;../addon/search/searchcursor&quot;, &quot;../addon/dialog/dialog&quot;, &quot;../addon/edit/matchbrackets&quot;], mod);
  else // Plain browser env
    mod(CodeMirror);
})(function(CodeMirror) {
  &apos;use strict&apos;;

  var defaultKeymap = [
    // Key to key mapping. This goes first to make it possible to override
    // existing mappings.
    { keys: &apos;&lt;Left&gt;&apos;, type: &apos;keyToKey&apos;, toKeys: &apos;h&apos; },
    { keys: &apos;&lt;Right&gt;&apos;, type: &apos;keyToKey&apos;, toKeys: &apos;l&apos; },
    { keys: &apos;&lt;Up&gt;&apos;, type: &apos;keyToKey&apos;, toKeys: &apos;k&apos; },
    { keys: &apos;&lt;Down&gt;&apos;, type: &apos;keyToKey&apos;, toKeys: &apos;j&apos; },
    { keys: &apos;&lt;Space&gt;&apos;, type: &apos;keyToKey&apos;, toKeys: &apos;l&apos; },
    { keys: &apos;&lt;BS&gt;&apos;, type: &apos;keyToKey&apos;, toKeys: &apos;h&apos; },
    { keys: &apos;&lt;C-Space&gt;&apos;, type: &apos;keyToKey&apos;, toKeys: &apos;W&apos; },
    { keys: &apos;&lt;C-BS&gt;&apos;, type: &apos;keyToKey&apos;, toKeys: &apos;B&apos; },
    { keys: &apos;&lt;S-Space&gt;&apos;, type: &apos;keyToKey&apos;, toKeys: &apos;w&apos; },
    { keys: &apos;&lt;S-BS&gt;&apos;, type: &apos;keyToKey&apos;, toKeys: &apos;b&apos; },
    { keys: &apos;&lt;C-n&gt;&apos;, type: &apos;keyToKey&apos;, toKeys: &apos;j&apos; },
    { keys: &apos;&lt;C-p&gt;&apos;, type: &apos;keyToKey&apos;, toKeys: &apos;k&apos; },
    { keys: &apos;&lt;C-[&gt;&apos;, type: &apos;keyToKey&apos;, toKeys: &apos;&lt;Esc&gt;&apos; },
    { keys: &apos;&lt;C-c&gt;&apos;, type: &apos;keyToKey&apos;, toKeys: &apos;&lt;Esc&gt;&apos; },
    { keys: &apos;&lt;C-[&gt;&apos;, type: &apos;keyToKey&apos;, toKeys: &apos;&lt;Esc&gt;&apos;, context: &apos;insert&apos; },
    { keys: &apos;&lt;C-c&gt;&apos;, type: &apos;keyToKey&apos;, toKeys: &apos;&lt;Esc&gt;&apos;, context: &apos;insert&apos; },
    { keys: &apos;s&apos;, type: &apos;keyToKey&apos;, toKeys: &apos;cl&apos;, context: &apos;normal&apos; },
    { keys: &apos;s&apos;, type: &apos;keyToKey&apos;, toKeys: &apos;xi&apos;, context: &apos;visual&apos;},
    { keys: &apos;S&apos;, type: &apos;keyToKey&apos;, toKeys: &apos;cc&apos;, context: &apos;normal&apos; },
    { keys: &apos;S&apos;, type: &apos;keyToKey&apos;, toKeys: &apos;dcc&apos;, context: &apos;visual&apos; },
    { keys: &apos;&lt;Home&gt;&apos;, type: &apos;keyToKey&apos;, toKeys: &apos;0&apos; },
    { keys: &apos;&lt;End&gt;&apos;, type: &apos;keyToKey&apos;, toKeys: &apos;$&apos; },
    { keys: &apos;&lt;PageUp&gt;&apos;, type: &apos;keyToKey&apos;, toKeys: &apos;&lt;C-b&gt;&apos; },
    { keys: &apos;&lt;PageDown&gt;&apos;, type: &apos;keyToKey&apos;, toKeys: &apos;&lt;C-f&gt;&apos; },
    { keys: &apos;&lt;CR&gt;&apos;, type: &apos;keyToKey&apos;, toKeys: &apos;j^&apos;, context: &apos;normal&apos; },
    // Motions
    { keys: &apos;H&apos;, type: &apos;motion&apos;, motion: &apos;moveToTopLine&apos;, motionArgs: { linewise: true, toJumplist: true }},
    { keys: &apos;M&apos;, type: &apos;motion&apos;, motion: &apos;moveToMiddleLine&apos;, motionArgs: { linewise: true, toJumplist: true }},
    { keys: &apos;L&apos;, type: &apos;motion&apos;, motion: &apos;moveToBottomLine&apos;, motionArgs: { linewise: true, toJumplist: true }},
    { keys: &apos;h&apos;, type: &apos;motion&apos;, motion: &apos;moveByCharacters&apos;, motionArgs: { forward: false }},
    { keys: &apos;l&apos;, type: &apos;motion&apos;, motion: &apos;moveByCharacters&apos;, motionArgs: { forward: true }},
    { keys: &apos;j&apos;, type: &apos;motion&apos;, motion: &apos;moveByLines&apos;, motionArgs: { forward: true, linewise: true }},
    { keys: &apos;k&apos;, type: &apos;motion&apos;, motion: &apos;moveByLines&apos;, motionArgs: { forward: false, linewise: true }},
    { keys: &apos;gj&apos;, type: &apos;motion&apos;, motion: &apos;moveByDisplayLines&apos;, motionArgs: { forward: true }},
    { keys: &apos;gk&apos;, type: &apos;motion&apos;, motion: &apos;moveByDisplayLines&apos;, motionArgs: { forward: false }},
    { keys: &apos;w&apos;, type: &apos;motion&apos;, motion: &apos;moveByWords&apos;, motionArgs: { forward: true, wordEnd: false }},
    { keys: &apos;W&apos;, type: &apos;motion&apos;, motion: &apos;moveByWords&apos;, motionArgs: { forward: true, wordEnd: false, bigWord: true }},
    { keys: &apos;e&apos;, type: &apos;motion&apos;, motion: &apos;moveByWords&apos;, motionArgs: { forward: true, wordEnd: true, inclusive: true }},
    { keys: &apos;E&apos;, type: &apos;motion&apos;, motion: &apos;moveByWords&apos;, motionArgs: { forward: true, wordEnd: true, bigWord: true, inclusive: true }},
    { keys: &apos;b&apos;, type: &apos;motion&apos;, motion: &apos;moveByWords&apos;, motionArgs: { forward: false, wordEnd: false }},
    { keys: &apos;B&apos;, type: &apos;motion&apos;, motion: &apos;moveByWords&apos;, motionArgs: { forward: false, wordEnd: false, bigWord: true }},
    { keys: &apos;ge&apos;, type: &apos;motion&apos;, motion: &apos;moveByWords&apos;, motionArgs: { forward: false, wordEnd: true, inclusive: true }},
    { keys: &apos;gE&apos;, type: &apos;motion&apos;, motion: &apos;moveByWords&apos;, motionArgs: { forward: false, wordEnd: true, bigWord: true, inclusive: true }},
    { keys: &apos;{&apos;, type: &apos;motion&apos;, motion: &apos;moveByParagraph&apos;, motionArgs: { forward: false, toJumplist: true }},
    { keys: &apos;}&apos;, type: &apos;motion&apos;, motion: &apos;moveByParagraph&apos;, motionArgs: { forward: true, toJumplist: true }},
    { keys: &apos;&lt;C-f&gt;&apos;, type: &apos;motion&apos;, motion: &apos;moveByPage&apos;, motionArgs: { forward: true }},
    { keys: &apos;&lt;C-b&gt;&apos;, type: &apos;motion&apos;, motion: &apos;moveByPage&apos;, motionArgs: { forward: false }},
    { keys: &apos;&lt;C-d&gt;&apos;, type: &apos;motion&apos;, motion: &apos;moveByScroll&apos;, motionArgs: { forward: true, explicitRepeat: true }},
    { keys: &apos;&lt;C-u&gt;&apos;, type: &apos;motion&apos;, motion: &apos;moveByScroll&apos;, motionArgs: { forward: false, explicitRepeat: true }},
    { keys: &apos;gg&apos;, type: &apos;motion&apos;, motion: &apos;moveToLineOrEdgeOfDocument&apos;, motionArgs: { forward: false, explicitRepeat: true, linewise: true, toJumplist: true }},
    { keys: &apos;G&apos;, type: &apos;motion&apos;, motion: &apos;moveToLineOrEdgeOfDocument&apos;, motionArgs: { forward: true, explicitRepeat: true, linewise: true, toJumplist: true }},
    { keys: &apos;0&apos;, type: &apos;motion&apos;, motion: &apos;moveToStartOfLine&apos; },
    { keys: &apos;^&apos;, type: &apos;motion&apos;, motion: &apos;moveToFirstNonWhiteSpaceCharacter&apos; },
    { keys: &apos;+&apos;, type: &apos;motion&apos;, motion: &apos;moveByLines&apos;, motionArgs: { forward: true, toFirstChar:true }},
    { keys: &apos;-&apos;, type: &apos;motion&apos;, motion: &apos;moveByLines&apos;, motionArgs: { forward: false, toFirstChar:true }},
    { keys: &apos;_&apos;, type: &apos;motion&apos;, motion: &apos;moveByLines&apos;, motionArgs: { forward: true, toFirstChar:true, repeatOffset:-1 }},
    { keys: &apos;$&apos;, type: &apos;motion&apos;, motion: &apos;moveToEol&apos;, motionArgs: { inclusive: true }},
    { keys: &apos;%&apos;, type: &apos;motion&apos;, motion: &apos;moveToMatchedSymbol&apos;, motionArgs: { inclusive: true, toJumplist: true }},
    { keys: &apos;f&lt;character&gt;&apos;, type: &apos;motion&apos;, motion: &apos;moveToCharacter&apos;, motionArgs: { forward: true , inclusive: true }},
    { keys: &apos;F&lt;character&gt;&apos;, type: &apos;motion&apos;, motion: &apos;moveToCharacter&apos;, motionArgs: { forward: false }},
    { keys: &apos;t&lt;character&gt;&apos;, type: &apos;motion&apos;, motion: &apos;moveTillCharacter&apos;, motionArgs: { forward: true, inclusive: true }},
    { keys: &apos;T&lt;character&gt;&apos;, type: &apos;motion&apos;, motion: &apos;moveTillCharacter&apos;, motionArgs: { forward: false }},
    { keys: &apos;;&apos;, type: &apos;motion&apos;, motion: &apos;repeatLastCharacterSearch&apos;, motionArgs: { forward: true }},
    { keys: &apos;,&apos;, type: &apos;motion&apos;, motion: &apos;repeatLastCharacterSearch&apos;, motionArgs: { forward: false }},
    { keys: &apos;\&apos;&lt;character&gt;&apos;, type: &apos;motion&apos;, motion: &apos;goToMark&apos;, motionArgs: {toJumplist: true, linewise: true}},
    { keys: &apos;`&lt;character&gt;&apos;, type: &apos;motion&apos;, motion: &apos;goToMark&apos;, motionArgs: {toJumplist: true}},
    { keys: &apos;]`&apos;, type: &apos;motion&apos;, motion: &apos;jumpToMark&apos;, motionArgs: { forward: true } },
    { keys: &apos;[`&apos;, type: &apos;motion&apos;, motion: &apos;jumpToMark&apos;, motionArgs: { forward: false } },
    { keys: &apos;]\&apos;&apos;, type: &apos;motion&apos;, motion: &apos;jumpToMark&apos;, motionArgs: { forward: true, linewise: true } },
    { keys: &apos;[\&apos;&apos;, type: &apos;motion&apos;, motion: &apos;jumpToMark&apos;, motionArgs: { forward: false, linewise: true } },
    // the next two aren&apos;t motions but must come before more general motion declarations
    { keys: &apos;]p&apos;, type: &apos;action&apos;, action: &apos;paste&apos;, isEdit: true, actionArgs: { after: true, isEdit: true, matchIndent: true}},
    { keys: &apos;[p&apos;, type: &apos;action&apos;, action: &apos;paste&apos;, isEdit: true, actionArgs: { after: false, isEdit: true, matchIndent: true}},
    { keys: &apos;]&lt;character&gt;&apos;, type: &apos;motion&apos;, motion: &apos;moveToSymbol&apos;, motionArgs: { forward: true, toJumplist: true}},
    { keys: &apos;[&lt;character&gt;&apos;, type: &apos;motion&apos;, motion: &apos;moveToSymbol&apos;, motionArgs: { forward: false, toJumplist: true}},
    { keys: &apos;|&apos;, type: &apos;motion&apos;, motion: &apos;moveToColumn&apos;},
    { keys: &apos;o&apos;, type: &apos;motion&apos;, motion: &apos;moveToOtherHighlightedEnd&apos;, context:&apos;visual&apos;},
    { keys: &apos;O&apos;, type: &apos;motion&apos;, motion: &apos;moveToOtherHighlightedEnd&apos;, motionArgs: {sameLine: true}, context:&apos;visual&apos;},
    // Operators
    { keys: &apos;d&apos;, type: &apos;operator&apos;, operator: &apos;delete&apos; },
    { keys: &apos;y&apos;, type: &apos;operator&apos;, operator: &apos;yank&apos; },
    { keys: &apos;c&apos;, type: &apos;operator&apos;, operator: &apos;change&apos; },
    { keys: &apos;&gt;&apos;, type: &apos;operator&apos;, operator: &apos;indent&apos;, operatorArgs: { indentRight: true }},
    { keys: &apos;&lt;&apos;, type: &apos;operator&apos;, operator: &apos;indent&apos;, operatorArgs: { indentRight: false }},
    { keys: &apos;g~&apos;, type: &apos;operator&apos;, operator: &apos;swapcase&apos; },
    { keys: &apos;n&apos;, type: &apos;motion&apos;, motion: &apos;findNext&apos;, motionArgs: { forward: true, toJumplist: true }},
    { keys: &apos;N&apos;, type: &apos;motion&apos;, motion: &apos;findNext&apos;, motionArgs: { forward: false, toJumplist: true }},
    // Operator-Motion dual commands
    { keys: &apos;x&apos;, type: &apos;operatorMotion&apos;, operator: &apos;delete&apos;, motion: &apos;moveByCharacters&apos;, motionArgs: { forward: true }, operatorMotionArgs: { visualLine: false }},
    { keys: &apos;X&apos;, type: &apos;operatorMotion&apos;, operator: &apos;delete&apos;, motion: &apos;moveByCharacters&apos;, motionArgs: { forward: false }, operatorMotionArgs: { visualLine: true }},
    { keys: &apos;D&apos;, type: &apos;operatorMotion&apos;, operator: &apos;delete&apos;, motion: &apos;moveToEol&apos;, motionArgs: { inclusive: true }, operatorMotionArgs: { visualLine: true }},
    { keys: &apos;Y&apos;, type: &apos;operatorMotion&apos;, operator: &apos;yank&apos;, motion: &apos;moveToEol&apos;, motionArgs: { inclusive: true }, operatorMotionArgs: { visualLine: true }},
    { keys: &apos;C&apos;, type: &apos;operatorMotion&apos;, operator: &apos;change&apos;, motion: &apos;moveToEol&apos;, motionArgs: { inclusive: true }, operatorMotionArgs: { visualLine: true }},
    { keys: &apos;~&apos;, type: &apos;operatorMotion&apos;, operator: &apos;swapcase&apos;, operatorArgs: { shouldMoveCursor: true }, motion: &apos;moveByCharacters&apos;, motionArgs: { forward: true }},
    { keys: &apos;&lt;C-w&gt;&apos;, type: &apos;operatorMotion&apos;, operator: &apos;delete&apos;, motion: &apos;moveByWords&apos;, motionArgs: { forward: false, wordEnd: false }, context: &apos;insert&apos; },
    // Actions
    { keys: &apos;&lt;C-i&gt;&apos;, type: &apos;action&apos;, action: &apos;jumpListWalk&apos;, actionArgs: { forward: true }},
    { keys: &apos;&lt;C-o&gt;&apos;, type: &apos;action&apos;, action: &apos;jumpListWalk&apos;, actionArgs: { forward: false }},
    { keys: &apos;&lt;C-e&gt;&apos;, type: &apos;action&apos;, action: &apos;scroll&apos;, actionArgs: { forward: true, linewise: true }},
    { keys: &apos;&lt;C-y&gt;&apos;, type: &apos;action&apos;, action: &apos;scroll&apos;, actionArgs: { forward: false, linewise: true }},
    { keys: &apos;a&apos;, type: &apos;action&apos;, action: &apos;enterInsertMode&apos;, isEdit: true, actionArgs: { insertAt: &apos;charAfter&apos; }, context: &apos;normal&apos; },
    { keys: &apos;A&apos;, type: &apos;action&apos;, action: &apos;enterInsertMode&apos;, isEdit: true, actionArgs: { insertAt: &apos;eol&apos; }, context: &apos;normal&apos; },
    { keys: &apos;A&apos;, type: &apos;action&apos;, action: &apos;enterInsertMode&apos;, isEdit: true, actionArgs: { insertAt: &apos;endOfSelectedArea&apos; }, context: &apos;visual&apos; },
    { keys: &apos;i&apos;, type: &apos;action&apos;, action: &apos;enterInsertMode&apos;, isEdit: true, actionArgs: { insertAt: &apos;inplace&apos; }, context: &apos;normal&apos; },
    { keys: &apos;I&apos;, type: &apos;action&apos;, action: &apos;enterInsertMode&apos;, isEdit: true, actionArgs: { insertAt: &apos;firstNonBlank&apos; }},
    { keys: &apos;o&apos;, type: &apos;action&apos;, action: &apos;newLineAndEnterInsertMode&apos;, isEdit: true, interlaceInsertRepeat: true, actionArgs: { after: true }, context: &apos;normal&apos; },
    { keys: &apos;O&apos;, type: &apos;action&apos;, action: &apos;newLineAndEnterInsertMode&apos;, isEdit: true, interlaceInsertRepeat: true, actionArgs: { after: false }, context: &apos;normal&apos; },
    { keys: &apos;v&apos;, type: &apos;action&apos;, action: &apos;toggleVisualMode&apos; },
    { keys: &apos;V&apos;, type: &apos;action&apos;, action: &apos;toggleVisualMode&apos;, actionArgs: { linewise: true }},
    { keys: &apos;&lt;C-v&gt;&apos;, type: &apos;action&apos;, action: &apos;toggleVisualMode&apos;, actionArgs: { blockwise: true }},
    { keys: &apos;gv&apos;, type: &apos;action&apos;, action: &apos;reselectLastSelection&apos; },
    { keys: &apos;J&apos;, type: &apos;action&apos;, action: &apos;joinLines&apos;, isEdit: true },
    { keys: &apos;p&apos;, type: &apos;action&apos;, action: &apos;paste&apos;, isEdit: true, actionArgs: { after: true, isEdit: true }},
    { keys: &apos;P&apos;, type: &apos;action&apos;, action: &apos;paste&apos;, isEdit: true, actionArgs: { after: false, isEdit: true }},
    { keys: &apos;r&lt;character&gt;&apos;, type: &apos;action&apos;, action: &apos;replace&apos;, isEdit: true },
    { keys: &apos;@&lt;character&gt;&apos;, type: &apos;action&apos;, action: &apos;replayMacro&apos; },
    { keys: &apos;q&lt;character&gt;&apos;, type: &apos;action&apos;, action: &apos;enterMacroRecordMode&apos; },
    // Handle Replace-mode as a special case of insert mode.
    { keys: &apos;R&apos;, type: &apos;action&apos;, action: &apos;enterInsertMode&apos;, isEdit: true, actionArgs: { replace: true }},
    { keys: &apos;u&apos;, type: &apos;action&apos;, action: &apos;undo&apos;, context: &apos;normal&apos; },
    { keys: &apos;u&apos;, type: &apos;action&apos;, action: &apos;changeCase&apos;, actionArgs: {toLower: true}, context: &apos;visual&apos;, isEdit: true },
    { keys: &apos;U&apos;,type: &apos;action&apos;, action: &apos;changeCase&apos;, actionArgs: {toLower: false}, context: &apos;visual&apos;, isEdit: true },
    { keys: &apos;&lt;C-r&gt;&apos;, type: &apos;action&apos;, action: &apos;redo&apos; },
    { keys: &apos;m&lt;character&gt;&apos;, type: &apos;action&apos;, action: &apos;setMark&apos; },
    { keys: &apos;&quot;&lt;character&gt;&apos;, type: &apos;action&apos;, action: &apos;setRegister&apos; },
    { keys: &apos;zz&apos;, type: &apos;action&apos;, action: &apos;scrollToCursor&apos;, actionArgs: { position: &apos;center&apos; }},
    { keys: &apos;z.&apos;, type: &apos;action&apos;, action: &apos;scrollToCursor&apos;, actionArgs: { position: &apos;center&apos; }, motion: &apos;moveToFirstNonWhiteSpaceCharacter&apos; },
    { keys: &apos;zt&apos;, type: &apos;action&apos;, action: &apos;scrollToCursor&apos;, actionArgs: { position: &apos;top&apos; }},
    { keys: &apos;z&lt;CR&gt;&apos;, type: &apos;action&apos;, action: &apos;scrollToCursor&apos;, actionArgs: { position: &apos;top&apos; }, motion: &apos;moveToFirstNonWhiteSpaceCharacter&apos; },
    { keys: &apos;z-&apos;, type: &apos;action&apos;, action: &apos;scrollToCursor&apos;, actionArgs: { position: &apos;bottom&apos; }},
    { keys: &apos;zb&apos;, type: &apos;action&apos;, action: &apos;scrollToCursor&apos;, actionArgs: { position: &apos;bottom&apos; }, motion: &apos;moveToFirstNonWhiteSpaceCharacter&apos; },
    { keys: &apos;.&apos;, type: &apos;action&apos;, action: &apos;repeatLastEdit&apos; },
    { keys: &apos;&lt;C-a&gt;&apos;, type: &apos;action&apos;, action: &apos;incrementNumberToken&apos;, isEdit: true, actionArgs: {increase: true, backtrack: false}},
    { keys: &apos;&lt;C-x&gt;&apos;, type: &apos;action&apos;, action: &apos;incrementNumberToken&apos;, isEdit: true, actionArgs: {increase: false, backtrack: false}},
    // Text object motions
    { keys: &apos;a&lt;character&gt;&apos;, type: &apos;motion&apos;, motion: &apos;textObjectManipulation&apos; },
    { keys: &apos;i&lt;character&gt;&apos;, type: &apos;motion&apos;, motion: &apos;textObjectManipulation&apos;, motionArgs: { textObjectInner: true }},
    // Search
    { keys: &apos;/&apos;, type: &apos;search&apos;, searchArgs: { forward: true, querySrc: &apos;prompt&apos;, toJumplist: true }},
    { keys: &apos;?&apos;, type: &apos;search&apos;, searchArgs: { forward: false, querySrc: &apos;prompt&apos;, toJumplist: true }},
    { keys: &apos;*&apos;, type: &apos;search&apos;, searchArgs: { forward: true, querySrc: &apos;wordUnderCursor&apos;, wholeWordOnly: true, toJumplist: true }},
    { keys: &apos;#&apos;, type: &apos;search&apos;, searchArgs: { forward: false, querySrc: &apos;wordUnderCursor&apos;, wholeWordOnly: true, toJumplist: true }},
    { keys: &apos;g*&apos;, type: &apos;search&apos;, searchArgs: { forward: true, querySrc: &apos;wordUnderCursor&apos;, toJumplist: true }},
    { keys: &apos;g#&apos;, type: &apos;search&apos;, searchArgs: { forward: false, querySrc: &apos;wordUnderCursor&apos;, toJumplist: true }},
    // Ex command
    { keys: &apos;:&apos;, type: &apos;ex&apos; }
  ];

  var Pos = CodeMirror.Pos;

  var modifierCodes = [16, 17, 18, 91];
  var specialKey = {Enter:&apos;CR&apos;,Backspace:&apos;BS&apos;,Delete:&apos;Del&apos;};
  var mac = /Mac/.test(navigator.platform);
  var Vim = function() {
    CodeMirror.defineOption(&apos;vimMode&apos;, false, function(cm, val) {
      function lookupKey(e) {
        var keyCode = e.keyCode;
        if (modifierCodes.indexOf(keyCode) != -1) { return; }
        var hasModifier = e.ctrlKey || e.metaKey;
        var key = CodeMirror.keyNames[keyCode];
        key = specialKey[key] || key;
        var name = &apos;&apos;;
        if (e.ctrlKey) { name += &apos;C-&apos;; }
        if (e.altKey) { name += &apos;A-&apos;; }
        if (mac &amp;&amp; e.metaKey || (!hasModifier &amp;&amp; e.shiftKey) &amp;&amp; key.length &lt; 2) {
          // Shift key bindings can only specified for special characters.
          return;
        } else if (e.shiftKey &amp;&amp; !/^[A-Za-z]$/.test(key)) {
          name += &apos;S-&apos;;
        }
        if (key.length == 1) { key = key.toLowerCase(); }
        name += key;
        if (name.length &gt; 1) { name = &apos;&lt;&apos; + name + &apos;&gt;&apos;; }
        return name;
      }
      // Keys with modifiers are handled using keydown due to limitations of
      // keypress event.
      function handleKeyDown(cm, e) {
        var name = lookupKey(e);
        if (!name) { return; }

        CodeMirror.signal(cm, &apos;vim-keypress&apos;, name);
        if (CodeMirror.Vim.handleKey(cm, name, &apos;user&apos;)) {
          CodeMirror.e_stop(e);
        }
      }
      // Keys without modifiers are handled using keypress to work best with
      // non-standard keyboard layouts.
      function handleKeyPress(cm, e) {
        var code = e.charCode || e.keyCode;
        if (e.ctrlKey || e.metaKey || e.altKey ||
            e.shiftKey &amp;&amp; code &lt; 32) { return; }
        var name = String.fromCharCode(code);

        CodeMirror.signal(cm, &apos;vim-keypress&apos;, name);
        if (CodeMirror.Vim.handleKey(cm, name, &apos;user&apos;)) {
          CodeMirror.e_stop(e);
        }
      }
      if (val) {
        cm.setOption(&apos;keyMap&apos;, &apos;vim&apos;);
        cm.setOption(&apos;disableInput&apos;, true);
        cm.setOption(&apos;showCursorWhenSelecting&apos;, false);
        CodeMirror.signal(cm, &quot;vim-mode-change&quot;, {mode: &quot;normal&quot;});
        cm.on(&apos;cursorActivity&apos;, onCursorActivity);
        maybeInitVimState(cm);
        CodeMirror.on(cm.getInputField(), &apos;paste&apos;, getOnPasteFn(cm));
        cm.on(&apos;keypress&apos;, handleKeyPress);
        cm.on(&apos;keydown&apos;, handleKeyDown);
      } else if (cm.state.vim) {
        cm.setOption(&apos;keyMap&apos;, &apos;default&apos;);
        cm.setOption(&apos;disableInput&apos;, false);
        cm.off(&apos;cursorActivity&apos;, onCursorActivity);
        CodeMirror.off(cm.getInputField(), &apos;paste&apos;, getOnPasteFn(cm));
        cm.state.vim = null;
        cm.off(&apos;keypress&apos;, handleKeyPress);
        cm.off(&apos;keydown&apos;, handleKeyDown);
      }
    });
    function getOnPasteFn(cm) {
      var vim = cm.state.vim;
      if (!vim.onPasteFn) {
        vim.onPasteFn = function() {
          if (!vim.insertMode) {
            cm.setCursor(offsetCursor(cm.getCursor(), 0, 1));
            actions.enterInsertMode(cm, {}, vim);
          }
        };
      }
      return vim.onPasteFn;
    }

    var numberRegex = /[\d]/;
    var wordRegexp = [(/\w/), (/[^\w\s]/)], bigWordRegexp = [(/\S/)];
    function makeKeyRange(start, size) {
      var keys = [];
      for (var i = start; i &lt; start + size; i++) {
        keys.push(String.fromCharCode(i));
      }
      return keys;
    }
    var upperCaseAlphabet = makeKeyRange(65, 26);
    var lowerCaseAlphabet = makeKeyRange(97, 26);
    var numbers = makeKeyRange(48, 10);
    var validMarks = [].concat(upperCaseAlphabet, lowerCaseAlphabet, numbers, [&apos;&lt;&apos;, &apos;&gt;&apos;]);
    var validRegisters = [].concat(upperCaseAlphabet, lowerCaseAlphabet, numbers, [&apos;-&apos;, &apos;&quot;&apos;, &apos;.&apos;, &apos;:&apos;, &apos;/&apos;]);

    function isLine(cm, line) {
      return line &gt;= cm.firstLine() &amp;&amp; line &lt;= cm.lastLine();
    }
    function isLowerCase(k) {
      return (/^[a-z]$/).test(k);
    }
    function isMatchableSymbol(k) {
      return &apos;()[]{}&apos;.indexOf(k) != -1;
    }
    function isNumber(k) {
      return numberRegex.test(k);
    }
    function isUpperCase(k) {
      return (/^[A-Z]$/).test(k);
    }
    function isWhiteSpaceString(k) {
      return (/^\s*$/).test(k);
    }
    function inArray(val, arr) {
      for (var i = 0; i &lt; arr.length; i++) {
        if (arr[i] == val) {
          return true;
        }
      }
      return false;
    }

    var options = {};
    function defineOption(name, defaultValue, type) {
      if (defaultValue === undefined) { throw Error(&apos;defaultValue is required&apos;); }
      if (!type) { type = &apos;string&apos;; }
      options[name] = {
        type: type,
        defaultValue: defaultValue
      };
      setOption(name, defaultValue);
    }

    function setOption(name, value) {
      var option = options[name];
      if (!option) {
        throw Error(&apos;Unknown option: &apos; + name);
      }
      if (option.type == &apos;boolean&apos;) {
        if (value &amp;&amp; value !== true) {
          throw Error(&apos;Invalid argument: &apos; + name + &apos;=&apos; + value);
        } else if (value !== false) {
          // Boolean options are set to true if value is not defined.
          value = true;
        }
      }
      option.value = option.type == &apos;boolean&apos; ? !!value : value;
    }

    function getOption(name) {
      var option = options[name];
      if (!option) {
        throw Error(&apos;Unknown option: &apos; + name);
      }
      return option.value;
    }

    var createCircularJumpList = function() {
      var size = 100;
      var pointer = -1;
      var head = 0;
      var tail = 0;
      var buffer = new Array(size);
      function add(cm, oldCur, newCur) {
        var current = pointer % size;
        var curMark = buffer[current];
        function useNextSlot(cursor) {
          var next = ++pointer % size;
          var trashMark = buffer[next];
          if (trashMark) {
            trashMark.clear();
          }
          buffer[next] = cm.setBookmark(cursor);
        }
        if (curMark) {
          var markPos = curMark.find();
          // avoid recording redundant cursor position
          if (markPos &amp;&amp; !cursorEqual(markPos, oldCur)) {
            useNextSlot(oldCur);
          }
        } else {
          useNextSlot(oldCur);
        }
        useNextSlot(newCur);
        head = pointer;
        tail = pointer - size + 1;
        if (tail &lt; 0) {
          tail = 0;
        }
      }
      function move(cm, offset) {
        pointer += offset;
        if (pointer &gt; head) {
          pointer = head;
        } else if (pointer &lt; tail) {
          pointer = tail;
        }
        var mark = buffer[(size + pointer) % size];
        // skip marks that are temporarily removed from text buffer
        if (mark &amp;&amp; !mark.find()) {
          var inc = offset &gt; 0 ? 1 : -1;
          var newCur;
          var oldCur = cm.getCursor();
          do {
            pointer += inc;
            mark = buffer[(size + pointer) % size];
            // skip marks that are the same as current position
            if (mark &amp;&amp;
                (newCur = mark.find()) &amp;&amp;
                !cursorEqual(oldCur, newCur)) {
              break;
            }
          } while (pointer &lt; head &amp;&amp; pointer &gt; tail);
        }
        return mark;
      }
      return {
        cachedCursor: undefined, //used for # and * jumps
        add: add,
        move: move
      };
    };

    // Returns an object to track the changes associated insert mode.  It
    // clones the object that is passed in, or creates an empty object one if
    // none is provided.
    var createInsertModeChanges = function(c) {
      if (c) {
        // Copy construction
        return {
          changes: c.changes,
          expectCursorActivityForChange: c.expectCursorActivityForChange
        };
      }
      return {
        // Change list
        changes: [],
        // Set to true on change, false on cursorActivity.
        expectCursorActivityForChange: false
      };
    };

    function MacroModeState() {
      this.latestRegister = undefined;
      this.isPlaying = false;
      this.isRecording = false;
      this.replaySearchQueries = [];
      this.onRecordingDone = undefined;
      this.lastInsertModeChanges = createInsertModeChanges();
    }
    MacroModeState.prototype = {
      exitMacroRecordMode: function() {
        var macroModeState = vimGlobalState.macroModeState;
        if (macroModeState.onRecordingDone) {
          macroModeState.onRecordingDone(); // close dialog
        }
        macroModeState.onRecordingDone = undefined;
        macroModeState.isRecording = false;
      },
      enterMacroRecordMode: function(cm, registerName) {
        var register =
            vimGlobalState.registerController.getRegister(registerName);
        if (register) {
          register.clear();
          this.latestRegister = registerName;
          if (cm.openDialog) {
            this.onRecordingDone = cm.openDialog(
                &apos;(recording)[&apos;+registerName+&apos;]&apos;, null, {bottom:true});
          }
          this.isRecording = true;
        }
      }
    };

    function maybeInitVimState(cm) {
      if (!cm.state.vim) {
        // Store instance state in the CodeMirror object.
        cm.state.vim = {
          inputState: new InputState(),
          // Vim&apos;s input state that triggered the last edit, used to repeat
          // motions and operators with &apos;.&apos;.
          lastEditInputState: undefined,
          // Vim&apos;s action command before the last edit, used to repeat actions
          // with &apos;.&apos; and insert mode repeat.
          lastEditActionCommand: undefined,
          // When using jk for navigation, if you move from a longer line to a
          // shorter line, the cursor may clip to the end of the shorter line.
          // If j is pressed again and cursor goes to the next line, the
          // cursor should go back to its horizontal position on the longer
          // line if it can. This is to keep track of the horizontal position.
          lastHPos: -1,
          // Doing the same with screen-position for gj/gk
          lastHSPos: -1,
          // The last motion command run. Cleared if a non-motion command gets
          // executed in between.
          lastMotion: null,
          marks: {},
          // Mark for rendering fake cursor for visual mode.
          fakeCursor: null,
          insertMode: false,
          // Repeat count for changes made in insert mode, triggered by key
          // sequences like 3,i. Only exists when insertMode is true.
          insertModeRepeat: undefined,
          visualMode: false,
          // If we are in visual line mode. No effect if visualMode is false.
          visualLine: false,
          visualBlock: false,
          lastSelection: null,
          lastPastedText: null,
          // Used by two-character ESC keymap routines. Should not be changed from false here.
          awaitingEscapeSecondCharacter: false
        };
      }
      return cm.state.vim;
    }
    var vimGlobalState;
    function resetVimGlobalState() {
      vimGlobalState = {
        // The current search query.
        searchQuery: null,
        // Whether we are searching backwards.
        searchIsReversed: false,
        // Replace part of the last substituted pattern
        lastSubstituteReplacePart: undefined,
        jumpList: createCircularJumpList(),
        macroModeState: new MacroModeState,
        // Recording latest f, t, F or T motion command.
        lastChararacterSearch: {increment:0, forward:true, selectedCharacter:&apos;&apos;},
        registerController: new RegisterController({}),
        // search history buffer
        searchHistoryController: new HistoryController({}),
        // ex Command history buffer
        exCommandHistoryController : new HistoryController({})
      };
      for (var optionName in options) {
        var option = options[optionName];
        option.value = option.defaultValue;
      }
    }

    var lastInsertModeKeyTimer;
    var vimApi= {
      buildKeyMap: function() {
        // TODO: Convert keymap into dictionary format for fast lookup.
      },
      // Testing hook, though it might be useful to expose the register
      // controller anyways.
      getRegisterController: function() {
        return vimGlobalState.registerController;
      },
      // Testing hook.
      resetVimGlobalState_: resetVimGlobalState,

      // Testing hook.
      getVimGlobalState_: function() {
        return vimGlobalState;
      },

      // Testing hook.
      maybeInitVimState_: maybeInitVimState,

      InsertModeKey: InsertModeKey,
      map: function(lhs, rhs, ctx) {
        // Add user defined key bindings.
        exCommandDispatcher.map(lhs, rhs, ctx);
      },
      setOption: setOption,
      getOption: getOption,
      defineOption: defineOption,
      defineEx: function(name, prefix, func){
        if (name.indexOf(prefix) !== 0) {
          throw new Error(&apos;(Vim.defineEx) &quot;&apos;+prefix+&apos;&quot; is not a prefix of &quot;&apos;+name+&apos;&quot;, command not registered&apos;);
        }
        exCommands[name]=func;
        exCommandDispatcher.commandMap_[prefix]={name:name, shortName:prefix, type:&apos;api&apos;};
      },
      // This is the outermost function called by CodeMirror, after keys have
      // been mapped to their Vim equivalents.
      handleKey: function(cm, key, origin) {
        var vim = maybeInitVimState(cm);
        function handleMacroRecording() {
          var macroModeState = vimGlobalState.macroModeState;
          if (macroModeState.isRecording) {
            if (key == &apos;q&apos;) {
              macroModeState.exitMacroRecordMode();
              clearInputState(cm);
              return true;
            }
            if (origin != &apos;mapping&apos;) {
              logKey(macroModeState, key);
            }
          }
        }
        function handleEsc() {
          if (key == &apos;&lt;Esc&gt;&apos;) {
            // Clear input state and get back to normal mode.
            clearInputState(cm);
            if (vim.visualMode) {
              exitVisualMode(cm);
            } else if (vim.insertMode) {
              exitInsertMode(cm);
            }
            return true;
          }
        }
        function doKeyToKey(keys) {
          // TODO: prevent infinite recursion.
          var match;
          while (keys) {
            // Pull off one command key, which is either a single character
            // or a special sequence wrapped in &apos;&lt;&apos; and &apos;&gt;&apos;, e.g. &apos;&lt;Space&gt;&apos;.
            match = (/&lt;\w+-.+?&gt;|&lt;\w+&gt;|./).exec(keys);
            key = match[0];
            keys = keys.substring(match.index + key.length);
            CodeMirror.Vim.handleKey(cm, key, &apos;mapping&apos;);
          }
        }

        function handleKeyInsertMode() {
          if (handleEsc()) { return true; }
          var keys = vim.inputState.keyBuffer = vim.inputState.keyBuffer + key;
          var keysAreChars = key.length == 1;
          var match = commandDispatcher.matchCommand(keys, defaultKeymap, vim.inputState, &apos;insert&apos;);
          // Need to check all key substrings in insert mode.
          while (keys.length &gt; 1 &amp;&amp; match.type != &apos;full&apos;) {
            var keys = vim.inputState.keyBuffer = keys.slice(1);
            var thisMatch = commandDispatcher.matchCommand(keys, defaultKeymap, vim.inputState, &apos;insert&apos;);
            if (thisMatch.type != &apos;none&apos;) { match = thisMatch; }
          }
          if (match.type == &apos;none&apos;) { clearInputState(cm); return false; }
          else if (match.type == &apos;partial&apos;) {
            if (lastInsertModeKeyTimer) { window.clearTimeout(lastInsertModeKeyTimer); }
            lastInsertModeKeyTimer = window.setTimeout(
              function() { if (vim.insertMode &amp;&amp; vim.inputState.keyBuffer) { clearInputState(cm); } },
              getOption(&apos;insertModeEscKeysTimeout&apos;));
            return !keysAreChars;
          }

          if (lastInsertModeKeyTimer) { window.clearTimeout(lastInsertModeKeyTimer); }
          if (keysAreChars) {
            var here = cm.getCursor();
            cm.replaceRange(&apos;&apos;, offsetCursor(here, 0, -(keys.length - 1)), here, &apos;+input&apos;);
          }
          clearInputState(cm);
          var command = match.command;
          if (command.type == &apos;keyToKey&apos;) {
            doKeyToKey(command.toKeys);
          } else {
            commandDispatcher.processCommand(cm, vim, command);
          }
          return !keysAreChars;
        }

        function handleKeyNonInsertMode() {
          if (handleMacroRecording() || handleEsc()) { return true; };

          var keys = vim.inputState.keyBuffer = vim.inputState.keyBuffer + key;
          if (/^[1-9]\d*$/.test(keys)) { return true; }

          var keysMatcher = /^(\d*)(.*)$/.exec(keys);
          if (!keysMatcher) { clearInputState(cm); return false; }
          var context = vim.visualMode ? &apos;visual&apos; :
                                         &apos;normal&apos;;
          var match = commandDispatcher.matchCommand(keysMatcher[2] || keysMatcher[1], defaultKeymap, vim.inputState, context);
          if (match.type == &apos;none&apos;) { clearInputState(cm); return false; }
          else if (match.type == &apos;partial&apos;) { return true; }

          vim.inputState.keyBuffer = &apos;&apos;;
          var command = match.command;
          var keysMatcher = /^(\d*)(.*)$/.exec(keys);
          if (keysMatcher[1] &amp;&amp; keysMatcher[1] != &apos;0&apos;) {
            vim.inputState.pushRepeatDigit(keysMatcher[1]);
          }
          if (command.type == &apos;keyToKey&apos;) {
            doKeyToKey(command.toKeys);
          } else {
            commandDispatcher.processCommand(cm, vim, command);
          }
          return true;
        }

        if (vim.insertMode) { return handleKeyInsertMode(); }
        else { return handleKeyNonInsertMode(); }
      },
      handleEx: function(cm, input) {
        exCommandDispatcher.processCommand(cm, input);
      }
    };

    // Represents the current input state.
    function InputState() {
      this.prefixRepeat = [];
      this.motionRepeat = [];

      this.operator = null;
      this.operatorArgs = null;
      this.motion = null;
      this.motionArgs = null;
      this.keyBuffer = []; // For matching multi-key commands.
      this.registerName = null; // Defaults to the unnamed register.
    }
    InputState.prototype.pushRepeatDigit = function(n) {
      if (!this.operator) {
        this.prefixRepeat = this.prefixRepeat.concat(n);
      } else {
        this.motionRepeat = this.motionRepeat.concat(n);
      }
    };
    InputState.prototype.getRepeat = function() {
      var repeat = 0;
      if (this.prefixRepeat.length &gt; 0 || this.motionRepeat.length &gt; 0) {
        repeat = 1;
        if (this.prefixRepeat.length &gt; 0) {
          repeat *= parseInt(this.prefixRepeat.join(&apos;&apos;), 10);
        }
        if (this.motionRepeat.length &gt; 0) {
          repeat *= parseInt(this.motionRepeat.join(&apos;&apos;), 10);
        }
      }
      return repeat;
    };

    function clearInputState(cm, reason) {
      cm.state.vim.inputState = new InputState();
      CodeMirror.signal(cm, &apos;vim-command-done&apos;, reason);
    }

    /*
     * Register stores information about copy and paste registers.  Besides
     * text, a register must store whether it is linewise (i.e., when it is
     * pasted, should it insert itself into a new line, or should the text be
     * inserted at the cursor position.)
     */
    function Register(text, linewise, blockwise) {
      this.clear();
      this.keyBuffer = [text || &apos;&apos;];
      this.insertModeChanges = [];
      this.searchQueries = [];
      this.linewise = !!linewise;
      this.blockwise = !!blockwise;
    }
    Register.prototype = {
      setText: function(text, linewise, blockwise) {
        this.keyBuffer = [text || &apos;&apos;];
        this.linewise = !!linewise;
        this.blockwise = !!blockwise;
      },
      pushText: function(text, linewise) {
        // if this register has ever been set to linewise, use linewise.
        if (linewise) {
          if (!this.linewise) {
            this.keyBuffer.push(&apos;\n&apos;);
          }
          this.linewise = true;
        }
        this.keyBuffer.push(text);
      },
      pushInsertModeChanges: function(changes) {
        this.insertModeChanges.push(createInsertModeChanges(changes));
      },
      pushSearchQuery: function(query) {
        this.searchQueries.push(query);
      },
      clear: function() {
        this.keyBuffer = [];
        this.insertModeChanges = [];
        this.searchQueries = [];
        this.linewise = false;
      },
      toString: function() {
        return this.keyBuffer.join(&apos;&apos;);
      }
    };

    /*
     * vim registers allow you to keep many independent copy and paste buffers.
     * See http://usevim.com/2012/04/13/registers/ for an introduction.
     *
     * RegisterController keeps the state of all the registers.  An initial
     * state may be passed in.  The unnamed register &apos;&quot;&apos; will always be
     * overridden.
     */
    function RegisterController(registers) {
      this.registers = registers;
      this.unnamedRegister = registers[&apos;&quot;&apos;] = new Register();
      registers[&apos;.&apos;] = new Register();
      registers[&apos;:&apos;] = new Register();
      registers[&apos;/&apos;] = new Register();
    }
    RegisterController.prototype = {
      pushText: function(registerName, operator, text, linewise, blockwise) {
        if (linewise &amp;&amp; text.charAt(0) == &apos;\n&apos;) {
          text = text.slice(1) + &apos;\n&apos;;
        }
        if (linewise &amp;&amp; text.charAt(text.length - 1) !== &apos;\n&apos;){
          text += &apos;\n&apos;;
        }
        // Lowercase and uppercase registers refer to the same register.
        // Uppercase just means append.
        var register = this.isValidRegister(registerName) ?
            this.getRegister(registerName) : null;
        // if no register/an invalid register was specified, things go to the
        // default registers
        if (!register) {
          switch (operator) {
            case &apos;yank&apos;:
              // The 0 register contains the text from the most recent yank.
              this.registers[&apos;0&apos;] = new Register(text, linewise, blockwise);
              break;
            case &apos;delete&apos;:
            case &apos;change&apos;:
              if (text.indexOf(&apos;\n&apos;) == -1) {
                // Delete less than 1 line. Update the small delete register.
                this.registers[&apos;-&apos;] = new Register(text, linewise);
              } else {
                // Shift down the contents of the numbered registers and put the
                // deleted text into register 1.
                this.shiftNumericRegisters_();
                this.registers[&apos;1&apos;] = new Register(text, linewise);
              }
              break;
          }
          // Make sure the unnamed register is set to what just happened
          this.unnamedRegister.setText(text, linewise, blockwise);
          return;
        }

        // If we&apos;ve gotten to this point, we&apos;ve actually specified a register
        var append = isUpperCase(registerName);
        if (append) {
          register.pushText(text, linewise);
        } else {
          register.setText(text, linewise, blockwise);
        }
        // The unnamed register always has the same value as the last used
        // register.
        this.unnamedRegister.setText(register.toString(), linewise);
      },
      // Gets the register named @name.  If one of @name doesn&apos;t already exist,
      // create it.  If @name is invalid, return the unnamedRegister.
      getRegister: function(name) {
        if (!this.isValidRegister(name)) {
          return this.unnamedRegister;
        }
        name = name.toLowerCase();
        if (!this.registers[name]) {
          this.registers[name] = new Register();
        }
        return this.registers[name];
      },
      isValidRegister: function(name) {
        return name &amp;&amp; inArray(name, validRegisters);
      },
      shiftNumericRegisters_: function() {
        for (var i = 9; i &gt;= 2; i--) {
          this.registers[i] = this.getRegister(&apos;&apos; + (i - 1));
        }
      }
    };
    function HistoryController() {
        this.historyBuffer = [];
        this.iterator;
        this.initialPrefix = null;
    }
    HistoryController.prototype = {
      // the input argument here acts a user entered prefix for a small time
      // until we start autocompletion in which case it is the autocompleted.
      nextMatch: function (input, up) {
        var historyBuffer = this.historyBuffer;
        var dir = up ? -1 : 1;
        if (this.initialPrefix === null) this.initialPrefix = input;
        for (var i = this.iterator + dir; up ? i &gt;= 0 : i &lt; historyBuffer.length; i+= dir) {
          var element = historyBuffer[i];
          for (var j = 0; j &lt;= element.length; j++) {
            if (this.initialPrefix == element.substring(0, j)) {
              this.iterator = i;
              return element;
            }
          }
        }
        // should return the user input in case we reach the end of buffer.
        if (i &gt;= historyBuffer.length) {
          this.iterator = historyBuffer.length;
          return this.initialPrefix;
        }
        // return the last autocompleted query or exCommand as it is.
        if (i &lt; 0 ) return input;
      },
      pushInput: function(input) {
        var index = this.historyBuffer.indexOf(input);
        if (index &gt; -1) this.historyBuffer.splice(index, 1);
        if (input.length) this.historyBuffer.push(input);
      },
      reset: function() {
        this.initialPrefix = null;
        this.iterator = this.historyBuffer.length;
      }
    };
    var commandDispatcher = {
      matchCommand: function(keys, keyMap, inputState, context) {
        var matches = commandMatches(keys, keyMap, context, inputState);
        if (!matches.full &amp;&amp; !matches.partial) {
          return {type: &apos;none&apos;};
        } else if (!matches.full &amp;&amp; matches.partial) {
          return {type: &apos;partial&apos;};
        }

        var bestMatch;
        for (var i = 0; i &lt; matches.full.length; i++) {
          var match = matches.full[i];
          if (!bestMatch) {
            bestMatch = match;
          }
        }
        if (bestMatch.keys.slice(-11) == &apos;&lt;character&gt;&apos;) {
          inputState.selectedCharacter = lastChar(keys);
        }
        return {type: &apos;full&apos;, command: bestMatch};
      },
      processCommand: function(cm, vim, command) {
        vim.inputState.repeatOverride = command.repeatOverride;
        switch (command.type) {
          case &apos;motion&apos;:
            this.processMotion(cm, vim, command);
            break;
          case &apos;operator&apos;:
            this.processOperator(cm, vim, command);
            break;
          case &apos;operatorMotion&apos;:
            this.processOperatorMotion(cm, vim, command);
            break;
          case &apos;action&apos;:
            this.processAction(cm, vim, command);
            break;
          case &apos;search&apos;:
            this.processSearch(cm, vim, command);
            break;
          case &apos;ex&apos;:
          case &apos;keyToEx&apos;:
            this.processEx(cm, vim, command);
            break;
          default:
            break;
        }
      },
      processMotion: function(cm, vim, command) {
        vim.inputState.motion = command.motion;
        vim.inputState.motionArgs = copyArgs(command.motionArgs);
        this.evalInput(cm, vim);
      },
      processOperator: function(cm, vim, command) {
        var inputState = vim.inputState;
        if (inputState.operator) {
          if (inputState.operator == command.operator) {
            // Typing an operator twice like &apos;dd&apos; makes the operator operate
            // linewise
            inputState.motion = &apos;expandToLine&apos;;
            inputState.motionArgs = { linewise: true };
            this.evalInput(cm, vim);
            return;
          } else {
            // 2 different operators in a row doesn&apos;t make sense.
            clearInputState(cm);
          }
        }
        inputState.operator = command.operator;
        inputState.operatorArgs = copyArgs(command.operatorArgs);
        if (vim.visualMode) {
          // Operating on a selection in visual mode. We don&apos;t need a motion.
          this.evalInput(cm, vim);
        }
      },
      processOperatorMotion: function(cm, vim, command) {
        var visualMode = vim.visualMode;
        var operatorMotionArgs = copyArgs(command.operatorMotionArgs);
        if (operatorMotionArgs) {
          // Operator motions may have special behavior in visual mode.
          if (visualMode &amp;&amp; operatorMotionArgs.visualLine) {
            vim.visualLine = true;
          }
        }
        this.processOperator(cm, vim, command);
        if (!visualMode) {
          this.processMotion(cm, vim, command);
        }
      },
      processAction: function(cm, vim, command) {
        var inputState = vim.inputState;
        var repeat = inputState.getRepeat();
        var repeatIsExplicit = !!repeat;
        var actionArgs = copyArgs(command.actionArgs) || {};
        if (inputState.selectedCharacter) {
          actionArgs.selectedCharacter = inputState.selectedCharacter;
        }
        // Actions may or may not have motions and operators. Do these first.
        if (command.operator) {
          this.processOperator(cm, vim, command);
        }
        if (command.motion) {
          this.processMotion(cm, vim, command);
        }
        if (command.motion || command.operator) {
          this.evalInput(cm, vim);
        }
        actionArgs.repeat = repeat || 1;
        actionArgs.repeatIsExplicit = repeatIsExplicit;
        actionArgs.registerName = inputState.registerName;
        clearInputState(cm);
        vim.lastMotion = null;
        if (command.isEdit) {
          this.recordLastEdit(vim, inputState, command);
        }
        actions[command.action](cm, actionArgs, vim);
      },
      processSearch: function(cm, vim, command) {
        if (!cm.getSearchCursor) {
          // Search depends on SearchCursor.
          return;
        }
        var forward = command.searchArgs.forward;
        var wholeWordOnly = command.searchArgs.wholeWordOnly;
        getSearchState(cm).setReversed(!forward);
        var promptPrefix = (forward) ? &apos;/&apos; : &apos;?&apos;;
        var originalQuery = getSearchState(cm).getQuery();
        var originalScrollPos = cm.getScrollInfo();
        function handleQuery(query, ignoreCase, smartCase) {
          vimGlobalState.searchHistoryController.pushInput(query);
          vimGlobalState.searchHistoryController.reset();
          try {
            updateSearchQuery(cm, query, ignoreCase, smartCase);
          } catch (e) {
            showConfirm(cm, &apos;Invalid regex: &apos; + query);
            return;
          }
          commandDispatcher.processMotion(cm, vim, {
            type: &apos;motion&apos;,
            motion: &apos;findNext&apos;,
            motionArgs: { forward: true, toJumplist: command.searchArgs.toJumplist }
          });
        }
        function onPromptClose(query) {
          cm.scrollTo(originalScrollPos.left, originalScrollPos.top);
          handleQuery(query, true /** ignoreCase */, true /** smartCase */);
          var macroModeState = vimGlobalState.macroModeState;
          if (macroModeState.isRecording) {
            logSearchQuery(macroModeState, query);
          }
        }
        function onPromptKeyUp(e, query, close) {
          var keyName = CodeMirror.keyName(e), up;
          if (keyName == &apos;Up&apos; || keyName == &apos;Down&apos;) {
            up = keyName == &apos;Up&apos; ? true : false;
            query = vimGlobalState.searchHistoryController.nextMatch(query, up) || &apos;&apos;;
            close(query);
          } else {
            if ( keyName != &apos;Left&apos; &amp;&amp; keyName != &apos;Right&apos; &amp;&amp; keyName != &apos;Ctrl&apos; &amp;&amp; keyName != &apos;Alt&apos; &amp;&amp; keyName != &apos;Shift&apos;)
              vimGlobalState.searchHistoryController.reset();
          }
          var parsedQuery;
          try {
            parsedQuery = updateSearchQuery(cm, query,
                true /** ignoreCase */, true /** smartCase */);
          } catch (e) {
            // Swallow bad regexes for incremental search.
          }
          if (parsedQuery) {
            cm.scrollIntoView(findNext(cm, !forward, parsedQuery), 30);
          } else {
            clearSearchHighlight(cm);
            cm.scrollTo(originalScrollPos.left, originalScrollPos.top);
          }
        }
        function onPromptKeyDown(e, query, close) {
          var keyName = CodeMirror.keyName(e);
          if (keyName == &apos;Esc&apos; || keyName == &apos;Ctrl-C&apos; || keyName == &apos;Ctrl-[&apos;) {
            vimGlobalState.searchHistoryController.pushInput(query);
            vimGlobalState.searchHistoryController.reset();
            updateSearchQuery(cm, originalQuery);
            clearSearchHighlight(cm);
            cm.scrollTo(originalScrollPos.left, originalScrollPos.top);
            CodeMirror.e_stop(e);
            close();
            cm.focus();
          }
        }
        switch (command.searchArgs.querySrc) {
          case &apos;prompt&apos;:
            var macroModeState = vimGlobalState.macroModeState;
            if (macroModeState.isPlaying) {
              var query = macroModeState.replaySearchQueries.shift();
              handleQuery(query, true /** ignoreCase */, false /** smartCase */);
            } else {
              showPrompt(cm, {
                  onClose: onPromptClose,
                  prefix: promptPrefix,
                  desc: searchPromptDesc,
                  onKeyUp: onPromptKeyUp,
                  onKeyDown: onPromptKeyDown
              });
            }
            break;
          case &apos;wordUnderCursor&apos;:
            var word = expandWordUnderCursor(cm, false /** inclusive */,
                true /** forward */, false /** bigWord */,
                true /** noSymbol */);
            var isKeyword = true;
            if (!word) {
              word = expandWordUnderCursor(cm, false /** inclusive */,
                  true /** forward */, false /** bigWord */,
                  false /** noSymbol */);
              isKeyword = false;
            }
            if (!word) {
              return;
            }
            var query = cm.getLine(word.start.line).substring(word.start.ch,
                word.end.ch);
            if (isKeyword &amp;&amp; wholeWordOnly) {
                query = &apos;\\b&apos; + query + &apos;\\b&apos;;
            } else {
              query = escapeRegex(query);
            }

            // cachedCursor is used to save the old position of the cursor
            // when * or # causes vim to seek for the nearest word and shift
            // the cursor before entering the motion.
            vimGlobalState.jumpList.cachedCursor = cm.getCursor();
            cm.setCursor(word.start);

            handleQuery(query, true /** ignoreCase */, false /** smartCase */);
            break;
        }
      },
      processEx: function(cm, vim, command) {
        function onPromptClose(input) {
          // Give the prompt some time to close so that if processCommand shows
          // an error, the elements don&apos;t overlap.
          vimGlobalState.exCommandHistoryController.pushInput(input);
          vimGlobalState.exCommandHistoryController.reset();
          exCommandDispatcher.processCommand(cm, input);
        }
        function onPromptKeyDown(e, input, close) {
          var keyName = CodeMirror.keyName(e), up;
          if (keyName == &apos;Esc&apos; || keyName == &apos;Ctrl-C&apos; || keyName == &apos;Ctrl-[&apos;) {
            vimGlobalState.exCommandHistoryController.pushInput(input);
            vimGlobalState.exCommandHistoryController.reset();
            CodeMirror.e_stop(e);
            close();
            cm.focus();
          }
          if (keyName == &apos;Up&apos; || keyName == &apos;Down&apos;) {
            up = keyName == &apos;Up&apos; ? true : false;
            input = vimGlobalState.exCommandHistoryController.nextMatch(input, up) || &apos;&apos;;
            close(input);
          } else {
            if ( keyName != &apos;Left&apos; &amp;&amp; keyName != &apos;Right&apos; &amp;&amp; keyName != &apos;Ctrl&apos; &amp;&amp; keyName != &apos;Alt&apos; &amp;&amp; keyName != &apos;Shift&apos;)
              vimGlobalState.exCommandHistoryController.reset();
          }
        }
        if (command.type == &apos;keyToEx&apos;) {
          // Handle user defined Ex to Ex mappings
          exCommandDispatcher.processCommand(cm, command.exArgs.input);
        } else {
          if (vim.visualMode) {
            showPrompt(cm, { onClose: onPromptClose, prefix: &apos;:&apos;, value: &apos;\&apos;&lt;,\&apos;&gt;&apos;,
                onKeyDown: onPromptKeyDown});
          } else {
            showPrompt(cm, { onClose: onPromptClose, prefix: &apos;:&apos;,
                onKeyDown: onPromptKeyDown});
          }
        }
      },
      evalInput: function(cm, vim) {
        // If the motion comand is set, execute both the operator and motion.
        // Otherwise return.
        var inputState = vim.inputState;
        var motion = inputState.motion;
        var motionArgs = inputState.motionArgs || {};
        var operator = inputState.operator;
        var operatorArgs = inputState.operatorArgs || {};
        var registerName = inputState.registerName;
        var selectionEnd = copyCursor(cm.getCursor(&apos;head&apos;));
        var selectionStart = copyCursor(cm.getCursor(&apos;anchor&apos;));
        // The difference between cur and selection cursors are that cur is
        // being operated on and ignores that there is a selection.
        var curStart = copyCursor(selectionEnd);
        var curOriginal = copyCursor(curStart);
        var curEnd;
        var repeat;
        if (operator) {
          this.recordLastEdit(vim, inputState);
        }
        if (inputState.repeatOverride !== undefined) {
          // If repeatOverride is specified, that takes precedence over the
          // input state&apos;s repeat. Used by Ex mode and can be user defined.
          repeat = inputState.repeatOverride;
        } else {
          repeat = inputState.getRepeat();
        }
        if (repeat &gt; 0 &amp;&amp; motionArgs.explicitRepeat) {
          motionArgs.repeatIsExplicit = true;
        } else if (motionArgs.noRepeat ||
            (!motionArgs.explicitRepeat &amp;&amp; repeat === 0)) {
          repeat = 1;
          motionArgs.repeatIsExplicit = false;
        }
        if (inputState.selectedCharacter) {
          // If there is a character input, stick it in all of the arg arrays.
          motionArgs.selectedCharacter = operatorArgs.selectedCharacter =
              inputState.selectedCharacter;
        }
        motionArgs.repeat = repeat;
        clearInputState(cm);
        if (motion) {
          var motionResult = motions[motion](cm, motionArgs, vim);
          vim.lastMotion = motions[motion];
          if (!motionResult) {
            return;
          }
          if (motionArgs.toJumplist) {
            var jumpList = vimGlobalState.jumpList;
            // if the current motion is # or *, use cachedCursor
            var cachedCursor = jumpList.cachedCursor;
            if (cachedCursor) {
              recordJumpPosition(cm, cachedCursor, motionResult);
              delete jumpList.cachedCursor;
            } else {
              recordJumpPosition(cm, curOriginal, motionResult);
            }
          }
          if (motionResult instanceof Array) {
            curStart = motionResult[0];
            curEnd = motionResult[1];
          } else {
            curEnd = motionResult;
          }
          // TODO: Handle null returns from motion commands better.
          if (!curEnd) {
            curEnd = Pos(curStart.line, curStart.ch);
          }
          if (vim.visualMode) {
            // Check if the selection crossed over itself. Will need to shift
            // the start point if that happened.
            // offset is set to -1 or 1 to shift the curEnd
            // left or right
            var offset = 0;
            if (cursorIsBefore(selectionStart, selectionEnd) &amp;&amp;
                (cursorEqual(selectionStart, curEnd) ||
                    cursorIsBefore(curEnd, selectionStart))) {
              // The end of the selection has moved from after the start to
              // before the start. We will shift the start right by 1.
              selectionStart.ch += 1;
              offset = -1;
            } else if (cursorIsBefore(selectionEnd, selectionStart) &amp;&amp;
                (cursorEqual(selectionStart, curEnd) ||
                    cursorIsBefore(selectionStart, curEnd))) {
              // The opposite happened. We will shift the start left by 1.
              selectionStart.ch -= 1;
              offset = 1;
            }
            // in case of visual Block selectionStart and curEnd
            // may not be on the same line,
            // Also, In case of v_o this should not happen.
            if (!vim.visualBlock &amp;&amp; !(motionResult instanceof Array)) {
              curEnd.ch += offset;
            }
            if (vim.lastHPos != Infinity) {
              vim.lastHPos = curEnd.ch;
            }
            selectionEnd = curEnd;
            selectionStart = (motionResult instanceof Array) ? curStart : selectionStart;
            if (vim.visualLine) {
              if (cursorIsBefore(selectionStart, selectionEnd)) {
                selectionStart.ch = 0;

                var lastLine = cm.lastLine();
                if (selectionEnd.line &gt; lastLine) {
                  selectionEnd.line = lastLine;
                }
                selectionEnd.ch = lineLength(cm, selectionEnd.line);
              } else {
                selectionEnd.ch = 0;
                selectionStart.ch = lineLength(cm, selectionStart.line);
              }
            } else if (vim.visualBlock) {
              // Select a block and
              // return the diagonally opposite end.
              selectionStart = selectBlock(cm, selectionEnd);
            }
            if (!vim.visualBlock) {
              cm.setSelection(selectionStart, selectionEnd);
            }
            updateMark(cm, vim, &apos;&lt;&apos;,
                cursorIsBefore(selectionStart, selectionEnd) ? selectionStart
                    : selectionEnd);
            updateMark(cm, vim, &apos;&gt;&apos;,
                cursorIsBefore(selectionStart, selectionEnd) ? selectionEnd
                    : selectionStart);
          } else if (!operator) {
            curEnd = clipCursorToContent(cm, curEnd);
            cm.setCursor(curEnd.line, curEnd.ch);
          }
        }

        if (operator) {
          var inverted = false;
          vim.lastMotion = null;
          var lastSelection = vim.lastSelection;
          operatorArgs.repeat = repeat; // Indent in visual mode needs this.
          if (vim.visualMode) {
            curStart = selectionStart;
            curEnd = selectionEnd;
            motionArgs.inclusive = true;
            operatorArgs.shouldMoveCursor = false;
          }
          // Swap start and end if motion was backward.
          if (curEnd &amp;&amp; cursorIsBefore(curEnd, curStart)) {
            var tmp = curStart;
            curStart = curEnd;
            curEnd = tmp;
            inverted = true;
          } else if (!curEnd) {
            curEnd = copyCursor(curStart);
          }
          if (motionArgs.inclusive &amp;&amp; !vim.visualMode) {
            // Move the selection end one to the right to include the last
            // character.
            curEnd.ch++;
          }
          if (operatorArgs.selOffset) {
            // Replaying a visual mode operation
            curEnd.line = curStart.line + operatorArgs.selOffset.line;
            if (operatorArgs.selOffset.line) {curEnd.ch = operatorArgs.selOffset.ch; }
            else { curEnd.ch = curStart.ch + operatorArgs.selOffset.ch; }
            // In case of blockwise visual
            if (lastSelection &amp;&amp; lastSelection.visualBlock) {
              var block = lastSelection.visualBlock;
              var width = block.width;
              var height = block.height;
              curEnd = Pos(curStart.line + height, curStart.ch + width);
              // selectBlock creates a &apos;proper&apos; rectangular block.
              // We do not want that in all cases, so we manually set selections.
              var selections = [];
              for (var i = curStart.line; i &lt; curEnd.line; i++) {
                var anchor = Pos(i, curStart.ch);
                var head = Pos(i, curEnd.ch);
                var range = {anchor: anchor, head: head};
                selections.push(range);
              }
              cm.setSelections(selections);
              var blockSelected = true;
            }
          } else if (vim.visualMode) {
            var selOffset = Pos();
            selOffset.line = curEnd.line - curStart.line;
            if (selOffset.line) { selOffset.ch = curEnd.ch; }
            else { selOffset.ch = curEnd.ch - curStart.ch; }
            operatorArgs.selOffset = selOffset;
          }
          var linewise = motionArgs.linewise ||
              (vim.visualMode &amp;&amp; vim.visualLine) ||
              operatorArgs.linewise;
          if (linewise) {
            // Expand selection to entire line.
            expandSelectionToLine(cm, curStart, curEnd);
          } else if (motionArgs.forward) {
            // Clip to trailing newlines only if the motion goes forward.
            clipToLine(cm, curStart, curEnd);
          }
          operatorArgs.registerName = registerName;
          // Keep track of linewise as it affects how paste and change behave.
          operatorArgs.linewise = linewise;
          if (!vim.visualBlock &amp;&amp; !blockSelected) {
            cm.setSelection(curStart, curEnd);
          }
          operators[operator](cm, operatorArgs, vim, curStart,
              curEnd, curOriginal);
          if (vim.visualMode) {
            exitVisualMode(cm);
          }
        }
      },
      recordLastEdit: function(vim, inputState, actionCommand) {
        var macroModeState = vimGlobalState.macroModeState;
        if (macroModeState.isPlaying) { return; }
        vim.lastEditInputState = inputState;
        vim.lastEditActionCommand = actionCommand;
        macroModeState.lastInsertModeChanges.changes = [];
        macroModeState.lastInsertModeChanges.expectCursorActivityForChange = false;
      }
    };

    /**
     * typedef {Object{line:number,ch:number}} Cursor An object containing the
     *     position of the cursor.
     */
    // All of the functions below return Cursor objects.
    var motions = {
      moveToTopLine: function(cm, motionArgs) {
        var line = getUserVisibleLines(cm).top + motionArgs.repeat -1;
        return Pos(line, findFirstNonWhiteSpaceCharacter(cm.getLine(line)));
      },
      moveToMiddleLine: function(cm) {
        var range = getUserVisibleLines(cm);
        var line = Math.floor((range.top + range.bottom) * 0.5);
        return Pos(line, findFirstNonWhiteSpaceCharacter(cm.getLine(line)));
      },
      moveToBottomLine: function(cm, motionArgs) {
        var line = getUserVisibleLines(cm).bottom - motionArgs.repeat +1;
        return Pos(line, findFirstNonWhiteSpaceCharacter(cm.getLine(line)));
      },
      expandToLine: function(cm, motionArgs) {
        // Expands forward to end of line, and then to next line if repeat is
        // &gt;1. Does not handle backward motion!
        var cur = cm.getCursor();
        return Pos(cur.line + motionArgs.repeat - 1, Infinity);
      },
      findNext: function(cm, motionArgs) {
        var state = getSearchState(cm);
        var query = state.getQuery();
        if (!query) {
          return;
        }
        var prev = !motionArgs.forward;
        // If search is initiated with ? instead of /, negate direction.
        prev = (state.isReversed()) ? !prev : prev;
        highlightSearchMatches(cm, query);
        return findNext(cm, prev/** prev */, query, motionArgs.repeat);
      },
      goToMark: function(cm, motionArgs, vim) {
        var mark = vim.marks[motionArgs.selectedCharacter];
        if (mark) {
          var pos = mark.find();
          return motionArgs.linewise ? { line: pos.line, ch: findFirstNonWhiteSpaceCharacter(cm.getLine(pos.line)) } : pos;
        }
        return null;
      },
      moveToOtherHighlightedEnd: function(cm, motionArgs, vim) {
        var ranges = cm.listSelections();
        var curEnd = cm.getCursor(&apos;head&apos;);
        var curStart = ranges[0].anchor;
        var curIndex = cursorEqual(ranges[0].head, curEnd) ? ranges.length-1 : 0;
        if (motionArgs.sameLine &amp;&amp; vim.visualBlock) {
          curStart = Pos(curEnd.line, ranges[curIndex].anchor.ch);
          curEnd = Pos(ranges[curIndex].head.line, curEnd.ch);
        } else {
          curStart = ranges[curIndex].anchor;
        }
        cm.setCursor(curEnd);
        return ([curEnd, curStart]);
      },
      jumpToMark: function(cm, motionArgs, vim) {
        var best = cm.getCursor();
        for (var i = 0; i &lt; motionArgs.repeat; i++) {
          var cursor = best;
          for (var key in vim.marks) {
            if (!isLowerCase(key)) {
              continue;
            }
            var mark = vim.marks[key].find();
            var isWrongDirection = (motionArgs.forward) ?
              cursorIsBefore(mark, cursor) : cursorIsBefore(cursor, mark);

            if (isWrongDirection) {
              continue;
            }
            if (motionArgs.linewise &amp;&amp; (mark.line == cursor.line)) {
              continue;
            }

            var equal = cursorEqual(cursor, best);
            var between = (motionArgs.forward) ?
              cursorIsBetween(cursor, mark, best) :
              cursorIsBetween(best, mark, cursor);

            if (equal || between) {
              best = mark;
            }
          }
        }

        if (motionArgs.linewise) {
          // Vim places the cursor on the first non-whitespace character of
          // the line if there is one, else it places the cursor at the end
          // of the line, regardless of whether a mark was found.
          best = Pos(best.line, findFirstNonWhiteSpaceCharacter(cm.getLine(best.line)));
        }
        return best;
      },
      moveByCharacters: function(cm, motionArgs) {
        var cur = cm.getCursor();
        var repeat = motionArgs.repeat;
        var ch = motionArgs.forward ? cur.ch + repeat : cur.ch - repeat;
        return Pos(cur.line, ch);
      },
      moveByLines: function(cm, motionArgs, vim) {
        var cur = cm.getCursor();
        var endCh = cur.ch;
        // Depending what our last motion was, we may want to do different
        // things. If our last motion was moving vertically, we want to
        // preserve the HPos from our last horizontal move.  If our last motion
        // was going to the end of a line, moving vertically we should go to
        // the end of the line, etc.
        switch (vim.lastMotion) {
          case this.moveByLines:
          case this.moveByDisplayLines:
          case this.moveByScroll:
          case this.moveToColumn:
          case this.moveToEol:
            endCh = vim.lastHPos;
            break;
          default:
            vim.lastHPos = endCh;
        }
        var repeat = motionArgs.repeat+(motionArgs.repeatOffset||0);
        var line = motionArgs.forward ? cur.line + repeat : cur.line - repeat;
        var first = cm.firstLine();
        var last = cm.lastLine();
        // Vim cancels linewise motions that start on an edge and move beyond
        // that edge. It does not cancel motions that do not start on an edge.
        if ((line &lt; first &amp;&amp; cur.line == first) ||
            (line &gt; last &amp;&amp; cur.line == last)) {
          return;
        }
        if (motionArgs.toFirstChar){
          endCh=findFirstNonWhiteSpaceCharacter(cm.getLine(line));
          vim.lastHPos = endCh;
        }
        vim.lastHSPos = cm.charCoords(Pos(line, endCh),&apos;div&apos;).left;
        return Pos(line, endCh);
      },
      moveByDisplayLines: function(cm, motionArgs, vim) {
        var cur = cm.getCursor();
        switch (vim.lastMotion) {
          case this.moveByDisplayLines:
          case this.moveByScroll:
          case this.moveByLines:
          case this.moveToColumn:
          case this.moveToEol:
            break;
          default:
            vim.lastHSPos = cm.charCoords(cur,&apos;div&apos;).left;
        }
        var repeat = motionArgs.repeat;
        var res=cm.findPosV(cur,(motionArgs.forward ? repeat : -repeat),&apos;line&apos;,vim.lastHSPos);
        if (res.hitSide) {
          if (motionArgs.forward) {
            var lastCharCoords = cm.charCoords(res, &apos;div&apos;);
            var goalCoords = { top: lastCharCoords.top + 8, left: vim.lastHSPos };
            var res = cm.coordsChar(goalCoords, &apos;div&apos;);
          } else {
            var resCoords = cm.charCoords(Pos(cm.firstLine(), 0), &apos;div&apos;);
            resCoords.left = vim.lastHSPos;
            res = cm.coordsChar(resCoords, &apos;div&apos;);
          }
        }
        vim.lastHPos = res.ch;
        return res;
      },
      moveByPage: function(cm, motionArgs) {
        // CodeMirror only exposes functions that move the cursor page down, so
        // doing this bad hack to move the cursor and move it back. evalInput
        // will move the cursor to where it should be in the end.
        var curStart = cm.getCursor();
        var repeat = motionArgs.repeat;
        return cm.findPosV(curStart, (motionArgs.forward ? repeat : -repeat), &apos;page&apos;);
      },
      moveByParagraph: function(cm, motionArgs) {
        var line = cm.getCursor().line;
        var repeat = motionArgs.repeat;
        var inc = motionArgs.forward ? 1 : -1;
        for (var i = 0; i &lt; repeat; i++) {
          if ((!motionArgs.forward &amp;&amp; line === cm.firstLine() ) ||
              (motionArgs.forward &amp;&amp; line == cm.lastLine())) {
            break;
          }
          line += inc;
          while (line !== cm.firstLine() &amp;&amp; line != cm.lastLine() &amp;&amp; cm.getLine(line)) {
            line += inc;
          }
        }
        return Pos(line, 0);
      },
      moveByScroll: function(cm, motionArgs, vim) {
        var scrollbox = cm.getScrollInfo();
        var curEnd = null;
        var repeat = motionArgs.repeat;
        if (!repeat) {
          repeat = scrollbox.clientHeight / (2 * cm.defaultTextHeight());
        }
        var orig = cm.charCoords(cm.getCursor(), &apos;local&apos;);
        motionArgs.repeat = repeat;
        var curEnd = motions.moveByDisplayLines(cm, motionArgs, vim);
        if (!curEnd) {
          return null;
        }
        var dest = cm.charCoords(curEnd, &apos;local&apos;);
        cm.scrollTo(null, scrollbox.top + dest.top - orig.top);
        return curEnd;
      },
      moveByWords: function(cm, motionArgs) {
        return moveToWord(cm, motionArgs.repeat, !!motionArgs.forward,
            !!motionArgs.wordEnd, !!motionArgs.bigWord);
      },
      moveTillCharacter: function(cm, motionArgs) {
        var repeat = motionArgs.repeat;
        var curEnd = moveToCharacter(cm, repeat, motionArgs.forward,
            motionArgs.selectedCharacter);
        var increment = motionArgs.forward ? -1 : 1;
        recordLastCharacterSearch(increment, motionArgs);
        if (!curEnd) return null;
        curEnd.ch += increment;
        return curEnd;
      },
      moveToCharacter: function(cm, motionArgs) {
        var repeat = motionArgs.repeat;
        recordLastCharacterSearch(0, motionArgs);
        return moveToCharacter(cm, repeat, motionArgs.forward,
            motionArgs.selectedCharacter) || cm.getCursor();
      },
      moveToSymbol: function(cm, motionArgs) {
        var repeat = motionArgs.repeat;
        return findSymbol(cm, repeat, motionArgs.forward,
            motionArgs.selectedCharacter) || cm.getCursor();
      },
      moveToColumn: function(cm, motionArgs, vim) {
        var repeat = motionArgs.repeat;
        // repeat is equivalent to which column we want to move to!
        vim.lastHPos = repeat - 1;
        vim.lastHSPos = cm.charCoords(cm.getCursor(),&apos;div&apos;).left;
        return moveToColumn(cm, repeat);
      },
      moveToEol: function(cm, motionArgs, vim) {
        var cur = cm.getCursor();
        vim.lastHPos = Infinity;
        var retval= Pos(cur.line + motionArgs.repeat - 1, Infinity);
        var end=cm.clipPos(retval);
        end.ch--;
        vim.lastHSPos = cm.charCoords(end,&apos;div&apos;).left;
        return retval;
      },
      moveToFirstNonWhiteSpaceCharacter: function(cm) {
        // Go to the start of the line where the text begins, or the end for
        // whitespace-only lines
        var cursor = cm.getCursor();
        return Pos(cursor.line,
                   findFirstNonWhiteSpaceCharacter(cm.getLine(cursor.line)));
      },
      moveToMatchedSymbol: function(cm) {
        var cursor = cm.getCursor();
        var line = cursor.line;
        var ch = cursor.ch;
        var lineText = cm.getLine(line);
        var symbol;
        do {
          symbol = lineText.charAt(ch++);
          if (symbol &amp;&amp; isMatchableSymbol(symbol)) {
            var style = cm.getTokenTypeAt(Pos(line, ch));
            if (style !== &quot;string&quot; &amp;&amp; style !== &quot;comment&quot;) {
              break;
            }
          }
        } while (symbol);
        if (symbol) {
          var matched = cm.findMatchingBracket(Pos(line, ch));
          return matched.to;
        } else {
          return cursor;
        }
      },
      moveToStartOfLine: function(cm) {
        var cursor = cm.getCursor();
        return Pos(cursor.line, 0);
      },
      moveToLineOrEdgeOfDocument: function(cm, motionArgs) {
        var lineNum = motionArgs.forward ? cm.lastLine() : cm.firstLine();
        if (motionArgs.repeatIsExplicit) {
          lineNum = motionArgs.repeat - cm.getOption(&apos;firstLineNumber&apos;);
        }
        return Pos(lineNum,
                   findFirstNonWhiteSpaceCharacter(cm.getLine(lineNum)));
      },
      textObjectManipulation: function(cm, motionArgs) {
        // TODO: lots of possible exceptions that can be thrown here. Try da(
        //     outside of a () block.

        // TODO: adding &lt;&gt; &gt;&lt; to this map doesn&apos;t work, presumably because
        // they&apos;re operators
        var mirroredPairs = {&apos;(&apos;: &apos;)&apos;, &apos;)&apos;: &apos;(&apos;,
                             &apos;{&apos;: &apos;}&apos;, &apos;}&apos;: &apos;{&apos;,
                             &apos;[&apos;: &apos;]&apos;, &apos;]&apos;: &apos;[&apos;};
        var selfPaired = {&apos;\&apos;&apos;: true, &apos;&quot;&apos;: true};

        var character = motionArgs.selectedCharacter;
        // &apos;b&apos; refers to  &apos;()&apos; block.
        // &apos;B&apos; refers to  &apos;{}&apos; block.
        if (character == &apos;b&apos;) {
          character = &apos;(&apos;;
        } else if (character == &apos;B&apos;) {
          character = &apos;{&apos;;
        }

        // Inclusive is the difference between a and i
        // TODO: Instead of using the additional text object map to perform text
        //     object operations, merge the map into the defaultKeyMap and use
        //     motionArgs to define behavior. Define separate entries for &apos;aw&apos;,
        //     &apos;iw&apos;, &apos;a[&apos;, &apos;i[&apos;, etc.
        var inclusive = !motionArgs.textObjectInner;

        var tmp;
        if (mirroredPairs[character]) {
          tmp = selectCompanionObject(cm, character, inclusive);
        } else if (selfPaired[character]) {
          tmp = findBeginningAndEnd(cm, character, inclusive);
        } else if (character === &apos;W&apos;) {
          tmp = expandWordUnderCursor(cm, inclusive, true /** forward */,
                                                     true /** bigWord */);
        } else if (character === &apos;w&apos;) {
          tmp = expandWordUnderCursor(cm, inclusive, true /** forward */,
                                                     false /** bigWord */);
        } else {
          // No text object defined for this, don&apos;t move.
          return null;
        }

        if (!cm.state.vim.visualMode) {
          return [tmp.start, tmp.end];
        } else {
          return expandSelection(cm, tmp.start, tmp.end);
        }
      },

      repeatLastCharacterSearch: function(cm, motionArgs) {
        var lastSearch = vimGlobalState.lastChararacterSearch;
        var repeat = motionArgs.repeat;
        var forward = motionArgs.forward === lastSearch.forward;
        var increment = (lastSearch.increment ? 1 : 0) * (forward ? -1 : 1);
        cm.moveH(-increment, &apos;char&apos;);
        motionArgs.inclusive = forward ? true : false;
        var curEnd = moveToCharacter(cm, repeat, forward, lastSearch.selectedCharacter);
        if (!curEnd) {
          cm.moveH(increment, &apos;char&apos;);
          return cm.getCursor();
        }
        curEnd.ch += increment;
        return curEnd;
      }
    };

    var operators = {
      change: function(cm, operatorArgs, vim) {
        var selections = cm.listSelections();
        var start = selections[0], end = selections[selections.length-1];
        var curStart = cursorIsBefore(start.anchor, start.head) ? start.anchor : start.head;
        var curEnd = cursorIsBefore(end.anchor, end.head) ? end.head : end.anchor;
        var text = cm.getSelection();
        var visualBlock = vim.visualBlock;
        if (vim.lastSelection &amp;&amp; !vim.visualMode) {
          visualBlock = vim.lastSelection.visualBlock ? true : visualBlock;
        }
        var lastInsertModeChanges = vimGlobalState.macroModeState.lastInsertModeChanges;
        lastInsertModeChanges.inVisualBlock = visualBlock;
        var replacement = new Array(selections.length).join(&apos;1&apos;).split(&apos;1&apos;);
        // save the selectionEnd mark
        var selectionEnd = vim.marks[&apos;&gt;&apos;] ? vim.marks[&apos;&gt;&apos;].find() : cm.getCursor(&apos;head&apos;);
        vimGlobalState.registerController.pushText(
            operatorArgs.registerName, &apos;change&apos;, text,
            operatorArgs.linewise);
        if (operatorArgs.linewise) {
          // &apos;C&apos; in visual block extends the block till eol for all lines
          if (visualBlock){
            var startLine = curStart.line;
            while (startLine &lt;= curEnd.line) {
              var endCh = lineLength(cm, startLine);
              var head = Pos(startLine, endCh);
              var anchor = Pos(startLine, curStart.ch);
              startLine++;
              cm.replaceRange(&apos;&apos;, anchor, head);
            }
          } else {
            // Push the next line back down, if there is a next line.
            replacement = &apos;\n&apos;;
            if (curEnd.line == curStart.line &amp;&amp; curEnd.line == cm.lastLine()) {
              replacement = &apos;&apos;;
            }
            cm.replaceRange(replacement, curStart, curEnd);
            cm.indentLine(curStart.line, &apos;smart&apos;);
            // null ch so setCursor moves to end of line.
            curStart.ch = null;
            cm.setCursor(curStart);
          }
        } else {
          // Exclude trailing whitespace if the range is not all whitespace.
          var text = cm.getRange(curStart, curEnd);
          if (!isWhiteSpaceString(text)) {
            var match = (/\s+$/).exec(text);
            if (match) {
              curEnd = offsetCursor(curEnd, 0, - match[0].length);
            }
          }
          if (visualBlock) {
            cm.replaceSelections(replacement);
          } else {
            cm.setCursor(curStart);
            cm.replaceRange(&apos;&apos;, curStart, curEnd);
          }
        }
        vim.marks[&apos;&gt;&apos;] = cm.setBookmark(selectionEnd);
        actions.enterInsertMode(cm, {}, cm.state.vim);
      },
      // delete is a javascript keyword.
      &apos;delete&apos;: function(cm, operatorArgs, vim) {
        var selections = cm.listSelections();
        var start = selections[0], end = selections[selections.length-1];
        var curStart = cursorIsBefore(start.anchor, start.head) ? start.anchor : start.head;
        var curEnd = cursorIsBefore(end.anchor, end.head) ? end.head : end.anchor;
        // Save the &apos;&gt;&apos; mark before cm.replaceRange clears it.
        var selectionEnd, selectionStart;
        var blockwise = vim.visualBlock;
        if (vim.visualMode) {
          selectionEnd = vim.marks[&apos;&gt;&apos;].find();
          selectionStart = vim.marks[&apos;&lt;&apos;].find();
        } else if (vim.lastSelection) {
          selectionEnd = vim.lastSelection.curStartMark.find();
          selectionStart = vim.lastSelection.curEndMark.find();
          blockwise = vim.lastSelection.visualBlock;
        }
        var text = cm.getSelection();
        vimGlobalState.registerController.pushText(
            operatorArgs.registerName, &apos;delete&apos;, text,
            operatorArgs.linewise, blockwise);
        var replacement = new Array(selections.length).join(&apos;1&apos;).split(&apos;1&apos;);
        // If the ending line is past the last line, inclusive, instead of
        // including the trailing \n, include the \n before the starting line
        if (operatorArgs.linewise &amp;&amp;
            curEnd.line == cm.lastLine() &amp;&amp; curStart.line == curEnd.line) {
          if (curEnd.line == 0) {
            curStart.ch = 0;
          }
          else {
            var tmp = copyCursor(curEnd);
            curStart.line--;
            curStart.ch = lineLength(cm, curStart.line);
            curEnd = tmp;
          }
          cm.replaceRange(&apos;&apos;, curStart, curEnd);
        } else {
          cm.replaceSelections(replacement);
        }
        // restore the saved bookmark
        if (selectionEnd) {
          var curStartMark = cm.setBookmark(selectionStart);
          var curEndMark = cm.setBookmark(selectionEnd);
          if (vim.visualMode) {
            vim.marks[&apos;&lt;&apos;] = curStartMark;
            vim.marks[&apos;&gt;&apos;] = curEndMark;
          } else {
            vim.lastSelection.curStartMark = curStartMark;
            vim.lastSelection.curEndMark = curEndMark;
          }
        }
        if (operatorArgs.linewise) {
          cm.setCursor(motions.moveToFirstNonWhiteSpaceCharacter(cm));
        } else {
          cm.setCursor(curStart);
        }
      },
      indent: function(cm, operatorArgs, vim, curStart, curEnd) {
        var startLine = curStart.line;
        var endLine = curEnd.line;
        // In visual mode, n&gt; shifts the selection right n times, instead of
        // shifting n lines right once.
        var repeat = (vim.visualMode) ? operatorArgs.repeat : 1;
        if (operatorArgs.linewise) {
          // The only way to delete a newline is to delete until the start of
          // the next line, so in linewise mode evalInput will include the next
          // line. We don&apos;t want this in indent, so we go back a line.
          endLine--;
        }
        for (var i = startLine; i &lt;= endLine; i++) {
          for (var j = 0; j &lt; repeat; j++) {
            cm.indentLine(i, operatorArgs.indentRight);
          }
        }
        cm.setCursor(curStart);
        cm.setCursor(motions.moveToFirstNonWhiteSpaceCharacter(cm));
      },
      swapcase: function(cm, operatorArgs, _vim, _curStart, _curEnd, _curOriginal) {
        var selections = cm.getSelections();
        var ranges = cm.listSelections();
        var swapped = [];
        for (var j = 0; j &lt; selections.length; j++) {
          var toSwap = selections[j];
          var text = &apos;&apos;;
          for (var i = 0; i &lt; toSwap.length; i++) {
            var character = toSwap.charAt(i);
            text += isUpperCase(character) ? character.toLowerCase() :
                character.toUpperCase();
          }
          swapped.push(text);
        }
        cm.replaceSelections(swapped);
        var curStart  = ranges[0].anchor;
        var curEnd = ranges[0].head;
        if (!operatorArgs.shouldMoveCursor) {
          cm.setCursor(cursorIsBefore(curStart, curEnd) ? curStart : curEnd);
        }
      },
      yank: function(cm, operatorArgs, vim, _curStart, _curEnd, curOriginal) {
        var text = cm.getSelection();
        vimGlobalState.registerController.pushText(
            operatorArgs.registerName, &apos;yank&apos;,
            text, operatorArgs.linewise, vim.visualBlock);
        cm.setCursor(curOriginal);
      }
    };

    var actions = {
      jumpListWalk: function(cm, actionArgs, vim) {
        if (vim.visualMode) {
          return;
        }
        var repeat = actionArgs.repeat;
        var forward = actionArgs.forward;
        var jumpList = vimGlobalState.jumpList;

        var mark = jumpList.move(cm, forward ? repeat : -repeat);
        var markPos = mark ? mark.find() : undefined;
        markPos = markPos ? markPos : cm.getCursor();
        cm.setCursor(markPos);
      },
      scroll: function(cm, actionArgs, vim) {
        if (vim.visualMode) {
          return;
        }
        var repeat = actionArgs.repeat || 1;
        var lineHeight = cm.defaultTextHeight();
        var top = cm.getScrollInfo().top;
        var delta = lineHeight * repeat;
        var newPos = actionArgs.forward ? top + delta : top - delta;
        var cursor = copyCursor(cm.getCursor());
        var cursorCoords = cm.charCoords(cursor, &apos;local&apos;);
        if (actionArgs.forward) {
          if (newPos &gt; cursorCoords.top) {
             cursor.line += (newPos - cursorCoords.top) / lineHeight;
             cursor.line = Math.ceil(cursor.line);
             cm.setCursor(cursor);
             cursorCoords = cm.charCoords(cursor, &apos;local&apos;);
             cm.scrollTo(null, cursorCoords.top);
          } else {
             // Cursor stays within bounds.  Just reposition the scroll window.
             cm.scrollTo(null, newPos);
          }
        } else {
          var newBottom = newPos + cm.getScrollInfo().clientHeight;
          if (newBottom &lt; cursorCoords.bottom) {
             cursor.line -= (cursorCoords.bottom - newBottom) / lineHeight;
             cursor.line = Math.floor(cursor.line);
             cm.setCursor(cursor);
             cursorCoords = cm.charCoords(cursor, &apos;local&apos;);
             cm.scrollTo(
                 null, cursorCoords.bottom - cm.getScrollInfo().clientHeight);
          } else {
             // Cursor stays within bounds.  Just reposition the scroll window.
             cm.scrollTo(null, newPos);
          }
        }
      },
      scrollToCursor: function(cm, actionArgs) {
        var lineNum = cm.getCursor().line;
        var charCoords = cm.charCoords(Pos(lineNum, 0), &apos;local&apos;);
        var height = cm.getScrollInfo().clientHeight;
        var y = charCoords.top;
        var lineHeight = charCoords.bottom - y;
        switch (actionArgs.position) {
          case &apos;center&apos;: y = y - (height / 2) + lineHeight;
            break;
          case &apos;bottom&apos;: y = y - height + lineHeight*1.4;
            break;
          case &apos;top&apos;: y = y + lineHeight*0.4;
            break;
        }
        cm.scrollTo(null, y);
      },
      replayMacro: function(cm, actionArgs, vim) {
        var registerName = actionArgs.selectedCharacter;
        var repeat = actionArgs.repeat;
        var macroModeState = vimGlobalState.macroModeState;
        if (registerName == &apos;@&apos;) {
          registerName = macroModeState.latestRegister;
        }
        while(repeat--){
          executeMacroRegister(cm, vim, macroModeState, registerName);
        }
      },
      enterMacroRecordMode: function(cm, actionArgs) {
        var macroModeState = vimGlobalState.macroModeState;
        var registerName = actionArgs.selectedCharacter;
        macroModeState.enterMacroRecordMode(cm, registerName);
      },
      enterInsertMode: function(cm, actionArgs, vim) {
        if (cm.getOption(&apos;readOnly&apos;)) { return; }
        vim.insertMode = true;
        vim.insertModeRepeat = actionArgs &amp;&amp; actionArgs.repeat || 1;
        var insertAt = (actionArgs) ? actionArgs.insertAt : null;
        if (vim.visualMode) {
          var selections = getSelectedAreaRange(cm, vim);
          var selectionStart = selections[0];
          var selectionEnd = selections[1];
        }
        if (insertAt == &apos;eol&apos;) {
          var cursor = cm.getCursor();
          cursor = Pos(cursor.line, lineLength(cm, cursor.line));
          cm.setCursor(cursor);
        } else if (insertAt == &apos;charAfter&apos;) {
          cm.setCursor(offsetCursor(cm.getCursor(), 0, 1));
        } else if (insertAt == &apos;firstNonBlank&apos;) {
          if (vim.visualMode &amp;&amp; !vim.visualBlock) {
            if (selectionEnd.line &lt; selectionStart.line) {
              cm.setCursor(selectionEnd);
            } else {
              selectionStart = Pos(selectionStart.line, 0);
              cm.setCursor(selectionStart);
            }
            cm.setCursor(motions.moveToFirstNonWhiteSpaceCharacter(cm));
          } else if (vim.visualBlock) {
            selectionEnd = Pos(selectionEnd.line, selectionStart.ch);
            cm.setCursor(selectionStart);
            selectBlock(cm, selectionEnd);
          } else {
            cm.setCursor(motions.moveToFirstNonWhiteSpaceCharacter(cm));
          }
        } else if (insertAt == &apos;endOfSelectedArea&apos;) {
          if (vim.visualBlock) {
            selectionStart = Pos(selectionStart.line, selectionEnd.ch);
            cm.setCursor(selectionStart);
            selectBlock(cm, selectionEnd);
          } else if (selectionEnd.line &lt; selectionStart.line) {
            selectionEnd = Pos(selectionStart.line, 0);
            cm.setCursor(selectionEnd);
          }
        } else if (insertAt == &apos;inplace&apos;) {
          if (vim.visualMode){
            return;
          }
        }
        cm.setOption(&apos;keyMap&apos;, &apos;vim-insert&apos;);
        cm.setOption(&apos;disableInput&apos;, false);
        if (actionArgs &amp;&amp; actionArgs.replace) {
          // Handle Replace-mode as a special case of insert mode.
          cm.toggleOverwrite(true);
          cm.setOption(&apos;keyMap&apos;, &apos;vim-replace&apos;);
          CodeMirror.signal(cm, &quot;vim-mode-change&quot;, {mode: &quot;replace&quot;});
        } else {
          cm.setOption(&apos;keyMap&apos;, &apos;vim-insert&apos;);
          CodeMirror.signal(cm, &quot;vim-mode-change&quot;, {mode: &quot;insert&quot;});
        }
        if (!vimGlobalState.macroModeState.isPlaying) {
          // Only record if not replaying.
          cm.on(&apos;change&apos;, onChange);
          CodeMirror.on(cm.getInputField(), &apos;keydown&apos;, onKeyEventTargetKeyDown);
        }
        if (vim.visualMode) {
          exitVisualMode(cm);
        }
      },
      toggleVisualMode: function(cm, actionArgs, vim) {
        var repeat = actionArgs.repeat;
        var curStart = cm.getCursor();
        var curEnd;
        var selections = cm.listSelections();
        // TODO: The repeat should actually select number of characters/lines
        //     equal to the repeat times the size of the previous visual
        //     operation.
        if (!vim.visualMode) {
          cm.on(&apos;mousedown&apos;, exitVisualMode);
          vim.visualMode = true;
          vim.visualLine = !!actionArgs.linewise;
          vim.visualBlock = !!actionArgs.blockwise;
          if (vim.visualLine) {
            curStart.ch = 0;
            curEnd = clipCursorToContent(
              cm, Pos(curStart.line + repeat - 1, lineLength(cm, curStart.line)),
              true /** includeLineBreak */);
          } else {
            curEnd = clipCursorToContent(
              cm, Pos(curStart.line, curStart.ch + repeat),
              true /** includeLineBreak */);
          }
          cm.setSelection(curStart, curEnd);
          CodeMirror.signal(cm, &quot;vim-mode-change&quot;, {mode: &quot;visual&quot;, subMode: vim.visualLine ? &quot;linewise&quot; : &quot;&quot;});
        } else {
          curStart = cm.getCursor(&apos;anchor&apos;);
          curEnd = cm.getCursor(&apos;head&apos;);
          if (vim.visualLine) {
            if (actionArgs.blockwise) {
              // This means Ctrl-V pressed in linewise visual
              vim.visualBlock = true;
              selectBlock(cm, curEnd);
              CodeMirror.signal(cm, &apos;vim-mode-change&apos;, {mode: &apos;visual&apos;, subMode: &apos;blockwise&apos;});
            } else if (!actionArgs.linewise) {
              // v pressed in linewise, switch to characterwise visual mode
              CodeMirror.signal(cm, &apos;vim-mode-change&apos;, {mode: &apos;visual&apos;});
            } else {
              exitVisualMode(cm);
            }
            vim.visualLine = false;
          } else if (vim.visualBlock) {
            if (actionArgs.linewise) {
              // Shift-V pressed in blockwise visual mode
              vim.visualLine = true;
              curStart = Pos(selections[0].anchor.line, 0);
              curEnd = Pos(selections[selections.length-1].anchor.line, lineLength(cm, selections[selections.length-1].anchor.line));
              cm.setSelection(curStart, curEnd);
              CodeMirror.signal(cm, &apos;vim-mode-change&apos;, {mode: &apos;visual&apos;, subMode: &apos;linewise&apos;});
            } else if (!actionArgs.blockwise) {
              // v pressed in blockwise mode, Switch to characterwise
              if (curEnd != selections[0].head) {
                curStart = selections[0].anchor;
              } else {
                curStart = selections[selections.length-1].anchor;
              }
              cm.setSelection(curStart, curEnd);
              CodeMirror.signal(cm, &apos;vim-mode-change&apos;, {mode: &apos;visual&apos;});
            } else {
              exitVisualMode(cm);
            }
            vim.visualBlock = false;
          } else if (actionArgs.linewise) {
              // Shift-V pressed in characterwise visual mode. Switch to linewise
              // visual mode instead of exiting visual mode.
              vim.visualLine = true;
              curStart.ch = cursorIsBefore(curStart, curEnd) ? 0 :
                lineLength(cm, curStart.line);
              curEnd.ch = cursorIsBefore(curStart, curEnd) ?
                lineLength(cm, curEnd.line) : 0;
              cm.setSelection(curStart, curEnd);
              CodeMirror.signal(cm, &quot;vim-mode-change&quot;, {mode: &quot;visual&quot;, subMode: &quot;linewise&quot;});
            } else if (actionArgs.blockwise) {
              vim.visualBlock = true;
              selectBlock(cm, curEnd);
              CodeMirror.signal(cm, &apos;vim-mode-change&apos;, {mode: &apos;visual&apos;, subMode: &apos;blockwise&apos;});
            } else {
              exitVisualMode(cm);
            }
        }
        updateMark(cm, vim, &apos;&lt;&apos;, cursorIsBefore(curStart, curEnd) ? curStart
            : curEnd);
        updateMark(cm, vim, &apos;&gt;&apos;, cursorIsBefore(curStart, curEnd) ? curEnd
            : curStart);
      },
      reselectLastSelection: function(cm, _actionArgs, vim) {
        var curStart = vim.marks[&apos;&lt;&apos;].find();
        var curEnd = vim.marks[&apos;&gt;&apos;].find();
        var lastSelection = vim.lastSelection;
        if (lastSelection) {
          // Set the selections as per last selection
          var selectionStart = lastSelection.curStartMark.find();
          var selectionEnd = lastSelection.curEndMark.find();
          var blockwise = lastSelection.visualBlock;
          // update last selection
          updateLastSelection(cm, vim, curStart, curEnd);
          if (blockwise) {
            cm.setCursor(selectionStart);
            selectionStart = selectBlock(cm, selectionEnd);
          } else {
            cm.setSelection(selectionStart, selectionEnd);
            selectionStart = cm.getCursor(&apos;anchor&apos;);
            selectionEnd = cm.getCursor(&apos;head&apos;);
          }
          if (vim.visualMode) {
            updateMark(cm, vim, &apos;&lt;&apos;, cursorIsBefore(selectionStart, selectionEnd) ? selectionStart
              : selectionEnd);
            updateMark(cm, vim, &apos;&gt;&apos;, cursorIsBefore(selectionStart, selectionEnd) ? selectionEnd
              : selectionStart);
          }
          // Last selection is updated now
          vim.visualMode = true;
          if (lastSelection.visualLine) {
            vim.visualLine = true;
            vim.visualBlock = false;
          } else if (lastSelection.visualBlock) {
            vim.visualLine = false;
            vim.visualBlock = true;
          } else {
            vim.visualBlock = vim.visualLine = false;
          }
          CodeMirror.signal(cm, &quot;vim-mode-change&quot;, {mode: &quot;visual&quot;, subMode: vim.visualLine ? &quot;linewise&quot; : &quot;&quot;});
        }
      },
      joinLines: function(cm, actionArgs, vim) {
        var curStart, curEnd;
        if (vim.visualMode) {
          curStart = cm.getCursor(&apos;anchor&apos;);
          curEnd = cm.getCursor(&apos;head&apos;);
          curEnd.ch = lineLength(cm, curEnd.line) - 1;
        } else {
          // Repeat is the number of lines to join. Minimum 2 lines.
          var repeat = Math.max(actionArgs.repeat, 2);
          curStart = cm.getCursor();
          curEnd = clipCursorToContent(cm, Pos(curStart.line + repeat - 1,
                                               Infinity));
        }
        var finalCh = 0;
        cm.operation(function() {
          for (var i = curStart.line; i &lt; curEnd.line; i++) {
            finalCh = lineLength(cm, curStart.line);
            var tmp = Pos(curStart.line + 1,
                          lineLength(cm, curStart.line + 1));
            var text = cm.getRange(curStart, tmp);
            text = text.replace(/\n\s*/g, &apos; &apos;);
            cm.replaceRange(text, curStart, tmp);
          }
          var curFinalPos = Pos(curStart.line, finalCh);
          cm.setCursor(curFinalPos);
        });
      },
      newLineAndEnterInsertMode: function(cm, actionArgs, vim) {
        vim.insertMode = true;
        var insertAt = copyCursor(cm.getCursor());
        if (insertAt.line === cm.firstLine() &amp;&amp; !actionArgs.after) {
          // Special case for inserting newline before start of document.
          cm.replaceRange(&apos;\n&apos;, Pos(cm.firstLine(), 0));
          cm.setCursor(cm.firstLine(), 0);
        } else {
          insertAt.line = (actionArgs.after) ? insertAt.line :
              insertAt.line - 1;
          insertAt.ch = lineLength(cm, insertAt.line);
          cm.setCursor(insertAt);
          var newlineFn = CodeMirror.commands.newlineAndIndentContinueComment ||
              CodeMirror.commands.newlineAndIndent;
          newlineFn(cm);
        }
        this.enterInsertMode(cm, { repeat: actionArgs.repeat }, vim);
      },
      paste: function(cm, actionArgs, vim) {
        var cur = copyCursor(cm.getCursor());
        var register = vimGlobalState.registerController.getRegister(
            actionArgs.registerName);
        var text = register.toString();
        if (!text) {
          return;
        }
        if (actionArgs.matchIndent) {
          // length that considers tabs and cm.options.tabSize
          var whitespaceLength = function(str) {
            var tabs = (str.split(&quot;\t&quot;).length - 1);
            var spaces = (str.split(&quot; &quot;).length - 1);
            return tabs * cm.options.tabSize + spaces * 1;
          };
          var currentLine = cm.getLine(cm.getCursor().line);
          var indent = whitespaceLength(currentLine.match(/^\s*/)[0]);
          // chomp last newline b/c don&apos;t want it to match /^\s*/gm
          var chompedText = text.replace(/\n$/, &apos;&apos;);
          var wasChomped = text !== chompedText;
          var firstIndent = whitespaceLength(text.match(/^\s*/)[0]);
          var text = chompedText.replace(/^\s*/gm, function(wspace) {
            var newIndent = indent + (whitespaceLength(wspace) - firstIndent);
            if (newIndent &lt; 0) {
              return &quot;&quot;;
            }
            else if (cm.options.indentWithTabs) {
              var quotient = Math.floor(newIndent / cm.options.tabSize);
              return Array(quotient + 1).join(&apos;\t&apos;);
            }
            else {
              return Array(newIndent + 1).join(&apos; &apos;);
            }
          });
          text += wasChomped ? &quot;\n&quot; : &quot;&quot;;
        }
        if (actionArgs.repeat &gt; 1) {
          var text = Array(actionArgs.repeat + 1).join(text);
        }
        var linewise = register.linewise;
        var blockwise = register.blockwise;
        if (linewise) {
          if(vim.visualMode) {
            text = vim.visualLine ? text.slice(0, -1) : &apos;\n&apos; + text.slice(0, text.length - 1) + &apos;\n&apos;;
          } else if (actionArgs.after) {
            // Move the newline at the end to the start instead, and paste just
            // before the newline character of the line we are on right now.
            text = &apos;\n&apos; + text.slice(0, text.length - 1);
            cur.ch = lineLength(cm, cur.line);
          } else {
            cur.ch = 0;
          }
        } else {
          if (blockwise) {
            text = text.split(&apos;\n&apos;);
            for (var i = 0; i &lt; text.length; i++) {
              text[i] = (text[i] == &apos;&apos;) ? &apos; &apos; : text[i];
            }
          }
          cur.ch += actionArgs.after ? 1 : 0;
        }
        var curPosFinal;
        var idx;
        if (vim.visualMode) {
          //  save the pasted text for reselection if the need arises
          vim.lastPastedText = text;
          var lastSelectionCurEnd;
          var selectedArea = getSelectedAreaRange(cm, vim);
          var selectionStart = selectedArea[0];
          var selectionEnd = selectedArea[1];
          var selectedText = cm.getSelection();
          var selections = cm.listSelections();
          var emptyStrings = new Array(selections.length).join(&apos;1&apos;).split(&apos;1&apos;);
          // save the curEnd marker before it get cleared due to cm.replaceRange.
          if (vim.lastSelection) {
            lastSelectionCurEnd = vim.lastSelection.curEndMark.find();
          }
          // push the previously selected text to unnamed register
          vimGlobalState.registerController.unnamedRegister.setText(selectedText);
          if (blockwise) {
            // first delete the selected text
            cm.replaceSelections(emptyStrings);
            // Set new selections as per the block length of the yanked text
            selectionEnd = Pos(selectionStart.line + text.length-1, selectionStart.ch);
            cm.setCursor(selectionStart);
            selectBlock(cm, selectionEnd);
            cm.replaceSelections(text);
            curPosFinal = selectionStart;
          } else if (vim.visualBlock) {
            cm.replaceSelections(emptyStrings);
            cm.setCursor(selectionStart);
            cm.replaceRange(text, selectionStart, selectionStart);
            curPosFinal = selectionStart;
          } else {
            cm.replaceRange(text, selectionStart, selectionEnd);
            curPosFinal = cm.posFromIndex(cm.indexFromPos(selectionStart) + text.length - 1);
          }
          // restore the the curEnd marker
          if(lastSelectionCurEnd) {
            vim.lastSelection.curEndMark = cm.setBookmark(lastSelectionCurEnd);
          }
          if (linewise) {
            curPosFinal.ch=0;
          }
        } else {
          if (blockwise) {
            cm.setCursor(cur);
            for (var i = 0; i &lt; text.length; i++) {
              var line = cur.line+i;
              if (line &gt; cm.lastLine()) {
                cm.replaceRange(&apos;\n&apos;,  Pos(line, 0));
              }
              var lastCh = lineLength(cm, line);
              if (lastCh &lt; cur.ch) {
                extendLineToColumn(cm, line, cur.ch);
              }
            }
            cm.setCursor(cur);
            selectBlock(cm, Pos(cur.line + text.length-1, cur.ch));
            cm.replaceSelections(text);
            curPosFinal = cur;
          } else {
            cm.replaceRange(text, cur);
            // Now fine tune the cursor to where we want it.
            if (linewise &amp;&amp; actionArgs.after) {
              curPosFinal = Pos(
              cur.line + 1,
              findFirstNonWhiteSpaceCharacter(cm.getLine(cur.line + 1)));
            } else if (linewise &amp;&amp; !actionArgs.after) {
              curPosFinal = Pos(
                cur.line,
                findFirstNonWhiteSpaceCharacter(cm.getLine(cur.line)));
            } else if (!linewise &amp;&amp; actionArgs.after) {
              idx = cm.indexFromPos(cur);
              curPosFinal = cm.posFromIndex(idx + text.length - 1);
            } else {
              idx = cm.indexFromPos(cur);
              curPosFinal = cm.posFromIndex(idx + text.length);
            }
          }
        }
        cm.setCursor(curPosFinal);
        if (vim.visualMode) {
          exitVisualMode(cm);
        }
      },
      undo: function(cm, actionArgs) {
        cm.operation(function() {
          repeatFn(cm, CodeMirror.commands.undo, actionArgs.repeat)();
          cm.setCursor(cm.getCursor(&apos;anchor&apos;));
        });
      },
      redo: function(cm, actionArgs) {
        repeatFn(cm, CodeMirror.commands.redo, actionArgs.repeat)();
      },
      setRegister: function(_cm, actionArgs, vim) {
        vim.inputState.registerName = actionArgs.selectedCharacter;
      },
      setMark: function(cm, actionArgs, vim) {
        var markName = actionArgs.selectedCharacter;
        updateMark(cm, vim, markName, cm.getCursor());
      },
      replace: function(cm, actionArgs, vim) {
        var replaceWith = actionArgs.selectedCharacter;
        var curStart = cm.getCursor();
        var replaceTo;
        var curEnd;
        var selections = cm.listSelections();
        if (vim.visualMode) {
          curStart = cm.getCursor(&apos;start&apos;);
          curEnd = cm.getCursor(&apos;end&apos;);
        } else {
          var line = cm.getLine(curStart.line);
          replaceTo = curStart.ch + actionArgs.repeat;
          if (replaceTo &gt; line.length) {
            replaceTo=line.length;
          }
          curEnd = Pos(curStart.line, replaceTo);
        }
        if (replaceWith==&apos;\n&apos;) {
          if (!vim.visualMode) cm.replaceRange(&apos;&apos;, curStart, curEnd);
          // special case, where vim help says to replace by just one line-break
          (CodeMirror.commands.newlineAndIndentContinueComment || CodeMirror.commands.newlineAndIndent)(cm);
        } else {
          var replaceWithStr = cm.getRange(curStart, curEnd);
          //replace all characters in range by selected, but keep linebreaks
          replaceWithStr = replaceWithStr.replace(/[^\n]/g, replaceWith);
          if (vim.visualBlock) {
            // Tabs are split in visua block before replacing
            var spaces = new Array(cm.options.tabSize+1).join(&apos; &apos;);
            replaceWithStr = cm.getSelection();
            replaceWithStr = replaceWithStr.replace(/\t/g, spaces).replace(/[^\n]/g, replaceWith).split(&apos;\n&apos;);
            cm.replaceSelections(replaceWithStr);
          } else {
            cm.replaceRange(replaceWithStr, curStart, curEnd);
          }
          if (vim.visualMode) {
            curStart = cursorIsBefore(selections[0].anchor, selections[0].head) ?
                         selections[0].anchor : selections[0].head;
            cm.setCursor(curStart);
            exitVisualMode(cm);
          } else {
            cm.setCursor(offsetCursor(curEnd, 0, -1));
          }
        }
      },
      incrementNumberToken: function(cm, actionArgs) {
        var cur = cm.getCursor();
        var lineStr = cm.getLine(cur.line);
        var re = /-?\d+/g;
        var match;
        var start;
        var end;
        var numberStr;
        var token;
        while ((match = re.exec(lineStr)) !== null) {
          token = match[0];
          start = match.index;
          end = start + token.length;
          if (cur.ch &lt; end)break;
        }
        if (!actionArgs.backtrack &amp;&amp; (end &lt;= cur.ch))return;
        if (token) {
          var increment = actionArgs.increase ? 1 : -1;
          var number = parseInt(token) + (increment * actionArgs.repeat);
          var from = Pos(cur.line, start);
          var to = Pos(cur.line, end);
          numberStr = number.toString();
          cm.replaceRange(numberStr, from, to);
        } else {
          return;
        }
        cm.setCursor(Pos(cur.line, start + numberStr.length - 1));
      },
      repeatLastEdit: function(cm, actionArgs, vim) {
        var lastEditInputState = vim.lastEditInputState;
        if (!lastEditInputState) { return; }
        var repeat = actionArgs.repeat;
        if (repeat &amp;&amp; actionArgs.repeatIsExplicit) {
          vim.lastEditInputState.repeatOverride = repeat;
        } else {
          repeat = vim.lastEditInputState.repeatOverride || repeat;
        }
        repeatLastEdit(cm, vim, repeat, false /** repeatForInsert */);
      },
      changeCase: function(cm, actionArgs, vim) {
        var selectionStart = getSelectedAreaRange(cm, vim)[0];
        var text = cm.getSelection();
        var lastSelectionCurEnd;
        var blockSelection;
        if (vim.lastSelection) {
        // save the curEnd marker to avoid its removal due to cm.replaceRange
          lastSelectionCurEnd = vim.lastSelection.curEndMark.find();
          blockSelection = vim.lastSelection.visualBlock;
        }
        var toLower = actionArgs.toLower;
        text = toLower ? text.toLowerCase() : text.toUpperCase();
        cm.replaceSelections(vim.visualBlock || blockSelection ? text.split(&apos;\n&apos;) : [text]);
        // restore the last selection curEnd marker
        if (lastSelectionCurEnd) {
          vim.lastSelection.curEndMark = cm.setBookmark(lastSelectionCurEnd);
        }
        cm.setCursor(selectionStart);
        if (vim.visualMode) {
          exitVisualMode(cm);
        }
      },
      exitInsertMode: exitInsertMode
    };

    /*
     * Below are miscellaneous utility functions used by vim.js
     */

    /**
     * Clips cursor to ensure that line is within the buffer&apos;s range
     * If includeLineBreak is true, then allow cur.ch == lineLength.
     */
    function clipCursorToContent(cm, cur, includeLineBreak) {
      var line = Math.min(Math.max(cm.firstLine(), cur.line), cm.lastLine() );
      var maxCh = lineLength(cm, line) - 1;
      maxCh = (includeLineBreak) ? maxCh + 1 : maxCh;
      var ch = Math.min(Math.max(0, cur.ch), maxCh);
      return Pos(line, ch);
    }
    function copyArgs(args) {
      var ret = {};
      for (var prop in args) {
        if (args.hasOwnProperty(prop)) {
          ret[prop] = args[prop];
        }
      }
      return ret;
    }
    function offsetCursor(cur, offsetLine, offsetCh) {
      return Pos(cur.line + offsetLine, cur.ch + offsetCh);
    }
    function commandMatches(keys, keyMap, context, inputState) {
      // Partial matches are not applied. They inform the key handler
      // that the current key sequence is a subsequence of a valid key
      // sequence, so that the key buffer is not cleared.
      var match, partial = [], full = [];
      for (var i = 0; i &lt; keyMap.length; i++) {
        var command = keyMap[i];
        if (context == &apos;insert&apos; &amp;&amp; command.context != &apos;insert&apos; ||
            command.context &amp;&amp; command.context != context ||
            inputState.operator &amp;&amp; command.type == &apos;action&apos; ||
            !(match = commandMatch(keys, command.keys))) { continue; }
        if (match == &apos;partial&apos;) { partial.push(command); }
        if (match == &apos;full&apos;) { full.push(command); }
      }
      return {
        partial: partial.length &amp;&amp; partial,
        full: full.length &amp;&amp; full
      };
    }
    function commandMatch(pressed, mapped) {
      if (mapped.slice(-11) == &apos;&lt;character&gt;&apos;) {
        // Last character matches anything.
        var prefixLen = mapped.length - 11;
        var pressedPrefix = pressed.slice(0, prefixLen);
        var mappedPrefix = mapped.slice(0, prefixLen);
        return pressedPrefix == mappedPrefix &amp;&amp; pressed.length &gt; prefixLen ? &apos;full&apos; :
               mappedPrefix.indexOf(pressedPrefix) == 0 ? &apos;partial&apos; : false;
      } else {
        return pressed == mapped ? &apos;full&apos; :
               mapped.indexOf(pressed) == 0 ? &apos;partial&apos; : false;
      }
    }
    function lastChar(keys) {
      var match = /^.*(&lt;[\w\-]+&gt;)$/.exec(keys);
      var selectedCharacter = match ? match[1] : keys.slice(-1);
      if (selectedCharacter.length &gt; 1){
        switch(selectedCharacter){
          case &apos;&lt;CR&gt;&apos;:
            selectedCharacter=&apos;\n&apos;;
            break;
          case &apos;&lt;Space&gt;&apos;:
            selectedCharacter=&apos; &apos;;
            break;
          default:
            break;
        }
      }
      return selectedCharacter;
    }
    function repeatFn(cm, fn, repeat) {
      return function() {
        for (var i = 0; i &lt; repeat; i++) {
          fn(cm);
        }
      };
    }
    function copyCursor(cur) {
      return Pos(cur.line, cur.ch);
    }
    function cursorEqual(cur1, cur2) {
      return cur1.ch == cur2.ch &amp;&amp; cur1.line == cur2.line;
    }
    function cursorIsBefore(cur1, cur2) {
      if (cur1.line &lt; cur2.line) {
        return true;
      }
      if (cur1.line == cur2.line &amp;&amp; cur1.ch &lt; cur2.ch) {
        return true;
      }
      return false;
    }
    function cursorMin(cur1, cur2) {
      return cursorIsBefore(cur1, cur2) ? cur1 : cur2;
    }
    function cursorMax(cur1, cur2) {
      return cursorIsBefore(cur1, cur2) ? cur2 : cur1;
    }
    function cursorIsBetween(cur1, cur2, cur3) {
      // returns true if cur2 is between cur1 and cur3.
      var cur1before2 = cursorIsBefore(cur1, cur2);
      var cur2before3 = cursorIsBefore(cur2, cur3);
      return cur1before2 &amp;&amp; cur2before3;
    }
    function lineLength(cm, lineNum) {
      return cm.getLine(lineNum).length;
    }
    function reverse(s){
      return s.split(&apos;&apos;).reverse().join(&apos;&apos;);
    }
    function trim(s) {
      if (s.trim) {
        return s.trim();
      }
      return s.replace(/^\s+|\s+$/g, &apos;&apos;);
    }
    function escapeRegex(s) {
      return s.replace(/([.?*+$\[\]\/\\(){}|\-])/g, &apos;\\$1&apos;);
    }
    function extendLineToColumn(cm, lineNum, column) {
      var endCh = lineLength(cm, lineNum);
      var spaces = new Array(column-endCh+1).join(&apos; &apos;);
      cm.setCursor(Pos(lineNum, endCh));
      cm.replaceRange(spaces, cm.getCursor());
    }
    // This functions selects a rectangular block
    // of text with selectionEnd as any of its corner
    // Height of block:
    // Difference in selectionEnd.line and first/last selection.line
    // Width of the block:
    // Distance between selectionEnd.ch and any(first considered here) selection.ch
    function selectBlock(cm, selectionEnd) {
      var selections = [], ranges = cm.listSelections();
      var firstRange = ranges[0].anchor, lastRange = ranges[ranges.length-1].anchor;
      var start, end, direction, selectionStart;
      var curEnd = cm.getCursor(&apos;head&apos;);
      var originalSelectionEnd = copyCursor(selectionEnd);
      start = firstRange.line;
      end = lastRange.line;
      if (selectionEnd.line &lt; curEnd.line) {
        direction = &apos;up&apos;;
      } else if (selectionEnd.line &gt; curEnd.line) {
        direction = &apos;down&apos;;
      } else {
        if (selectionEnd.ch != curEnd.ch) {
          direction = selectionEnd.ch &gt; curEnd.ch ? &apos;right&apos; : &apos;left&apos;;
        }
        selectionStart = cm.getCursor(&apos;anchor&apos;);
      }
      var primIndex = getIndex(ranges, curEnd);
      // sets to true when selectionEnd already lies inside the existing selections
      selectionEnd = cm.clipPos(selectionEnd);
      var contains = getIndex(ranges, selectionEnd) &lt; 0 ? false : true;
      var isClipped = !cursorEqual(originalSelectionEnd, selectionEnd);
      // This function helps to check selection crossing
      // in case of short lines.
      var processSelectionCrossing = function() {
        if (isClipped) {
          if (curEnd.ch &gt;= selectionStart.ch) {
            selectionStart.ch++;
          }
        } else if (curEnd.ch == lineLength(cm, curEnd.line)) {
          if (cursorEqual(ranges[primIndex].anchor, ranges[primIndex].head) &amp;&amp; ranges.length&gt;1) {
            if (direction == &apos;up&apos;) {
              if (contains || primIndex&gt;0) {
              start = firstRange.line;
              end = selectionEnd.line;
              selectionStart = ranges[primIndex-1].anchor;
            }
          } else {
              if (contains || primIndex == 0) {
                end = lastRange.line;
                start = selectionEnd.line;
                selectionStart = ranges[primIndex+1].anchor;
              }
            }
            if (selectionEnd.ch &gt;= selectionStart.ch) {
              selectionStart.ch--;
            }
          }
        }
      };
      switch(direction) {
        case &apos;up&apos;:
          start = contains ? firstRange.line : selectionEnd.line;
          end = contains ? selectionEnd.line : lastRange.line;
          selectionStart = lastRange;
          processSelectionCrossing();
          break;
        case &apos;down&apos;:
          start = contains ? selectionEnd.line : firstRange.line;
          end = contains ? lastRange.line : selectionEnd.line;
          selectionStart = firstRange;
          processSelectionCrossing();
          break;
        case &apos;left&apos;:
          if ((selectionEnd.ch &lt;= selectionStart.ch) &amp;&amp; (curEnd.ch &gt; selectionStart.ch)) {
            selectionStart.ch++;
            selectionEnd.ch--;
          }
          break;
        case &apos;right&apos;:
          if ((selectionStart.ch &lt;= selectionEnd.ch) &amp;&amp; (curEnd.ch &lt; selectionStart.ch)) {
            selectionStart.ch--;
            selectionEnd.ch++;
          }
          break;
        default:
          start = selectionStart.line;
          end = selectionEnd.line;
      }
      while (start &lt;= end) {
        var anchor = {line: start, ch: selectionStart.ch};
        var head = {line: start, ch: selectionEnd.ch};
        var range = {anchor: anchor, head: head};
        selections.push(range);
        if (cursorEqual(head, selectionEnd)) {
            primIndex = selections.indexOf(range);
        }
        start++;
      }
      // Update selectionEnd and selectionStart
      // after selection crossing
      selectionEnd.ch = selections[0].head.ch;
      selectionStart.ch = selections[0].anchor.ch;
      if (cursorEqual(selectionEnd, selections[0].head)) {
        selectionStart.line = selections[selections.length-1].anchor.line;
      } else {
        selectionStart.line = selections[0].anchor.line;
      }
      cm.setSelections(selections, primIndex);
      return selectionStart;
    }
    // getIndex returns the index of the cursor in the selections.
    function getIndex(ranges, cursor, end) {
      var pos = -1;
      for (var i = 0; i &lt; ranges.length; i++) {
        var atAnchor = cursorEqual(ranges[i].anchor, cursor);
        var atHead = cursorEqual(ranges[i].head, cursor);
        if (end == &apos;head&apos;) {
        pos = atHead ? i : pos;
        } else if (end == &apos;anchor&apos;) {
          pos = atAnchor ? i : pos;
        } else {
          pos = (atAnchor || atHead) ? i : pos;
        }
      }
      return pos;
    }
    function getSelectedAreaRange(cm, vim) {
      var lastSelection = vim.lastSelection;
      var getCurrentSelectedAreaRange = function() {
        var selections = cm.listSelections();
        var start =  selections[0];
        var end = selections[selections.length-1];
        var selectionStart = cursorIsBefore(start.anchor, start.head) ? start.anchor : start.head;
        var selectionEnd = cursorIsBefore(end.anchor, end.head) ? end.head : end.anchor;
        return [selectionStart, selectionEnd];
      };
      var getLastSelectedAreaRange = function() {
        var selectionStart = cm.getCursor();
        var selectionEnd = cm.getCursor();
        var block = lastSelection.visualBlock;
        if (block) {
          var width = block.width;
          var height = block.height;
          selectionEnd = Pos(selectionStart.line + height, selectionStart.ch + width);
          var selections = [];
          // selectBlock creates a &apos;proper&apos; rectangular block.
          // We do not want that in all cases, so we manually set selections.
          for (var i = selectionStart.line; i &lt; selectionEnd.line; i++) {
            var anchor = Pos(i, selectionStart.ch);
            var head = Pos(i, selectionEnd.ch);
            var range = {anchor: anchor, head: head};
            selections.push(range);
          }
          cm.setSelections(selections);
        } else {
          var start = lastSelection.curStartMark.find();
          var end = lastSelection.curEndMark.find();
          var line = end.line - start.line;
          var ch = end.ch - start.ch;
          selectionEnd = {line: selectionEnd.line + line, ch: line ? selectionEnd.ch : ch + selectionEnd.ch};
          if (lastSelection.visualLine) {
            selectionStart = Pos(selectionStart.line, 0);
            selectionEnd = Pos(selectionEnd.line, lineLength(cm, selectionEnd.line));
          }
          cm.setSelection(selectionStart, selectionEnd);
        }
        return [selectionStart, selectionEnd];
      };
      if (!vim.visualMode) {
      // In case of replaying the action.
        return getLastSelectedAreaRange();
      } else {
        return getCurrentSelectedAreaRange();
      }
    }
    function updateLastSelection(cm, vim, selectionStart, selectionEnd) {
      if (!selectionStart || !selectionEnd) {
        selectionStart = vim.marks[&apos;&lt;&apos;].find() || cm.getCursor(&apos;anchor&apos;);
        selectionEnd = vim.marks[&apos;&gt;&apos;].find() || cm.getCursor(&apos;head&apos;);
      }
      // To accommodate the effect of lastPastedText in the last selection
      if (vim.lastPastedText) {
        selectionEnd = cm.posFromIndex(cm.indexFromPos(selectionStart) + vim.lastPastedText.length);
        vim.lastPastedText = null;
      }
      var ranges = cm.listSelections();
      // This check ensures to set the cursor
      // position where we left off in previous selection
      var swap = getIndex(ranges, selectionStart, &apos;head&apos;) &gt; -1;
      if (vim.visualBlock) {
        var height = Math.abs(selectionStart.line - selectionEnd.line)+1;
        var width =  Math.abs(selectionStart.ch - selectionEnd.ch);
        var block = {height: height, width: width};
      }
      // can&apos;t use selection state here because yank has already reset its cursor
      // Also, Bookmarks make the visual selections robust to edit operations
      vim.lastSelection = {&apos;curStartMark&apos;: cm.setBookmark(swap ? selectionEnd : selectionStart),
                           &apos;curEndMark&apos;: cm.setBookmark(swap ? selectionStart : selectionEnd),
                           &apos;visualMode&apos;: vim.visualMode,
                           &apos;visualLine&apos;: vim.visualLine,
                           &apos;visualBlock&apos;: block};
    }
    function expandSelection(cm, start, end) {
      var head = cm.getCursor(&apos;head&apos;);
      var anchor = cm.getCursor(&apos;anchor&apos;);
      var tmp;
      if (cursorIsBefore(end, start)) {
        tmp = end;
        end = start;
        start = tmp;
      }
      if (cursorIsBefore(head, anchor)) {
        head = cursorMin(start, head);
        anchor = cursorMax(anchor, end);
      } else {
        anchor = cursorMin(start, anchor);
        head = cursorMax(head, end);
      }
      return [anchor, head];
    }
    function getHead(cm) {
      var cur = cm.getCursor(&apos;head&apos;);
      if (cm.getSelection().length == 1) {
        // Small corner case when only 1 character is selected. The &quot;real&quot;
        // head is the left of head and anchor.
        cur = cursorMin(cur, cm.getCursor(&apos;anchor&apos;));
      }
      return cur;
    }

    function exitVisualMode(cm) {
      cm.off(&apos;mousedown&apos;, exitVisualMode);
      var vim = cm.state.vim;
      var selectionStart = cm.getCursor(&apos;anchor&apos;);
      var selectionEnd = cm.getCursor(&apos;head&apos;);
      // hack to place the cursor at the right place
      // in case of visual block
      if (vim.visualBlock &amp;&amp; (cursorIsBefore(selectionStart, selectionEnd))) {
          selectionEnd.ch--;
      }
      updateLastSelection(cm, vim);
      vim.visualMode = false;
      vim.visualLine = false;
      vim.visualBlock = false;
      if (!cursorEqual(selectionStart, selectionEnd)) {
        cm.setCursor(clipCursorToContent(cm, selectionEnd));
      }
      CodeMirror.signal(cm, &quot;vim-mode-change&quot;, {mode: &quot;normal&quot;});
      if (vim.fakeCursor) {
        vim.fakeCursor.clear();
      }
    }

    // Remove any trailing newlines from the selection. For
    // example, with the caret at the start of the last word on the line,
    // &apos;dw&apos; should word, but not the newline, while &apos;w&apos; should advance the
    // caret to the first character of the next line.
    function clipToLine(cm, curStart, curEnd) {
      var selection = cm.getRange(curStart, curEnd);
      // Only clip if the selection ends with trailing newline + whitespace
      if (/\n\s*$/.test(selection)) {
        var lines = selection.split(&apos;\n&apos;);
        // We know this is all whitepsace.
        lines.pop();

        // Cases:
        // 1. Last word is an empty line - do not clip the trailing &apos;\n&apos;
        // 2. Last word is not an empty line - clip the trailing &apos;\n&apos;
        var line;
        // Find the line containing the last word, and clip all whitespace up
        // to it.
        for (var line = lines.pop(); lines.length &gt; 0 &amp;&amp; line &amp;&amp; isWhiteSpaceString(line); line = lines.pop()) {
          curEnd.line--;
          curEnd.ch = 0;
        }
        // If the last word is not an empty line, clip an additional newline
        if (line) {
          curEnd.line--;
          curEnd.ch = lineLength(cm, curEnd.line);
        } else {
          curEnd.ch = 0;
        }
      }
    }

    // Expand the selection to line ends.
    function expandSelectionToLine(_cm, curStart, curEnd) {
      curStart.ch = 0;
      curEnd.ch = 0;
      curEnd.line++;
    }

    function findFirstNonWhiteSpaceCharacter(text) {
      if (!text) {
        return 0;
      }
      var firstNonWS = text.search(/\S/);
      return firstNonWS == -1 ? text.length : firstNonWS;
    }

    function expandWordUnderCursor(cm, inclusive, _forward, bigWord, noSymbol) {
      var cur = getHead(cm);
      var line = cm.getLine(cur.line);
      var idx = cur.ch;

      // Seek to first word or non-whitespace character, depending on if
      // noSymbol is true.
      var textAfterIdx = line.substring(idx);
      var firstMatchedChar;
      if (noSymbol) {
        firstMatchedChar = textAfterIdx.search(/\w/);
      } else {
        firstMatchedChar = textAfterIdx.search(/\S/);
      }
      if (firstMatchedChar == -1) {
        return null;
      }
      idx += firstMatchedChar;
      textAfterIdx = line.substring(idx);
      var textBeforeIdx = line.substring(0, idx);

      var matchRegex;
      // Greedy matchers for the &quot;word&quot; we are trying to expand.
      if (bigWord) {
        matchRegex = /^\S+/;
      } else {
        if ((/\w/).test(line.charAt(idx))) {
          matchRegex = /^\w+/;
        } else {
          matchRegex = /^[^\w\s]+/;
        }
      }

      var wordAfterRegex = matchRegex.exec(textAfterIdx);
      var wordStart = idx;
      var wordEnd = idx + wordAfterRegex[0].length;
      // TODO: Find a better way to do this. It will be slow on very long lines.
      var revTextBeforeIdx = reverse(textBeforeIdx);
      var wordBeforeRegex = matchRegex.exec(revTextBeforeIdx);
      if (wordBeforeRegex) {
        wordStart -= wordBeforeRegex[0].length;
      }

      if (inclusive) {
        // If present, trim all whitespace after word.
        // Otherwise, trim all whitespace before word.
        var textAfterWordEnd = line.substring(wordEnd);
        var whitespacesAfterWord = textAfterWordEnd.match(/^\s*/)[0].length;
        if (whitespacesAfterWord &gt; 0) {
          wordEnd += whitespacesAfterWord;
        } else {
          var revTrim = revTextBeforeIdx.length - wordStart;
          var textBeforeWordStart = revTextBeforeIdx.substring(revTrim);
          var whitespacesBeforeWord = textBeforeWordStart.match(/^\s*/)[0].length;
          wordStart -= whitespacesBeforeWord;
        }
      }

      return { start: Pos(cur.line, wordStart),
               end: Pos(cur.line, wordEnd) };
    }

    function recordJumpPosition(cm, oldCur, newCur) {
      if (!cursorEqual(oldCur, newCur)) {
        vimGlobalState.jumpList.add(cm, oldCur, newCur);
      }
    }

    function recordLastCharacterSearch(increment, args) {
        vimGlobalState.lastChararacterSearch.increment = increment;
        vimGlobalState.lastChararacterSearch.forward = args.forward;
        vimGlobalState.lastChararacterSearch.selectedCharacter = args.selectedCharacter;
    }

    var symbolToMode = {
        &apos;(&apos;: &apos;bracket&apos;, &apos;)&apos;: &apos;bracket&apos;, &apos;{&apos;: &apos;bracket&apos;, &apos;}&apos;: &apos;bracket&apos;,
        &apos;[&apos;: &apos;section&apos;, &apos;]&apos;: &apos;section&apos;,
        &apos;*&apos;: &apos;comment&apos;, &apos;/&apos;: &apos;comment&apos;,
        &apos;m&apos;: &apos;method&apos;, &apos;M&apos;: &apos;method&apos;,
        &apos;#&apos;: &apos;preprocess&apos;
    };
    var findSymbolModes = {
      bracket: {
        isComplete: function(state) {
          if (state.nextCh === state.symb) {
            state.depth++;
            if (state.depth &gt;= 1)return true;
          } else if (state.nextCh === state.reverseSymb) {
            state.depth--;
          }
          return false;
        }
      },
      section: {
        init: function(state) {
          state.curMoveThrough = true;
          state.symb = (state.forward ? &apos;]&apos; : &apos;[&apos;) === state.symb ? &apos;{&apos; : &apos;}&apos;;
        },
        isComplete: function(state) {
          return state.index === 0 &amp;&amp; state.nextCh === state.symb;
        }
      },
      comment: {
        isComplete: function(state) {
          var found = state.lastCh === &apos;*&apos; &amp;&amp; state.nextCh === &apos;/&apos;;
          state.lastCh = state.nextCh;
          return found;
        }
      },
      // TODO: The original Vim implementation only operates on level 1 and 2.
      // The current implementation doesn&apos;t check for code block level and
      // therefore it operates on any levels.
      method: {
        init: function(state) {
          state.symb = (state.symb === &apos;m&apos; ? &apos;{&apos; : &apos;}&apos;);
          state.reverseSymb = state.symb === &apos;{&apos; ? &apos;}&apos; : &apos;{&apos;;
        },
        isComplete: function(state) {
          if (state.nextCh === state.symb)return true;
          return false;
        }
      },
      preprocess: {
        init: function(state) {
          state.index = 0;
        },
        isComplete: function(state) {
          if (state.nextCh === &apos;#&apos;) {
            var token = state.lineText.match(/#(\w+)/)[1];
            if (token === &apos;endif&apos;) {
              if (state.forward &amp;&amp; state.depth === 0) {
                return true;
              }
              state.depth++;
            } else if (token === &apos;if&apos;) {
              if (!state.forward &amp;&amp; state.depth === 0) {
                return true;
              }
              state.depth--;
            }
            if (token === &apos;else&apos; &amp;&amp; state.depth === 0)return true;
          }
          return false;
        }
      }
    };
    function findSymbol(cm, repeat, forward, symb) {
      var cur = copyCursor(cm.getCursor());
      var increment = forward ? 1 : -1;
      var endLine = forward ? cm.lineCount() : -1;
      var curCh = cur.ch;
      var line = cur.line;
      var lineText = cm.getLine(line);
      var state = {
        lineText: lineText,
        nextCh: lineText.charAt(curCh),
        lastCh: null,
        index: curCh,
        symb: symb,
        reverseSymb: (forward ?  { &apos;)&apos;: &apos;(&apos;, &apos;}&apos;: &apos;{&apos; } : { &apos;(&apos;: &apos;)&apos;, &apos;{&apos;: &apos;}&apos; })[symb],
        forward: forward,
        depth: 0,
        curMoveThrough: false
      };
      var mode = symbolToMode[symb];
      if (!mode)return cur;
      var init = findSymbolModes[mode].init;
      var isComplete = findSymbolModes[mode].isComplete;
      if (init) { init(state); }
      while (line !== endLine &amp;&amp; repeat) {
        state.index += increment;
        state.nextCh = state.lineText.charAt(state.index);
        if (!state.nextCh) {
          line += increment;
          state.lineText = cm.getLine(line) || &apos;&apos;;
          if (increment &gt; 0) {
            state.index = 0;
          } else {
            var lineLen = state.lineText.length;
            state.index = (lineLen &gt; 0) ? (lineLen-1) : 0;
          }
          state.nextCh = state.lineText.charAt(state.index);
        }
        if (isComplete(state)) {
          cur.line = line;
          cur.ch = state.index;
          repeat--;
        }
      }
      if (state.nextCh || state.curMoveThrough) {
        return Pos(line, state.index);
      }
      return cur;
    }

    /*
     * Returns the boundaries of the next word. If the cursor in the middle of
     * the word, then returns the boundaries of the current word, starting at
     * the cursor. If the cursor is at the start/end of a word, and we are going
     * forward/backward, respectively, find the boundaries of the next word.
     *
     * @param {CodeMirror} cm CodeMirror object.
     * @param {Cursor} cur The cursor position.
     * @param {boolean} forward True to search forward. False to search
     *     backward.
     * @param {boolean} bigWord True if punctuation count as part of the word.
     *     False if only [a-zA-Z0-9] characters count as part of the word.
     * @param {boolean} emptyLineIsWord True if empty lines should be treated
     *     as words.
     * @return {Object{from:number, to:number, line: number}} The boundaries of
     *     the word, or null if there are no more words.
     */
    function findWord(cm, cur, forward, bigWord, emptyLineIsWord) {
      var lineNum = cur.line;
      var pos = cur.ch;
      var line = cm.getLine(lineNum);
      var dir = forward ? 1 : -1;
      var regexps = bigWord ? bigWordRegexp : wordRegexp;

      if (emptyLineIsWord &amp;&amp; line == &apos;&apos;) {
        lineNum += dir;
        line = cm.getLine(lineNum);
        if (!isLine(cm, lineNum)) {
          return null;
        }
        pos = (forward) ? 0 : line.length;
      }

      while (true) {
        if (emptyLineIsWord &amp;&amp; line == &apos;&apos;) {
          return { from: 0, to: 0, line: lineNum };
        }
        var stop = (dir &gt; 0) ? line.length : -1;
        var wordStart = stop, wordEnd = stop;
        // Find bounds of next word.
        while (pos != stop) {
          var foundWord = false;
          for (var i = 0; i &lt; regexps.length &amp;&amp; !foundWord; ++i) {
            if (regexps[i].test(line.charAt(pos))) {
              wordStart = pos;
              // Advance to end of word.
              while (pos != stop &amp;&amp; regexps[i].test(line.charAt(pos))) {
                pos += dir;
              }
              wordEnd = pos;
              foundWord = wordStart != wordEnd;
              if (wordStart == cur.ch &amp;&amp; lineNum == cur.line &amp;&amp;
                  wordEnd == wordStart + dir) {
                // We started at the end of a word. Find the next one.
                continue;
              } else {
                return {
                  from: Math.min(wordStart, wordEnd + 1),
                  to: Math.max(wordStart, wordEnd),
                  line: lineNum };
              }
            }
          }
          if (!foundWord) {
            pos += dir;
          }
        }
        // Advance to next/prev line.
        lineNum += dir;
        if (!isLine(cm, lineNum)) {
          return null;
        }
        line = cm.getLine(lineNum);
        pos = (dir &gt; 0) ? 0 : line.length;
      }
      // Should never get here.
      throw new Error(&apos;The impossible happened.&apos;);
    }

    /**
     * @param {CodeMirror} cm CodeMirror object.
     * @param {int} repeat Number of words to move past.
     * @param {boolean} forward True to search forward. False to search
     *     backward.
     * @param {boolean} wordEnd True to move to end of word. False to move to
     *     beginning of word.
     * @param {boolean} bigWord True if punctuation count as part of the word.
     *     False if only alphabet characters count as part of the word.
     * @return {Cursor} The position the cursor should move to.
     */
    function moveToWord(cm, repeat, forward, wordEnd, bigWord) {
      var cur = cm.getCursor();
      var curStart = copyCursor(cur);
      var words = [];
      if (forward &amp;&amp; !wordEnd || !forward &amp;&amp; wordEnd) {
        repeat++;
      }
      // For &apos;e&apos;, empty lines are not considered words, go figure.
      var emptyLineIsWord = !(forward &amp;&amp; wordEnd);
      for (var i = 0; i &lt; repeat; i++) {
        var word = findWord(cm, cur, forward, bigWord, emptyLineIsWord);
        if (!word) {
          var eodCh = lineLength(cm, cm.lastLine());
          words.push(forward
              ? {line: cm.lastLine(), from: eodCh, to: eodCh}
              : {line: 0, from: 0, to: 0});
          break;
        }
        words.push(word);
        cur = Pos(word.line, forward ? (word.to - 1) : word.from);
      }
      var shortCircuit = words.length != repeat;
      var firstWord = words[0];
      var lastWord = words.pop();
      if (forward &amp;&amp; !wordEnd) {
        // w
        if (!shortCircuit &amp;&amp; (firstWord.from != curStart.ch || firstWord.line != curStart.line)) {
          // We did not start in the middle of a word. Discard the extra word at the end.
          lastWord = words.pop();
        }
        return Pos(lastWord.line, lastWord.from);
      } else if (forward &amp;&amp; wordEnd) {
        return Pos(lastWord.line, lastWord.to - 1);
      } else if (!forward &amp;&amp; wordEnd) {
        // ge
        if (!shortCircuit &amp;&amp; (firstWord.to != curStart.ch || firstWord.line != curStart.line)) {
          // We did not start in the middle of a word. Discard the extra word at the end.
          lastWord = words.pop();
        }
        return Pos(lastWord.line, lastWord.to);
      } else {
        // b
        return Pos(lastWord.line, lastWord.from);
      }
    }

    function moveToCharacter(cm, repeat, forward, character) {
      var cur = cm.getCursor();
      var start = cur.ch;
      var idx;
      for (var i = 0; i &lt; repeat; i ++) {
        var line = cm.getLine(cur.line);
        idx = charIdxInLine(start, line, character, forward, true);
        if (idx == -1) {
          return null;
        }
        start = idx;
      }
      return Pos(cm.getCursor().line, idx);
    }

    function moveToColumn(cm, repeat) {
      // repeat is always &gt;= 1, so repeat - 1 always corresponds
      // to the column we want to go to.
      var line = cm.getCursor().line;
      return clipCursorToContent(cm, Pos(line, repeat - 1));
    }

    function updateMark(cm, vim, markName, pos) {
      if (!inArray(markName, validMarks)) {
        return;
      }
      if (vim.marks[markName]) {
        vim.marks[markName].clear();
      }
      vim.marks[markName] = cm.setBookmark(pos);
    }

    function charIdxInLine(start, line, character, forward, includeChar) {
      // Search for char in line.
      // motion_options: {forward, includeChar}
      // If includeChar = true, include it too.
      // If forward = true, search forward, else search backwards.
      // If char is not found on this line, do nothing
      var idx;
      if (forward) {
        idx = line.indexOf(character, start + 1);
        if (idx != -1 &amp;&amp; !includeChar) {
          idx -= 1;
        }
      } else {
        idx = line.lastIndexOf(character, start - 1);
        if (idx != -1 &amp;&amp; !includeChar) {
          idx += 1;
        }
      }
      return idx;
    }

    // TODO: perhaps this finagling of start and end positions belonds
    // in codmirror/replaceRange?
    function selectCompanionObject(cm, symb, inclusive) {
      var cur = getHead(cm), start, end;

      var bracketRegexp = ({
        &apos;(&apos;: /[()]/, &apos;)&apos;: /[()]/,
        &apos;[&apos;: /[[\]]/, &apos;]&apos;: /[[\]]/,
        &apos;{&apos;: /[{}]/, &apos;}&apos;: /[{}]/})[symb];
      var openSym = ({
        &apos;(&apos;: &apos;(&apos;, &apos;)&apos;: &apos;(&apos;,
        &apos;[&apos;: &apos;[&apos;, &apos;]&apos;: &apos;[&apos;,
        &apos;{&apos;: &apos;{&apos;, &apos;}&apos;: &apos;{&apos;})[symb];
      var curChar = cm.getLine(cur.line).charAt(cur.ch);
      // Due to the behavior of scanForBracket, we need to add an offset if the
      // cursor is on a matching open bracket.
      var offset = curChar === openSym ? 1 : 0;

      start = cm.scanForBracket(Pos(cur.line, cur.ch + offset), -1, null, {&apos;bracketRegex&apos;: bracketRegexp});
      end = cm.scanForBracket(Pos(cur.line, cur.ch + offset), 1, null, {&apos;bracketRegex&apos;: bracketRegexp});

      if (!start || !end) {
        return { start: cur, end: cur };
      }

      start = start.pos;
      end = end.pos;

      if ((start.line == end.line &amp;&amp; start.ch &gt; end.ch)
          || (start.line &gt; end.line)) {
        var tmp = start;
        start = end;
        end = tmp;
      }

      if (inclusive) {
        end.ch += 1;
      } else {
        start.ch += 1;
      }

      return { start: start, end: end };
    }

    // Takes in a symbol and a cursor and tries to simulate text objects that
    // have identical opening and closing symbols
    // TODO support across multiple lines
    function findBeginningAndEnd(cm, symb, inclusive) {
      var cur = copyCursor(getHead(cm));
      var line = cm.getLine(cur.line);
      var chars = line.split(&apos;&apos;);
      var start, end, i, len;
      var firstIndex = chars.indexOf(symb);

      // the decision tree is to always look backwards for the beginning first,
      // but if the cursor is in front of the first instance of the symb,
      // then move the cursor forward
      if (cur.ch &lt; firstIndex) {
        cur.ch = firstIndex;
        // Why is this line even here???
        // cm.setCursor(cur.line, firstIndex+1);
      }
      // otherwise if the cursor is currently on the closing symbol
      else if (firstIndex &lt; cur.ch &amp;&amp; chars[cur.ch] == symb) {
        end = cur.ch; // assign end to the current cursor
        --cur.ch; // make sure to look backwards
      }

      // if we&apos;re currently on the symbol, we&apos;ve got a start
      if (chars[cur.ch] == symb &amp;&amp; !end) {
        start = cur.ch + 1; // assign start to ahead of the cursor
      } else {
        // go backwards to find the start
        for (i = cur.ch; i &gt; -1 &amp;&amp; !start; i--) {
          if (chars[i] == symb) {
            start = i + 1;
          }
        }
      }

      // look forwards for the end symbol
      if (start &amp;&amp; !end) {
        for (i = start, len = chars.length; i &lt; len &amp;&amp; !end; i++) {
          if (chars[i] == symb) {
            end = i;
          }
        }
      }

      // nothing found
      if (!start || !end) {
        return { start: cur, end: cur };
      }

      // include the symbols
      if (inclusive) {
        --start; ++end;
      }

      return {
        start: Pos(cur.line, start),
        end: Pos(cur.line, end)
      };
    }

    // Search functions
    defineOption(&apos;pcre&apos;, true, &apos;boolean&apos;);
    function SearchState() {}
    SearchState.prototype = {
      getQuery: function() {
        return vimGlobalState.query;
      },
      setQuery: function(query) {
        vimGlobalState.query = query;
      },
      getOverlay: function() {
        return this.searchOverlay;
      },
      setOverlay: function(overlay) {
        this.searchOverlay = overlay;
      },
      isReversed: function() {
        return vimGlobalState.isReversed;
      },
      setReversed: function(reversed) {
        vimGlobalState.isReversed = reversed;
      }
    };
    function getSearchState(cm) {
      var vim = cm.state.vim;
      return vim.searchState_ || (vim.searchState_ = new SearchState());
    }
    function dialog(cm, template, shortText, onClose, options) {
      if (cm.openDialog) {
        cm.openDialog(template, onClose, { bottom: true, value: options.value,
            onKeyDown: options.onKeyDown, onKeyUp: options.onKeyUp });
      }
      else {
        onClose(prompt(shortText, &apos;&apos;));
      }
    }
    function splitBySlash(argString) {
      var slashes = findUnescapedSlashes(argString) || [];
      if (!slashes.length) return [];
      var tokens = [];
      // in case of strings like foo/bar
      if (slashes[0] !== 0) return;
      for (var i = 0; i &lt; slashes.length; i++) {
        if (typeof slashes[i] == &apos;number&apos;)
          tokens.push(argString.substring(slashes[i] + 1, slashes[i+1]));
      }
      return tokens;
    }

    function findUnescapedSlashes(str) {
      var escapeNextChar = false;
      var slashes = [];
      for (var i = 0; i &lt; str.length; i++) {
        var c = str.charAt(i);
        if (!escapeNextChar &amp;&amp; c == &apos;/&apos;) {
          slashes.push(i);
        }
        escapeNextChar = !escapeNextChar &amp;&amp; (c == &apos;\\&apos;);
      }
      return slashes;
    }

    // Translates a search string from ex (vim) syntax into javascript form.
    function translateRegex(str) {
      // When these match, add a &apos;\&apos; if unescaped or remove one if escaped.
      var specials = &apos;|(){&apos;;
      // Remove, but never add, a &apos;\&apos; for these.
      var unescape = &apos;}&apos;;
      var escapeNextChar = false;
      var out = [];
      for (var i = -1; i &lt; str.length; i++) {
        var c = str.charAt(i) || &apos;&apos;;
        var n = str.charAt(i+1) || &apos;&apos;;
        var specialComesNext = (n &amp;&amp; specials.indexOf(n) != -1);
        if (escapeNextChar) {
          if (c !== &apos;\\&apos; || !specialComesNext) {
            out.push(c);
          }
          escapeNextChar = false;
        } else {
          if (c === &apos;\\&apos;) {
            escapeNextChar = true;
            // Treat the unescape list as special for removing, but not adding &apos;\&apos;.
            if (n &amp;&amp; unescape.indexOf(n) != -1) {
              specialComesNext = true;
            }
            // Not passing this test means removing a &apos;\&apos;.
            if (!specialComesNext || n === &apos;\\&apos;) {
              out.push(c);
            }
          } else {
            out.push(c);
            if (specialComesNext &amp;&amp; n !== &apos;\\&apos;) {
              out.push(&apos;\\&apos;);
            }
          }
        }
      }
      return out.join(&apos;&apos;);
    }

    // Translates the replace part of a search and replace from ex (vim) syntax into
    // javascript form.  Similar to translateRegex, but additionally fixes back references
    // (translates &apos;\[0..9]&apos; to &apos;$[0..9]&apos;) and follows different rules for escaping &apos;$&apos;.
    function translateRegexReplace(str) {
      var escapeNextChar = false;
      var out = [];
      for (var i = -1; i &lt; str.length; i++) {
        var c = str.charAt(i) || &apos;&apos;;
        var n = str.charAt(i+1) || &apos;&apos;;
        if (escapeNextChar) {
          // At any point in the loop, escapeNextChar is true if the previous
          // character was a &apos;\&apos; and was not escaped.
          out.push(c);
          escapeNextChar = false;
        } else {
          if (c === &apos;\\&apos;) {
            escapeNextChar = true;
            if ((isNumber(n) || n === &apos;$&apos;)) {
              out.push(&apos;$&apos;);
            } else if (n !== &apos;/&apos; &amp;&amp; n !== &apos;\\&apos;) {
              out.push(&apos;\\&apos;);
            }
          } else {
            if (c === &apos;$&apos;) {
              out.push(&apos;$&apos;);
            }
            out.push(c);
            if (n === &apos;/&apos;) {
              out.push(&apos;\\&apos;);
            }
          }
        }
      }
      return out.join(&apos;&apos;);
    }

    // Unescape \ and / in the replace part, for PCRE mode.
    function unescapeRegexReplace(str) {
      var stream = new CodeMirror.StringStream(str);
      var output = [];
      while (!stream.eol()) {
        // Search for \.
        while (stream.peek() &amp;&amp; stream.peek() != &apos;\\&apos;) {
          output.push(stream.next());
        }
        if (stream.match(&apos;\\/&apos;, true)) {
          // \/ =&gt; /
          output.push(&apos;/&apos;);
        } else if (stream.match(&apos;\\\\&apos;, true)) {
          // \\ =&gt; \
          output.push(&apos;\\&apos;);
        } else {
          // Don&apos;t change anything
          output.push(stream.next());
        }
      }
      return output.join(&apos;&apos;);
    }

    /**
     * Extract the regular expression from the query and return a Regexp object.
     * Returns null if the query is blank.
     * If ignoreCase is passed in, the Regexp object will have the &apos;i&apos; flag set.
     * If smartCase is passed in, and the query contains upper case letters,
     *   then ignoreCase is overridden, and the &apos;i&apos; flag will not be set.
     * If the query contains the /i in the flag part of the regular expression,
     *   then both ignoreCase and smartCase are ignored, and &apos;i&apos; will be passed
     *   through to the Regex object.
     */
    function parseQuery(query, ignoreCase, smartCase) {
      // First update the last search register
      var lastSearchRegister = vimGlobalState.registerController.getRegister(&apos;/&apos;);
      lastSearchRegister.setText(query);
      // Check if the query is already a regex.
      if (query instanceof RegExp) { return query; }
      // First try to extract regex + flags from the input. If no flags found,
      // extract just the regex. IE does not accept flags directly defined in
      // the regex string in the form /regex/flags
      var slashes = findUnescapedSlashes(query);
      var regexPart;
      var forceIgnoreCase;
      if (!slashes.length) {
        // Query looks like &apos;regexp&apos;
        regexPart = query;
      } else {
        // Query looks like &apos;regexp/...&apos;
        regexPart = query.substring(0, slashes[0]);
        var flagsPart = query.substring(slashes[0]);
        forceIgnoreCase = (flagsPart.indexOf(&apos;i&apos;) != -1);
      }
      if (!regexPart) {
        return null;
      }
      if (!getOption(&apos;pcre&apos;)) {
        regexPart = translateRegex(regexPart);
      }
      if (smartCase) {
        ignoreCase = (/^[^A-Z]*$/).test(regexPart);
      }
      var regexp = new RegExp(regexPart,
          (ignoreCase || forceIgnoreCase) ? &apos;i&apos; : undefined);
      return regexp;
    }
    function showConfirm(cm, text) {
      if (cm.openNotification) {
        cm.openNotification(&apos;&lt;span style=&quot;color: red&quot;&gt;&apos; + text + &apos;&lt;/span&gt;&apos;,
                            {bottom: true, duration: 5000});
      } else {
        alert(text);
      }
    }
    function makePrompt(prefix, desc) {
      var raw = &apos;&apos;;
      if (prefix) {
        raw += &apos;&lt;span style=&quot;font-family: monospace&quot;&gt;&apos; + prefix + &apos;&lt;/span&gt;&apos;;
      }
      raw += &apos;&lt;input type=&quot;text&quot;/&gt; &apos; +
          &apos;&lt;span style=&quot;color: #888&quot;&gt;&apos;;
      if (desc) {
        raw += &apos;&lt;span style=&quot;color: #888&quot;&gt;&apos;;
        raw += desc;
        raw += &apos;&lt;/span&gt;&apos;;
      }
      return raw;
    }
    var searchPromptDesc = &apos;(Javascript regexp)&apos;;
    function showPrompt(cm, options) {
      var shortText = (options.prefix || &apos;&apos;) + &apos; &apos; + (options.desc || &apos;&apos;);
      var prompt = makePrompt(options.prefix, options.desc);
      dialog(cm, prompt, shortText, options.onClose, options);
    }
    function regexEqual(r1, r2) {
      if (r1 instanceof RegExp &amp;&amp; r2 instanceof RegExp) {
          var props = [&apos;global&apos;, &apos;multiline&apos;, &apos;ignoreCase&apos;, &apos;source&apos;];
          for (var i = 0; i &lt; props.length; i++) {
              var prop = props[i];
              if (r1[prop] !== r2[prop]) {
                  return false;
              }
          }
          return true;
      }
      return false;
    }
    // Returns true if the query is valid.
    function updateSearchQuery(cm, rawQuery, ignoreCase, smartCase) {
      if (!rawQuery) {
        return;
      }
      var state = getSearchState(cm);
      var query = parseQuery(rawQuery, !!ignoreCase, !!smartCase);
      if (!query) {
        return;
      }
      highlightSearchMatches(cm, query);
      if (regexEqual(query, state.getQuery())) {
        return query;
      }
      state.setQuery(query);
      return query;
    }
    function searchOverlay(query) {
      if (query.source.charAt(0) == &apos;^&apos;) {
        var matchSol = true;
      }
      return {
        token: function(stream) {
          if (matchSol &amp;&amp; !stream.sol()) {
            stream.skipToEnd();
            return;
          }
          var match = stream.match(query, false);
          if (match) {
            if (match[0].length == 0) {
              // Matched empty string, skip to next.
              stream.next();
              return &apos;searching&apos;;
            }
            if (!stream.sol()) {
              // Backtrack 1 to match \b
              stream.backUp(1);
              if (!query.exec(stream.next() + match[0])) {
                stream.next();
                return null;
              }
            }
            stream.match(query);
            return &apos;searching&apos;;
          }
          while (!stream.eol()) {
            stream.next();
            if (stream.match(query, false)) break;
          }
        },
        query: query
      };
    }
    function highlightSearchMatches(cm, query) {
      var overlay = getSearchState(cm).getOverlay();
      if (!overlay || query != overlay.query) {
        if (overlay) {
          cm.removeOverlay(overlay);
        }
        overlay = searchOverlay(query);
        cm.addOverlay(overlay);
        getSearchState(cm).setOverlay(overlay);
      }
    }
    function findNext(cm, prev, query, repeat) {
      if (repeat === undefined) { repeat = 1; }
      return cm.operation(function() {
        var pos = cm.getCursor();
        var cursor = cm.getSearchCursor(query, pos);
        for (var i = 0; i &lt; repeat; i++) {
          var found = cursor.find(prev);
          if (i == 0 &amp;&amp; found &amp;&amp; cursorEqual(cursor.from(), pos)) { found = cursor.find(prev); }
          if (!found) {
            // SearchCursor may have returned null because it hit EOF, wrap
            // around and try again.
            cursor = cm.getSearchCursor(query,
                (prev) ? Pos(cm.lastLine()) : Pos(cm.firstLine(), 0) );
            if (!cursor.find(prev)) {
              return;
            }
          }
        }
        return cursor.from();
      });
    }
    function clearSearchHighlight(cm) {
      cm.removeOverlay(getSearchState(cm).getOverlay());
      getSearchState(cm).setOverlay(null);
    }
    /**
     * Check if pos is in the specified range, INCLUSIVE.
     * Range can be specified with 1 or 2 arguments.
     * If the first range argument is an array, treat it as an array of line
     * numbers. Match pos against any of the lines.
     * If the first range argument is a number,
     *   if there is only 1 range argument, check if pos has the same line
     *       number
     *   if there are 2 range arguments, then check if pos is in between the two
     *       range arguments.
     */
    function isInRange(pos, start, end) {
      if (typeof pos != &apos;number&apos;) {
        // Assume it is a cursor position. Get the line number.
        pos = pos.line;
      }
      if (start instanceof Array) {
        return inArray(pos, start);
      } else {
        if (end) {
          return (pos &gt;= start &amp;&amp; pos &lt;= end);
        } else {
          return pos == start;
        }
      }
    }
    function getUserVisibleLines(cm) {
      var scrollInfo = cm.getScrollInfo();
      var occludeToleranceTop = 6;
      var occludeToleranceBottom = 10;
      var from = cm.coordsChar({left:0, top: occludeToleranceTop + scrollInfo.top}, &apos;local&apos;);
      var bottomY = scrollInfo.clientHeight - occludeToleranceBottom + scrollInfo.top;
      var to = cm.coordsChar({left:0, top: bottomY}, &apos;local&apos;);
      return {top: from.line, bottom: to.line};
    }

    // Ex command handling
    // Care must be taken when adding to the default Ex command map. For any
    // pair of commands that have a shared prefix, at least one of their
    // shortNames must not match the prefix of the other command.
    var defaultExCommandMap = [
      { name: &apos;map&apos; },
      { name: &apos;imap&apos;, shortName: &apos;im&apos; },
      { name: &apos;nmap&apos;, shortName: &apos;nm&apos; },
      { name: &apos;vmap&apos;, shortName: &apos;vm&apos; },
      { name: &apos;unmap&apos; },
      { name: &apos;write&apos;, shortName: &apos;w&apos; },
      { name: &apos;undo&apos;, shortName: &apos;u&apos; },
      { name: &apos;redo&apos;, shortName: &apos;red&apos; },
      { name: &apos;set&apos;, shortName: &apos;set&apos; },
      { name: &apos;sort&apos;, shortName: &apos;sor&apos; },
      { name: &apos;substitute&apos;, shortName: &apos;s&apos;, possiblyAsync: true },
      { name: &apos;nohlsearch&apos;, shortName: &apos;noh&apos; },
      { name: &apos;delmarks&apos;, shortName: &apos;delm&apos; },
      { name: &apos;registers&apos;, shortName: &apos;reg&apos;, excludeFromCommandHistory: true },
      { name: &apos;global&apos;, shortName: &apos;g&apos; }
    ];
    Vim.ExCommandDispatcher = function() {
      this.buildCommandMap_();
    };
    Vim.ExCommandDispatcher.prototype = {
      processCommand: function(cm, input, opt_params) {
        var vim = cm.state.vim;
        var commandHistoryRegister = vimGlobalState.registerController.getRegister(&apos;:&apos;);
        var previousCommand = commandHistoryRegister.toString();
        if (vim.visualMode) {
          exitVisualMode(cm);
        }
        var inputStream = new CodeMirror.StringStream(input);
        // update &quot;: with the latest command whether valid or invalid
        commandHistoryRegister.setText(input);
        var params = opt_params || {};
        params.input = input;
        try {
          this.parseInput_(cm, inputStream, params);
        } catch(e) {
          showConfirm(cm, e);
          throw e;
        }
        var command;
        var commandName;
        if (!params.commandName) {
          // If only a line range is defined, move to the line.
          if (params.line !== undefined) {
            commandName = &apos;move&apos;;
          }
        } else {
          command = this.matchCommand_(params.commandName);
          if (command) {
            commandName = command.name;
            if (command.excludeFromCommandHistory) {
              commandHistoryRegister.setText(previousCommand);
            }
            this.parseCommandArgs_(inputStream, params, command);
            if (command.type == &apos;exToKey&apos;) {
              // Handle Ex to Key mapping.
              for (var i = 0; i &lt; command.toKeys.length; i++) {
                CodeMirror.Vim.handleKey(cm, command.toKeys[i], &apos;mapping&apos;);
              }
              return;
            } else if (command.type == &apos;exToEx&apos;) {
              // Handle Ex to Ex mapping.
              this.processCommand(cm, command.toInput);
              return;
            }
          }
        }
        if (!commandName) {
          showConfirm(cm, &apos;Not an editor command &quot;:&apos; + input + &apos;&quot;&apos;);
          return;
        }
        try {
          exCommands[commandName](cm, params);
          // Possibly asynchronous commands (e.g. substitute, which might have a
          // user confirmation), are responsible for calling the callback when
          // done. All others have it taken care of for them here.
          if ((!command || !command.possiblyAsync) &amp;&amp; params.callback) {
            params.callback();
          }
        } catch(e) {
          showConfirm(cm, e);
          throw e;
        }
      },
      parseInput_: function(cm, inputStream, result) {
        inputStream.eatWhile(&apos;:&apos;);
        // Parse range.
        if (inputStream.eat(&apos;%&apos;)) {
          result.line = cm.firstLine();
          result.lineEnd = cm.lastLine();
        } else {
          result.line = this.parseLineSpec_(cm, inputStream);
          if (result.line !== undefined &amp;&amp; inputStream.eat(&apos;,&apos;)) {
            result.lineEnd = this.parseLineSpec_(cm, inputStream);
          }
        }

        // Parse command name.
        var commandMatch = inputStream.match(/^(\w+)/);
        if (commandMatch) {
          result.commandName = commandMatch[1];
        } else {
          result.commandName = inputStream.match(/.*/)[0];
        }

        return result;
      },
      parseLineSpec_: function(cm, inputStream) {
        var numberMatch = inputStream.match(/^(\d+)/);
        if (numberMatch) {
          return parseInt(numberMatch[1], 10) - 1;
        }
        switch (inputStream.next()) {
          case &apos;.&apos;:
            return cm.getCursor().line;
          case &apos;$&apos;:
            return cm.lastLine();
          case &apos;\&apos;&apos;:
            var mark = cm.state.vim.marks[inputStream.next()];
            if (mark &amp;&amp; mark.find()) {
              return mark.find().line;
            }
            throw new Error(&apos;Mark not set&apos;);
          default:
            inputStream.backUp(1);
            return undefined;
        }
      },
      parseCommandArgs_: function(inputStream, params, command) {
        if (inputStream.eol()) {
          return;
        }
        params.argString = inputStream.match(/.*/)[0];
        // Parse command-line arguments
        var delim = command.argDelimiter || /\s+/;
        var args = trim(params.argString).split(delim);
        if (args.length &amp;&amp; args[0]) {
          params.args = args;
        }
      },
      matchCommand_: function(commandName) {
        // Return the command in the command map that matches the shortest
        // prefix of the passed in command name. The match is guaranteed to be
        // unambiguous if the defaultExCommandMap&apos;s shortNames are set up
        // correctly. (see @code{defaultExCommandMap}).
        for (var i = commandName.length; i &gt; 0; i--) {
          var prefix = commandName.substring(0, i);
          if (this.commandMap_[prefix]) {
            var command = this.commandMap_[prefix];
            if (command.name.indexOf(commandName) === 0) {
              return command;
            }
          }
        }
        return null;
      },
      buildCommandMap_: function() {
        this.commandMap_ = {};
        for (var i = 0; i &lt; defaultExCommandMap.length; i++) {
          var command = defaultExCommandMap[i];
          var key = command.shortName || command.name;
          this.commandMap_[key] = command;
        }
      },
      map: function(lhs, rhs, ctx) {
        if (lhs != &apos;:&apos; &amp;&amp; lhs.charAt(0) == &apos;:&apos;) {
          if (ctx) { throw Error(&apos;Mode not supported for ex mappings&apos;); }
          var commandName = lhs.substring(1);
          if (rhs != &apos;:&apos; &amp;&amp; rhs.charAt(0) == &apos;:&apos;) {
            // Ex to Ex mapping
            this.commandMap_[commandName] = {
              name: commandName,
              type: &apos;exToEx&apos;,
              toInput: rhs.substring(1),
              user: true
            };
          } else {
            // Ex to key mapping
            this.commandMap_[commandName] = {
              name: commandName,
              type: &apos;exToKey&apos;,
              toKeys: rhs,
              user: true
            };
          }
        } else {
          if (rhs != &apos;:&apos; &amp;&amp; rhs.charAt(0) == &apos;:&apos;) {
            // Key to Ex mapping.
            var mapping = {
              keys: lhs,
              type: &apos;keyToEx&apos;,
              exArgs: { input: rhs.substring(1) },
              user: true};
            if (ctx) { mapping.context = ctx; }
            defaultKeymap.unshift(mapping);
          } else {
            // Key to key mapping
            var mapping = {
              keys: lhs,
              type: &apos;keyToKey&apos;,
              toKeys: rhs,
              user: true
            };
            if (ctx) { mapping.context = ctx; }
            defaultKeymap.unshift(mapping);
          }
        }
      },
      unmap: function(lhs, ctx) {
        if (lhs != &apos;:&apos; &amp;&amp; lhs.charAt(0) == &apos;:&apos;) {
          // Ex to Ex or Ex to key mapping
          if (ctx) { throw Error(&apos;Mode not supported for ex mappings&apos;); }
          var commandName = lhs.substring(1);
          if (this.commandMap_[commandName] &amp;&amp; this.commandMap_[commandName].user) {
            delete this.commandMap_[commandName];
            return;
          }
        } else {
          // Key to Ex or key to key mapping
          var keys = lhs;
          for (var i = 0; i &lt; defaultKeymap.length; i++) {
            if (keys == defaultKeymap[i].keys
                &amp;&amp; defaultKeymap[i].context === ctx
                &amp;&amp; defaultKeymap[i].user) {
              defaultKeymap.splice(i, 1);
              return;
            }
          }
        }
        throw Error(&apos;No such mapping.&apos;);
      }
    };

    var exCommands = {
      map: function(cm, params, ctx) {
        var mapArgs = params.args;
        if (!mapArgs || mapArgs.length &lt; 2) {
          if (cm) {
            showConfirm(cm, &apos;Invalid mapping: &apos; + params.input);
          }
          return;
        }
        exCommandDispatcher.map(mapArgs[0], mapArgs[1], ctx);
      },
      imap: function(cm, params) { this.map(cm, params, &apos;insert&apos;); },
      nmap: function(cm, params) { this.map(cm, params, &apos;normal&apos;); },
      vmap: function(cm, params) { this.map(cm, params, &apos;visual&apos;); },
      unmap: function(cm, params, ctx) {
        var mapArgs = params.args;
        if (!mapArgs || mapArgs.length &lt; 1) {
          if (cm) {
            showConfirm(cm, &apos;No such mapping: &apos; + params.input);
          }
          return;
        }
        exCommandDispatcher.unmap(mapArgs[0], ctx);
      },
      move: function(cm, params) {
        commandDispatcher.processCommand(cm, cm.state.vim, {
            type: &apos;motion&apos;,
            motion: &apos;moveToLineOrEdgeOfDocument&apos;,
            motionArgs: { forward: false, explicitRepeat: true,
              linewise: true },
            repeatOverride: params.line+1});
      },
      set: function(cm, params) {
        var setArgs = params.args;
        if (!setArgs || setArgs.length &lt; 1) {
          if (cm) {
            showConfirm(cm, &apos;Invalid mapping: &apos; + params.input);
          }
          return;
        }
        var expr = setArgs[0].split(&apos;=&apos;);
        var optionName = expr[0];
        var value = expr[1];
        var forceGet = false;

        if (optionName.charAt(optionName.length - 1) == &apos;?&apos;) {
          // If post-fixed with ?, then the set is actually a get.
          if (value) { throw Error(&apos;Trailing characters: &apos; + params.argString); }
          optionName = optionName.substring(0, optionName.length - 1);
          forceGet = true;
        }
        if (value === undefined &amp;&amp; optionName.substring(0, 2) == &apos;no&apos;) {
          // To set boolean options to false, the option name is prefixed with
          // &apos;no&apos;.
          optionName = optionName.substring(2);
          value = false;
        }
        var optionIsBoolean = options[optionName] &amp;&amp; options[optionName].type == &apos;boolean&apos;;
        if (optionIsBoolean &amp;&amp; value == undefined) {
          // Calling set with a boolean option sets it to true.
          value = true;
        }
        if (!optionIsBoolean &amp;&amp; !value || forceGet) {
          var oldValue = getOption(optionName);
          // If no value is provided, then we assume this is a get.
          if (oldValue === true || oldValue === false) {
            showConfirm(cm, &apos; &apos; + (oldValue ? &apos;&apos; : &apos;no&apos;) + optionName);
          } else {
            showConfirm(cm, &apos;  &apos; + optionName + &apos;=&apos; + oldValue);
          }
        } else {
          setOption(optionName, value);
        }
      },
      registers: function(cm,params) {
        var regArgs = params.args;
        var registers = vimGlobalState.registerController.registers;
        var regInfo = &apos;----------Registers----------&lt;br&gt;&lt;br&gt;&apos;;
        if (!regArgs) {
          for (var registerName in registers) {
            var text = registers[registerName].toString();
            if (text.length) {
              regInfo += &apos;&quot;&apos; + registerName + &apos;    &apos; + text + &apos;&lt;br&gt;&apos;;
            }
          }
        } else {
          var registerName;
          regArgs = regArgs.join(&apos;&apos;);
          for (var i = 0; i &lt; regArgs.length; i++) {
            registerName = regArgs.charAt(i);
            if (!vimGlobalState.registerController.isValidRegister(registerName)) {
              continue;
            }
            var register = registers[registerName] || new Register();
            regInfo += &apos;&quot;&apos; + registerName + &apos;    &apos; + register.toString() + &apos;&lt;br&gt;&apos;;
          }
        }
        showConfirm(cm, regInfo);
      },
      sort: function(cm, params) {
        var reverse, ignoreCase, unique, number;
        function parseArgs() {
          if (params.argString) {
            var args = new CodeMirror.StringStream(params.argString);
            if (args.eat(&apos;!&apos;)) { reverse = true; }
            if (args.eol()) { return; }
            if (!args.eatSpace()) { return &apos;Invalid arguments&apos;; }
            var opts = args.match(/[a-z]+/);
            if (opts) {
              opts = opts[0];
              ignoreCase = opts.indexOf(&apos;i&apos;) != -1;
              unique = opts.indexOf(&apos;u&apos;) != -1;
              var decimal = opts.indexOf(&apos;d&apos;) != -1 &amp;&amp; 1;
              var hex = opts.indexOf(&apos;x&apos;) != -1 &amp;&amp; 1;
              var octal = opts.indexOf(&apos;o&apos;) != -1 &amp;&amp; 1;
              if (decimal + hex + octal &gt; 1) { return &apos;Invalid arguments&apos;; }
              number = decimal &amp;&amp; &apos;decimal&apos; || hex &amp;&amp; &apos;hex&apos; || octal &amp;&amp; &apos;octal&apos;;
            }
            if (args.eatSpace() &amp;&amp; args.match(/\/.*\//)) { &apos;patterns not supported&apos;; }
          }
        }
        var err = parseArgs();
        if (err) {
          showConfirm(cm, err + &apos;: &apos; + params.argString);
          return;
        }
        var lineStart = params.line || cm.firstLine();
        var lineEnd = params.lineEnd || params.line || cm.lastLine();
        if (lineStart == lineEnd) { return; }
        var curStart = Pos(lineStart, 0);
        var curEnd = Pos(lineEnd, lineLength(cm, lineEnd));
        var text = cm.getRange(curStart, curEnd).split(&apos;\n&apos;);
        var numberRegex = (number == &apos;decimal&apos;) ? /(-?)([\d]+)/ :
           (number == &apos;hex&apos;) ? /(-?)(?:0x)?([0-9a-f]+)/i :
           (number == &apos;octal&apos;) ? /([0-7]+)/ : null;
        var radix = (number == &apos;decimal&apos;) ? 10 : (number == &apos;hex&apos;) ? 16 : (number == &apos;octal&apos;) ? 8 : null;
        var numPart = [], textPart = [];
        if (number) {
          for (var i = 0; i &lt; text.length; i++) {
            if (numberRegex.exec(text[i])) {
              numPart.push(text[i]);
            } else {
              textPart.push(text[i]);
            }
          }
        } else {
          textPart = text;
        }
        function compareFn(a, b) {
          if (reverse) { var tmp; tmp = a; a = b; b = tmp; }
          if (ignoreCase) { a = a.toLowerCase(); b = b.toLowerCase(); }
          var anum = number &amp;&amp; numberRegex.exec(a);
          var bnum = number &amp;&amp; numberRegex.exec(b);
          if (!anum) { return a &lt; b ? -1 : 1; }
          anum = parseInt((anum[1] + anum[2]).toLowerCase(), radix);
          bnum = parseInt((bnum[1] + bnum[2]).toLowerCase(), radix);
          return anum - bnum;
        }
        numPart.sort(compareFn);
        textPart.sort(compareFn);
        text = (!reverse) ? textPart.concat(numPart) : numPart.concat(textPart);
        if (unique) { // Remove duplicate lines
          var textOld = text;
          var lastLine;
          text = [];
          for (var i = 0; i &lt; textOld.length; i++) {
            if (textOld[i] != lastLine) {
              text.push(textOld[i]);
            }
            lastLine = textOld[i];
          }
        }
        cm.replaceRange(text.join(&apos;\n&apos;), curStart, curEnd);
      },
      global: function(cm, params) {
        // a global command is of the form
        // :[range]g/pattern/[cmd]
        // argString holds the string /pattern/[cmd]
        var argString = params.argString;
        if (!argString) {
          showConfirm(cm, &apos;Regular Expression missing from global&apos;);
          return;
        }
        // range is specified here
        var lineStart = (params.line !== undefined) ? params.line : cm.firstLine();
        var lineEnd = params.lineEnd || params.line || cm.lastLine();
        // get the tokens from argString
        var tokens = splitBySlash(argString);
        var regexPart = argString, cmd;
        if (tokens.length) {
          regexPart = tokens[0];
          cmd = tokens.slice(1, tokens.length).join(&apos;/&apos;);
        }
        if (regexPart) {
          // If regex part is empty, then use the previous query. Otherwise
          // use the regex part as the new query.
          try {
           updateSearchQuery(cm, regexPart, true /** ignoreCase */,
             true /** smartCase */);
          } catch (e) {
           showConfirm(cm, &apos;Invalid regex: &apos; + regexPart);
           return;
          }
        }
        // now that we have the regexPart, search for regex matches in the
        // specified range of lines
        var query = getSearchState(cm).getQuery();
        var matchedLines = [], content = &apos;&apos;;
        for (var i = lineStart; i &lt;= lineEnd; i++) {
          var matched = query.test(cm.getLine(i));
          if (matched) {
            matchedLines.push(i+1);
            content+= cm.getLine(i) + &apos;&lt;br&gt;&apos;;
          }
        }
        // if there is no [cmd], just display the list of matched lines
        if (!cmd) {
          showConfirm(cm, content);
          return;
        }
        var index = 0;
        var nextCommand = function() {
          if (index &lt; matchedLines.length) {
            var command = matchedLines[index] + cmd;
            exCommandDispatcher.processCommand(cm, command, {
              callback: nextCommand
            });
          }
          index++;
        };
        nextCommand();
      },
      substitute: function(cm, params) {
        if (!cm.getSearchCursor) {
          throw new Error(&apos;Search feature not available. Requires searchcursor.js or &apos; +
              &apos;any other getSearchCursor implementation.&apos;);
        }
        var argString = params.argString;
        var tokens = argString ? splitBySlash(argString) : [];
        var regexPart, replacePart = &apos;&apos;, trailing, flagsPart, count;
        var confirm = false; // Whether to confirm each replace.
        var global = false; // True to replace all instances on a line, false to replace only 1.
        if (tokens.length) {
          regexPart = tokens[0];
          replacePart = tokens[1];
          if (replacePart !== undefined) {
            if (getOption(&apos;pcre&apos;)) {
              replacePart = unescapeRegexReplace(replacePart);
            } else {
              replacePart = translateRegexReplace(replacePart);
            }
            vimGlobalState.lastSubstituteReplacePart = replacePart;
          }
          trailing = tokens[2] ? tokens[2].split(&apos; &apos;) : [];
        } else {
          // either the argString is empty or its of the form &apos; hello/world&apos;
          // actually splitBySlash returns a list of tokens
          // only if the string starts with a &apos;/&apos;
          if (argString &amp;&amp; argString.length) {
            showConfirm(cm, &apos;Substitutions should be of the form &apos; +
                &apos;:s/pattern/replace/&apos;);
            return;
          }
        }
        // After the 3rd slash, we can have flags followed by a space followed
        // by count.
        if (trailing) {
          flagsPart = trailing[0];
          count = parseInt(trailing[1]);
          if (flagsPart) {
            if (flagsPart.indexOf(&apos;c&apos;) != -1) {
              confirm = true;
              flagsPart.replace(&apos;c&apos;, &apos;&apos;);
            }
            if (flagsPart.indexOf(&apos;g&apos;) != -1) {
              global = true;
              flagsPart.replace(&apos;g&apos;, &apos;&apos;);
            }
            regexPart = regexPart + &apos;/&apos; + flagsPart;
          }
        }
        if (regexPart) {
          // If regex part is empty, then use the previous query. Otherwise use
          // the regex part as the new query.
          try {
            updateSearchQuery(cm, regexPart, true /** ignoreCase */,
              true /** smartCase */);
          } catch (e) {
            showConfirm(cm, &apos;Invalid regex: &apos; + regexPart);
            return;
          }
        }
        replacePart = replacePart || vimGlobalState.lastSubstituteReplacePart;
        if (replacePart === undefined) {
          showConfirm(cm, &apos;No previous substitute regular expression&apos;);
          return;
        }
        var state = getSearchState(cm);
        var query = state.getQuery();
        var lineStart = (params.line !== undefined) ? params.line : cm.getCursor().line;
        var lineEnd = params.lineEnd || lineStart;
        if (count) {
          lineStart = lineEnd;
          lineEnd = lineStart + count - 1;
        }
        var startPos = clipCursorToContent(cm, Pos(lineStart, 0));
        var cursor = cm.getSearchCursor(query, startPos);
        doReplace(cm, confirm, global, lineStart, lineEnd, cursor, query, replacePart, params.callback);
      },
      redo: CodeMirror.commands.redo,
      undo: CodeMirror.commands.undo,
      write: function(cm) {
        if (CodeMirror.commands.save) {
          // If a save command is defined, call it.
          CodeMirror.commands.save(cm);
        } else {
          // Saves to text area if no save command is defined.
          cm.save();
        }
      },
      nohlsearch: function(cm) {
        clearSearchHighlight(cm);
      },
      delmarks: function(cm, params) {
        if (!params.argString || !trim(params.argString)) {
          showConfirm(cm, &apos;Argument required&apos;);
          return;
        }

        var state = cm.state.vim;
        var stream = new CodeMirror.StringStream(trim(params.argString));
        while (!stream.eol()) {
          stream.eatSpace();

          // Record the streams position at the beginning of the loop for use
          // in error messages.
          var count = stream.pos;

          if (!stream.match(/[a-zA-Z]/, false)) {
            showConfirm(cm, &apos;Invalid argument: &apos; + params.argString.substring(count));
            return;
          }

          var sym = stream.next();
          // Check if this symbol is part of a range
          if (stream.match(&apos;-&apos;, true)) {
            // This symbol is part of a range.

            // The range must terminate at an alphabetic character.
            if (!stream.match(/[a-zA-Z]/, false)) {
              showConfirm(cm, &apos;Invalid argument: &apos; + params.argString.substring(count));
              return;
            }

            var startMark = sym;
            var finishMark = stream.next();
            // The range must terminate at an alphabetic character which
            // shares the same case as the start of the range.
            if (isLowerCase(startMark) &amp;&amp; isLowerCase(finishMark) ||
                isUpperCase(startMark) &amp;&amp; isUpperCase(finishMark)) {
              var start = startMark.charCodeAt(0);
              var finish = finishMark.charCodeAt(0);
              if (start &gt;= finish) {
                showConfirm(cm, &apos;Invalid argument: &apos; + params.argString.substring(count));
                return;
              }

              // Because marks are always ASCII values, and we have
              // determined that they are the same case, we can use
              // their char codes to iterate through the defined range.
              for (var j = 0; j &lt;= finish - start; j++) {
                var mark = String.fromCharCode(start + j);
                delete state.marks[mark];
              }
            } else {
              showConfirm(cm, &apos;Invalid argument: &apos; + startMark + &apos;-&apos;);
              return;
            }
          } else {
            // This symbol is a valid mark, and is not part of a range.
            delete state.marks[sym];
          }
        }
      }
    };

    var exCommandDispatcher = new Vim.ExCommandDispatcher();

    /**
    * @param {CodeMirror} cm CodeMirror instance we are in.
    * @param {boolean} confirm Whether to confirm each replace.
    * @param {Cursor} lineStart Line to start replacing from.
    * @param {Cursor} lineEnd Line to stop replacing at.
    * @param {RegExp} query Query for performing matches with.
    * @param {string} replaceWith Text to replace matches with. May contain $1,
    *     $2, etc for replacing captured groups using Javascript replace.
    * @param {function()} callback A callback for when the replace is done.
    */
    function doReplace(cm, confirm, global, lineStart, lineEnd, searchCursor, query,
        replaceWith, callback) {
      // Set up all the functions.
      cm.state.vim.exMode = true;
      var done = false;
      var lastPos = searchCursor.from();
      function replaceAll() {
        cm.operation(function() {
          while (!done) {
            replace();
            next();
          }
          stop();
        });
      }
      function replace() {
        var text = cm.getRange(searchCursor.from(), searchCursor.to());
        var newText = text.replace(query, replaceWith);
        searchCursor.replace(newText);
      }
      function next() {
        var found;
        // The below only loops to skip over multiple occurrences on the same
        // line when &apos;global&apos; is not true.
        while(found = searchCursor.findNext() &amp;&amp;
              isInRange(searchCursor.from(), lineStart, lineEnd)) {
          if (!global &amp;&amp; lastPos &amp;&amp; searchCursor.from().line == lastPos.line) {
            continue;
          }
          cm.scrollIntoView(searchCursor.from(), 30);
          cm.setSelection(searchCursor.from(), searchCursor.to());
          lastPos = searchCursor.from();
          done = false;
          return;
        }
        done = true;
      }
      function stop(close) {
        if (close) { close(); }
        cm.focus();
        if (lastPos) {
          cm.setCursor(lastPos);
          var vim = cm.state.vim;
          vim.exMode = false;
          vim.lastHPos = vim.lastHSPos = lastPos.ch;
        }
        if (callback) { callback(); }
      }
      function onPromptKeyDown(e, _value, close) {
        // Swallow all keys.
        CodeMirror.e_stop(e);
        var keyName = CodeMirror.keyName(e);
        switch (keyName) {
          case &apos;Y&apos;:
            replace(); next(); break;
          case &apos;N&apos;:
            next(); break;
          case &apos;A&apos;:
            // replaceAll contains a call to close of its own. We don&apos;t want it
            // to fire too early or multiple times.
            var savedCallback = callback;
            callback = undefined;
            cm.operation(replaceAll);
            callback = savedCallback;
            break;
          case &apos;L&apos;:
            replace();
            // fall through and exit.
          case &apos;Q&apos;:
          case &apos;Esc&apos;:
          case &apos;Ctrl-C&apos;:
          case &apos;Ctrl-[&apos;:
            stop(close);
            break;
        }
        if (done) { stop(close); }
      }

      // Actually do replace.
      next();
      if (done) {
        showConfirm(cm, &apos;No matches for &apos; + query.source);
        return;
      }
      if (!confirm) {
        replaceAll();
        if (callback) { callback(); };
        return;
      }
      showPrompt(cm, {
        prefix: &apos;replace with &lt;strong&gt;&apos; + replaceWith + &apos;&lt;/strong&gt; (y/n/a/q/l)&apos;,
        onKeyDown: onPromptKeyDown
      });
    }

    CodeMirror.keyMap.vim = {
        &apos;nofallthrough&apos;: true,
        &apos;style&apos;: &apos;fat-cursor&apos;
      };

    function exitInsertMode(cm) {
      var vim = cm.state.vim;
      var macroModeState = vimGlobalState.macroModeState;
      var insertModeChangeRegister = vimGlobalState.registerController.getRegister(&apos;.&apos;);
      var isPlaying = macroModeState.isPlaying;
      var lastChange = macroModeState.lastInsertModeChanges;
      // In case of visual block, the insertModeChanges are not saved as a
      // single word, so we convert them to a single word
      // so as to update the &quot;. register as expected in real vim.
      var text = [];
      if (!isPlaying) {
        var selLength = lastChange.inVisualBlock ? vim.lastSelection.visualBlock.height : 1;
        var changes = lastChange.changes;
        var text = [];
        var i = 0;
        // In case of multiple selections in blockwise visual,
        // the inserted text, for example: &apos;f&lt;Backspace&gt;oo&apos;, is stored as
        // &apos;f&apos;, &apos;f&apos;, InsertModeKey &apos;o&apos;, &apos;o&apos;, &apos;o&apos;, &apos;o&apos;. (if you have a block with 2 lines).
        // We push the contents of the changes array as per the following:
        // 1. In case of InsertModeKey, just increment by 1.
        // 2. In case of a character, jump by selLength (2 in the example).
        while (i &lt; changes.length) {
          // This loop will convert &apos;ff&lt;bs&gt;oooo&apos; to &apos;f&lt;bs&gt;oo&apos;.
          text.push(changes[i]);
          if (changes[i] instanceof InsertModeKey) {
             i++;
          } else {
             i+= selLength;
          }
        }
        lastChange.changes = text;
        cm.off(&apos;change&apos;, onChange);
        CodeMirror.off(cm.getInputField(), &apos;keydown&apos;, onKeyEventTargetKeyDown);
      }
      if (!isPlaying &amp;&amp; vim.insertModeRepeat &gt; 1) {
        // Perform insert mode repeat for commands like 3,a and 3,o.
        repeatLastEdit(cm, vim, vim.insertModeRepeat - 1,
            true /** repeatForInsert */);
        vim.lastEditInputState.repeatOverride = vim.insertModeRepeat;
      }
      delete vim.insertModeRepeat;
      vim.insertMode = false;
      cm.setCursor(cm.getCursor().line, cm.getCursor().ch-1);
      cm.setOption(&apos;keyMap&apos;, &apos;vim&apos;);
      cm.setOption(&apos;disableInput&apos;, true);
      cm.toggleOverwrite(false); // exit replace mode if we were in it.
      // update the &quot;. register before exiting insert mode
      insertModeChangeRegister.setText(lastChange.changes.join(&apos;&apos;));
      CodeMirror.signal(cm, &quot;vim-mode-change&quot;, {mode: &quot;normal&quot;});
      if (macroModeState.isRecording) {
        logInsertModeChange(macroModeState);
      }
    }

    // The timeout in milliseconds for the two-character ESC keymap should be
    // adjusted according to your typing speed to prevent false positives.
    defineOption(&apos;insertModeEscKeysTimeout&apos;, 200, &apos;number&apos;);

    CodeMirror.keyMap[&apos;vim-insert&apos;] = {
      // TODO: override navigation keys so that Esc will cancel automatic
      // indentation from o, O, i_&lt;CR&gt;
      &apos;Ctrl-N&apos;: &apos;autocomplete&apos;,
      &apos;Ctrl-P&apos;: &apos;autocomplete&apos;,
      &apos;Enter&apos;: function(cm) {
        var fn = CodeMirror.commands.newlineAndIndentContinueComment ||
            CodeMirror.commands.newlineAndIndent;
        fn(cm);
      },
      fallthrough: [&apos;default&apos;]
    };

    CodeMirror.keyMap[&apos;await-second&apos;] = {
      fallthrough: [&apos;vim-insert&apos;]
    };

    CodeMirror.keyMap[&apos;vim-replace&apos;] = {
      &apos;Backspace&apos;: &apos;goCharLeft&apos;,
      fallthrough: [&apos;vim-insert&apos;]
    };

    function executeMacroRegister(cm, vim, macroModeState, registerName) {
      var register = vimGlobalState.registerController.getRegister(registerName);
      var keyBuffer = register.keyBuffer;
      var imc = 0;
      macroModeState.isPlaying = true;
      macroModeState.replaySearchQueries = register.searchQueries.slice(0);
      for (var i = 0; i &lt; keyBuffer.length; i++) {
        var text = keyBuffer[i];
        var match, key;
        while (text) {
          // Pull off one command key, which is either a single character
          // or a special sequence wrapped in &apos;&lt;&apos; and &apos;&gt;&apos;, e.g. &apos;&lt;Space&gt;&apos;.
          match = (/&lt;\w+-.+?&gt;|&lt;\w+&gt;|./).exec(text);
          key = match[0];
          text = text.substring(match.index + key.length);
          CodeMirror.Vim.handleKey(cm, key, &apos;macro&apos;);
          if (vim.insertMode) {
            var changes = register.insertModeChanges[imc++].changes;
            vimGlobalState.macroModeState.lastInsertModeChanges.changes =
                changes;
            repeatInsertModeChanges(cm, changes, 1);
            exitInsertMode(cm);
          }
        }
      };
      macroModeState.isPlaying = false;
    }

    function logKey(macroModeState, key) {
      if (macroModeState.isPlaying) { return; }
      var registerName = macroModeState.latestRegister;
      var register = vimGlobalState.registerController.getRegister(registerName);
      if (register) {
        register.pushText(key);
      }
    }

    function logInsertModeChange(macroModeState) {
      if (macroModeState.isPlaying) { return; }
      var registerName = macroModeState.latestRegister;
      var register = vimGlobalState.registerController.getRegister(registerName);
      if (register) {
        register.pushInsertModeChanges(macroModeState.lastInsertModeChanges);
      }
    }

    function logSearchQuery(macroModeState, query) {
      if (macroModeState.isPlaying) { return; }
      var registerName = macroModeState.latestRegister;
      var register = vimGlobalState.registerController.getRegister(registerName);
      if (register) {
        register.pushSearchQuery(query);
      }
    }

    /**
     * Listens for changes made in insert mode.
     * Should only be active in insert mode.
     */
    function onChange(_cm, changeObj) {
      var macroModeState = vimGlobalState.macroModeState;
      var lastChange = macroModeState.lastInsertModeChanges;
      if (!macroModeState.isPlaying) {
        while(changeObj) {
          lastChange.expectCursorActivityForChange = true;
          if (changeObj.origin == &apos;+input&apos; || changeObj.origin == &apos;paste&apos;
              || changeObj.origin === undefined /* only in testing */) {
            var text = changeObj.text.join(&apos;\n&apos;);
            lastChange.changes.push(text);
          }
          // Change objects may be chained with next.
          changeObj = changeObj.next;
        }
      }
    }

    /**
    * Listens for any kind of cursor activity on CodeMirror.
    */
    function onCursorActivity(cm) {
      var vim = cm.state.vim;
      if (vim.insertMode) {
        // Tracking cursor activity in insert mode (for macro support).
        var macroModeState = vimGlobalState.macroModeState;
        if (macroModeState.isPlaying) { return; }
        var lastChange = macroModeState.lastInsertModeChanges;
        if (lastChange.expectCursorActivityForChange) {
          lastChange.expectCursorActivityForChange = false;
        } else {
          // Cursor moved outside the context of an edit. Reset the change.
          lastChange.changes = [];
        }
      } else if (cm.doc.history.lastSelOrigin == &apos;*mouse&apos;) {
        // Reset lastHPos if mouse click was done in normal mode.
        vim.lastHPos = cm.doc.getCursor().ch;
        handleExternalSelection(cm, vim);
      }
      if (vim.visualMode) {
        var from, head;
        from = head = cm.getCursor(&apos;head&apos;);
        var anchor = cm.getCursor(&apos;anchor&apos;);
        var to = Pos(head.line, from.ch + (cursorIsBefore(anchor, head) ? -1 : 1));
        if (cursorIsBefore(to, from)) {
          var temp = from;
          from = to;
          to = temp;
        }
        if (vim.fakeCursor) {
          vim.fakeCursor.clear();
        }
        vim.fakeCursor = cm.markText(from, to, {className: &apos;cm-animate-fat-cursor&apos;});
      }
    }

    function handleExternalSelection(cm, vim) {
      var anchor = cm.getCursor(&apos;anchor&apos;);
      var head = cm.getCursor(&apos;head&apos;);
      // Enter visual mode when the mouse selects text.
      if (!vim.visualMode &amp;&amp; !vim.insertMode &amp;&amp; cm.somethingSelected()) {
        vim.visualMode = true;
        vim.visualLine = false;
        CodeMirror.signal(cm, &quot;vim-mode-change&quot;, {mode: &quot;visual&quot;});
        cm.on(&apos;mousedown&apos;, exitVisualMode);
      }
      if (vim.visualMode) {
        updateMark(cm, vim, &apos;&lt;&apos;, cursorMin(head, anchor));
        updateMark(cm, vim, &apos;&gt;&apos;, cursorMax(head, anchor));
      }
    }

    /** Wrapper for special keys pressed in insert mode */
    function InsertModeKey(keyName) {
      this.keyName = keyName;
    }

    /**
    * Handles raw key down events from the text area.
    * - Should only be active in insert mode.
    * - For recording deletes in insert mode.
    */
    function onKeyEventTargetKeyDown(e) {
      var macroModeState = vimGlobalState.macroModeState;
      var lastChange = macroModeState.lastInsertModeChanges;
      var keyName = CodeMirror.keyName(e);
      function onKeyFound() {
        lastChange.changes.push(new InsertModeKey(keyName));
        return true;
      }
      if (keyName.indexOf(&apos;Delete&apos;) != -1 || keyName.indexOf(&apos;Backspace&apos;) != -1) {
        CodeMirror.lookupKey(keyName, [&apos;vim-insert&apos;], onKeyFound);
      }
    }

    /**
     * Repeats the last edit, which includes exactly 1 command and at most 1
     * insert. Operator and motion commands are read from lastEditInputState,
     * while action commands are read from lastEditActionCommand.
     *
     * If repeatForInsert is true, then the function was called by
     * exitInsertMode to repeat the insert mode changes the user just made. The
     * corresponding enterInsertMode call was made with a count.
     */
    function repeatLastEdit(cm, vim, repeat, repeatForInsert) {
      var macroModeState = vimGlobalState.macroModeState;
      macroModeState.isPlaying = true;
      var isAction = !!vim.lastEditActionCommand;
      var cachedInputState = vim.inputState;
      function repeatCommand() {
        if (isAction) {
          commandDispatcher.processAction(cm, vim, vim.lastEditActionCommand);
        } else {
          commandDispatcher.evalInput(cm, vim);
        }
      }
      function repeatInsert(repeat) {
        if (macroModeState.lastInsertModeChanges.changes.length &gt; 0) {
          // For some reason, repeat cw in desktop VIM does not repeat
          // insert mode changes. Will conform to that behavior.
          repeat = !vim.lastEditActionCommand ? 1 : repeat;
          var changeObject = macroModeState.lastInsertModeChanges;
          repeatInsertModeChanges(cm, changeObject.changes, repeat);
        }
      }
      vim.inputState = vim.lastEditInputState;
      if (isAction &amp;&amp; vim.lastEditActionCommand.interlaceInsertRepeat) {
        // o and O repeat have to be interlaced with insert repeats so that the
        // insertions appear on separate lines instead of the last line.
        for (var i = 0; i &lt; repeat; i++) {
          repeatCommand();
          repeatInsert(1);
        }
      } else {
        if (!repeatForInsert) {
          // Hack to get the cursor to end up at the right place. If I is
          // repeated in insert mode repeat, cursor will be 1 insert
          // change set left of where it should be.
          repeatCommand();
        }
        repeatInsert(repeat);
      }
      vim.inputState = cachedInputState;
      if (vim.insertMode &amp;&amp; !repeatForInsert) {
        // Don&apos;t exit insert mode twice. If repeatForInsert is set, then we
        // were called by an exitInsertMode call lower on the stack.
        exitInsertMode(cm);
      }
      macroModeState.isPlaying = false;
    };

    function repeatInsertModeChanges(cm, changes, repeat) {
      function keyHandler(binding) {
        if (typeof binding == &apos;string&apos;) {
          CodeMirror.commands[binding](cm);
        } else {
          binding(cm);
        }
        return true;
      }
      var curStart = cm.getCursor();
      var inVisualBlock = vimGlobalState.macroModeState.lastInsertModeChanges.inVisualBlock;
      if (inVisualBlock) {
        // Set up block selection again for repeating the changes.
        var vim = cm.state.vim;
        var block = vim.lastSelection.visualBlock;
        var curEnd = Pos(curStart.line + block.height-1, curStart.ch);
        cm.setCursor(curStart);
        selectBlock(cm, curEnd);
        repeat = cm.listSelections().length;
        cm.setCursor(curStart);
      }
      for (var i = 0; i &lt; repeat; i++) {
        for (var j = 0; j &lt; changes.length; j++) {
          var change = changes[j];
          if (change instanceof InsertModeKey) {
            CodeMirror.lookupKey(change.keyName, [&apos;vim-insert&apos;], keyHandler);
          } else {
            var cur = cm.getCursor();
            cm.replaceRange(change, cur, cur);
          }
        }
        if (inVisualBlock) {
          curStart.line++;
          cm.setCursor(curStart);
        }
      }
    }

    resetVimGlobalState();
    return vimApi;
  };
  // Initialize Vim and make it available as an API.
  CodeMirror.Vim = Vim();
});
</code></pre>

</div>

<footer class="footer">
  Generated by <a href="https://esdoc.org">ESDoc<span data-ice="esdocVersion">(1.1.0)</span><img src="./image/esdoc-logo-mini-black.png"></a>
</footer>

<script src="script/search_index.js"></script>
<script src="script/search.js"></script>
<script src="script/pretty-print.js"></script>
<script src="script/inherited-summary.js"></script>
<script src="script/test-summary.js"></script>
<script src="script/inner-link.js"></script>
<script src="script/patch-for-local.js"></script>
</body>
</html>
