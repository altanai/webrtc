<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <base data-ice="baseUrl" href="../../../../">
  <title data-ice="title">src/codemirror/keymap/sublime.js | webrtcdevelopment</title>
  <link type="text/css" rel="stylesheet" href="css/style.css">
  <link type="text/css" rel="stylesheet" href="css/prettify-tomorrow.css">
  <script src="script/prettify/prettify.js"></script>
  <script src="script/manual.js"></script>
<meta name="description" content="webrtc based communication and collaboration client. Contains lot of experiments modules "><meta property="twitter:card" content="summary"><meta property="twitter:title" content="webrtcdevelopment"><meta property="twitter:description" content="webrtc based communication and collaboration client. Contains lot of experiments modules "></head>
<body class="layout-container" data-ice="rootContainer">

<header>
  <a href="./">Home</a>
  
  <a href="identifiers.html">Reference</a>
  <a href="source.html">Source</a>
  
  <div class="search-box">
  <span>
    <img src="./image/search.png">
    <span class="search-input-edge"></span><input class="search-input"><span class="search-input-edge"></span>
  </span>
    <ul class="search-result"></ul>
  </div>
<a style="position:relative; top:3px;" href="https://github.com/altanai/webrtc"><img width="20px" src="./image/github.png"></a></header>

<nav class="navigation" data-ice="nav"><div>
  <ul>
    
  <li data-ice="doc"><a data-ice="dirPath" class="nav-dir-path" href="identifiers.html#scripts">scripts</a><span data-ice="kind" class="kind-typedef">T</span><span data-ice="name"><span><a href="typedef/index.html#static-typedef-CanvasRecorder">CanvasRecorder</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-typedef">T</span><span data-ice="name"><span><a href="typedef/index.html#static-typedef-GetRecorderType">GetRecorderType</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-typedef">T</span><span data-ice="name"><span><a href="typedef/index.html#static-typedef-GifRecorder">GifRecorder</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-typedef">T</span><span data-ice="name"><span><a href="typedef/index.html#static-typedef-MRecordRTC">MRecordRTC</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-typedef">T</span><span data-ice="name"><span><a href="typedef/index.html#static-typedef-MediaStreamRecorder">MediaStreamRecorder</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-typedef">T</span><span data-ice="name"><span><a href="typedef/index.html#static-typedef-RecordRTC">RecordRTC</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-typedef">T</span><span data-ice="name"><span><a href="typedef/index.html#static-typedef-RecordRTCConfiguration">RecordRTCConfiguration</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-typedef">T</span><span data-ice="name"><span><a href="typedef/index.html#static-typedef-StereoAudioRecorder">StereoAudioRecorder</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-typedef">T</span><span data-ice="name"><span><a href="typedef/index.html#static-typedef-Whammy">Whammy</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-typedef">T</span><span data-ice="name"><span><a href="typedef/index.html#static-typedef-WhammyRecorder">WhammyRecorder</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-typedef">T</span><span data-ice="name"><span><a href="typedef/index.html#static-typedef-createFileSharingDiv">createFileSharingDiv</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-typedef">T</span><span data-ice="name"><span><a href="typedef/index.html#static-typedef-_turn.js">_turn.js</a></span></span></li>
<li data-ice="doc"><a data-ice="dirPath" class="nav-dir-path" href="identifiers.html#scripts-rtcconn">scripts/rtcconn</a><span data-ice="kind" class="kind-typedef">T</span><span data-ice="name"><span><a href="typedef/index.html#static-typedef-Whammy">Whammy</a></span></span></li>
</ul>
</div>
</nav>

<div class="content" data-ice="content"><h1 data-ice="title">src/codemirror/keymap/sublime.js</h1>
<pre class="source-code line-number raw-source-code"><code class="prettyprint linenums" data-ice="content">// CodeMirror, copyright (c) by Marijn Haverbeke and others
// Distributed under an MIT license: http://codemirror.net/LICENSE

// A rough approximation of Sublime Text&apos;s keybindings
// Depends on addon/search/searchcursor.js and optionally addon/dialog/dialogs.js

(function(mod) {
  if (typeof exports == &quot;object&quot; &amp;&amp; typeof module == &quot;object&quot;) // CommonJS
    mod(require(&quot;../lib/codemirror&quot;), require(&quot;../addon/search/searchcursor&quot;), require(&quot;../addon/edit/matchbrackets&quot;));
  else if (typeof define == &quot;function&quot; &amp;&amp; define.amd) // AMD
    define([&quot;../lib/codemirror&quot;, &quot;../addon/search/searchcursor&quot;, &quot;../addon/edit/matchbrackets&quot;], mod);
  else // Plain browser env
    mod(CodeMirror);
})(function(CodeMirror) {
  &quot;use strict&quot;;

  var map = CodeMirror.keyMap.sublime = {fallthrough: &quot;default&quot;};
  var cmds = CodeMirror.commands;
  var Pos = CodeMirror.Pos;
  var mac = CodeMirror.keyMap[&quot;default&quot;] == CodeMirror.keyMap.macDefault;
  var ctrl = mac ? &quot;Cmd-&quot; : &quot;Ctrl-&quot;;

  // This is not exactly Sublime&apos;s algorithm. I couldn&apos;t make heads or tails of that.
  function findPosSubword(doc, start, dir) {
    if (dir &lt; 0 &amp;&amp; start.ch == 0) return doc.clipPos(Pos(start.line - 1));
    var line = doc.getLine(start.line);
    if (dir &gt; 0 &amp;&amp; start.ch &gt;= line.length) return doc.clipPos(Pos(start.line + 1, 0));
    var state = &quot;start&quot;, type;
    for (var pos = start.ch, e = dir &lt; 0 ? 0 : line.length, i = 0; pos != e; pos += dir, i++) {
      var next = line.charAt(dir &lt; 0 ? pos - 1 : pos);
      var cat = next != &quot;_&quot; &amp;&amp; CodeMirror.isWordChar(next) ? &quot;w&quot; : &quot;o&quot;;
      if (cat == &quot;w&quot; &amp;&amp; next.toUpperCase() == next) cat = &quot;W&quot;;
      if (state == &quot;start&quot;) {
        if (cat != &quot;o&quot;) { state = &quot;in&quot;; type = cat; }
      } else if (state == &quot;in&quot;) {
        if (type != cat) {
          if (type == &quot;w&quot; &amp;&amp; cat == &quot;W&quot; &amp;&amp; dir &lt; 0) pos--;
          if (type == &quot;W&quot; &amp;&amp; cat == &quot;w&quot; &amp;&amp; dir &gt; 0) { type = &quot;w&quot;; continue; }
          break;
        }
      }
    }
    return Pos(start.line, pos);
  }

  function moveSubword(cm, dir) {
    cm.extendSelectionsBy(function(range) {
      if (cm.display.shift || cm.doc.extend || range.empty())
        return findPosSubword(cm.doc, range.head, dir);
      else
        return dir &lt; 0 ? range.from() : range.to();
    });
  }

  cmds[map[&quot;Alt-Left&quot;] = &quot;goSubwordLeft&quot;] = function(cm) { moveSubword(cm, -1); };
  cmds[map[&quot;Alt-Right&quot;] = &quot;goSubwordRight&quot;] = function(cm) { moveSubword(cm, 1); };

  cmds[map[ctrl + &quot;Up&quot;] = &quot;scrollLineUp&quot;] = function(cm) {
    var info = cm.getScrollInfo();
    if (!cm.somethingSelected()) {
      var visibleBottomLine = cm.lineAtHeight(info.top + info.clientHeight, &quot;local&quot;);
      if (cm.getCursor().line &gt;= visibleBottomLine)
        cm.execCommand(&quot;goLineUp&quot;);
    }
    cm.scrollTo(null, info.top - cm.defaultTextHeight());
  };
  cmds[map[ctrl + &quot;Down&quot;] = &quot;scrollLineDown&quot;] = function(cm) {
    var info = cm.getScrollInfo();
    if (!cm.somethingSelected()) {
      var visibleTopLine = cm.lineAtHeight(info.top, &quot;local&quot;)+1;
      if (cm.getCursor().line &lt;= visibleTopLine)
        cm.execCommand(&quot;goLineDown&quot;);
    }
    cm.scrollTo(null, info.top + cm.defaultTextHeight());
  };

  cmds[map[&quot;Shift-&quot; + ctrl + &quot;L&quot;] = &quot;splitSelectionByLine&quot;] = function(cm) {
    var ranges = cm.listSelections(), lineRanges = [];
    for (var i = 0; i &lt; ranges.length; i++) {
      var from = ranges[i].from(), to = ranges[i].to();
      for (var line = from.line; line &lt;= to.line; ++line)
        if (!(to.line &gt; from.line &amp;&amp; line == to.line &amp;&amp; to.ch == 0))
          lineRanges.push({anchor: line == from.line ? from : Pos(line, 0),
                           head: line == to.line ? to : Pos(line)});
    }
    cm.setSelections(lineRanges, 0);
  };

  map[&quot;Shift-Tab&quot;] = &quot;indentLess&quot;;

  cmds[map[&quot;Esc&quot;] = &quot;singleSelectionTop&quot;] = function(cm) {
    var range = cm.listSelections()[0];
    cm.setSelection(range.anchor, range.head, {scroll: false});
  };

  cmds[map[ctrl + &quot;L&quot;] = &quot;selectLine&quot;] = function(cm) {
    var ranges = cm.listSelections(), extended = [];
    for (var i = 0; i &lt; ranges.length; i++) {
      var range = ranges[i];
      extended.push({anchor: Pos(range.from().line, 0),
                     head: Pos(range.to().line + 1, 0)});
    }
    cm.setSelections(extended);
  };

  map[&quot;Shift-&quot; + ctrl + &quot;K&quot;] = &quot;deleteLine&quot;;

  function insertLine(cm, above) {
    cm.operation(function() {
      var len = cm.listSelections().length, newSelection = [], last = -1;
      for (var i = 0; i &lt; len; i++) {
        var head = cm.listSelections()[i].head;
        if (head.line &lt;= last) continue;
        var at = Pos(head.line + (above ? 0 : 1), 0);
        cm.replaceRange(&quot;\n&quot;, at, null, &quot;+insertLine&quot;);
        cm.indentLine(at.line, null, true);
        newSelection.push({head: at, anchor: at});
        last = head.line + 1;
      }
      cm.setSelections(newSelection);
    });
  }

  cmds[map[ctrl + &quot;Enter&quot;] = &quot;insertLineAfter&quot;] = function(cm) { insertLine(cm, false); };

  cmds[map[&quot;Shift-&quot; + ctrl + &quot;Enter&quot;] = &quot;insertLineBefore&quot;] = function(cm) { insertLine(cm, true); };

  function wordAt(cm, pos) {
    var start = pos.ch, end = start, line = cm.getLine(pos.line);
    while (start &amp;&amp; CodeMirror.isWordChar(line.charAt(start - 1))) --start;
    while (end &lt; line.length &amp;&amp; CodeMirror.isWordChar(line.charAt(end))) ++end;
    return {from: Pos(pos.line, start), to: Pos(pos.line, end), word: line.slice(start, end)};
  }

  cmds[map[ctrl + &quot;D&quot;] = &quot;selectNextOccurrence&quot;] = function(cm) {
    var from = cm.getCursor(&quot;from&quot;), to = cm.getCursor(&quot;to&quot;);
    var fullWord = cm.state.sublimeFindFullWord == cm.doc.sel;
    if (CodeMirror.cmpPos(from, to) == 0) {
      var word = wordAt(cm, from);
      if (!word.word) return;
      cm.setSelection(word.from, word.to);
      fullWord = true;
    } else {
      var text = cm.getRange(from, to);
      var query = fullWord ? new RegExp(&quot;\\b&quot; + text + &quot;\\b&quot;) : text;
      var cur = cm.getSearchCursor(query, to);
      if (cur.findNext()) {
        cm.addSelection(cur.from(), cur.to());
      } else {
        cur = cm.getSearchCursor(query, Pos(cm.firstLine(), 0));
        if (cur.findNext())
          cm.addSelection(cur.from(), cur.to());
      }
    }
    if (fullWord)
      cm.state.sublimeFindFullWord = cm.doc.sel;
  };

  var mirror = &quot;(){}[]&quot;;
  function selectBetweenBrackets(cm) {
    var pos = cm.getCursor(), opening = cm.scanForBracket(pos, -1);
    if (!opening) return;
    for (;;) {
      var closing = cm.scanForBracket(pos, 1);
      if (!closing) return;
      if (closing.ch == mirror.charAt(mirror.indexOf(opening.ch) + 1)) {
        cm.setSelection(Pos(opening.pos.line, opening.pos.ch + 1), closing.pos, false);
        return true;
      }
      pos = Pos(closing.pos.line, closing.pos.ch + 1);
    }
  }

  cmds[map[&quot;Shift-&quot; + ctrl + &quot;Space&quot;] = &quot;selectScope&quot;] = function(cm) {
    selectBetweenBrackets(cm) || cm.execCommand(&quot;selectAll&quot;);
  };
  cmds[map[&quot;Shift-&quot; + ctrl + &quot;M&quot;] = &quot;selectBetweenBrackets&quot;] = function(cm) {
    if (!selectBetweenBrackets(cm)) return CodeMirror.Pass;
  };

  cmds[map[ctrl + &quot;M&quot;] = &quot;goToBracket&quot;] = function(cm) {
    cm.extendSelectionsBy(function(range) {
      var next = cm.scanForBracket(range.head, 1);
      if (next &amp;&amp; CodeMirror.cmpPos(next.pos, range.head) != 0) return next.pos;
      var prev = cm.scanForBracket(range.head, -1);
      return prev &amp;&amp; Pos(prev.pos.line, prev.pos.ch + 1) || range.head;
    });
  };

  var swapLineCombo = mac ? &quot;Cmd-Ctrl-&quot; : &quot;Shift-Ctrl-&quot;;

  cmds[map[swapLineCombo + &quot;Up&quot;] = &quot;swapLineUp&quot;] = function(cm) {
    var ranges = cm.listSelections(), linesToMove = [], at = cm.firstLine() - 1, newSels = [];
    for (var i = 0; i &lt; ranges.length; i++) {
      var range = ranges[i], from = range.from().line - 1, to = range.to().line;
      newSels.push({anchor: Pos(range.anchor.line - 1, range.anchor.ch),
                    head: Pos(range.head.line - 1, range.head.ch)});
      if (range.to().ch == 0 &amp;&amp; !range.empty()) --to;
      if (from &gt; at) linesToMove.push(from, to);
      else if (linesToMove.length) linesToMove[linesToMove.length - 1] = to;
      at = to;
    }
    cm.operation(function() {
      for (var i = 0; i &lt; linesToMove.length; i += 2) {
        var from = linesToMove[i], to = linesToMove[i + 1];
        var line = cm.getLine(from);
        cm.replaceRange(&quot;&quot;, Pos(from, 0), Pos(from + 1, 0), &quot;+swapLine&quot;);
        if (to &gt; cm.lastLine())
          cm.replaceRange(&quot;\n&quot; + line, Pos(cm.lastLine()), null, &quot;+swapLine&quot;);
        else
          cm.replaceRange(line + &quot;\n&quot;, Pos(to, 0), null, &quot;+swapLine&quot;);
      }
      cm.setSelections(newSels);
      cm.scrollIntoView();
    });
  };

  cmds[map[swapLineCombo + &quot;Down&quot;] = &quot;swapLineDown&quot;] = function(cm) {
    var ranges = cm.listSelections(), linesToMove = [], at = cm.lastLine() + 1;
    for (var i = ranges.length - 1; i &gt;= 0; i--) {
      var range = ranges[i], from = range.to().line + 1, to = range.from().line;
      if (range.to().ch == 0 &amp;&amp; !range.empty()) from--;
      if (from &lt; at) linesToMove.push(from, to);
      else if (linesToMove.length) linesToMove[linesToMove.length - 1] = to;
      at = to;
    }
    cm.operation(function() {
      for (var i = linesToMove.length - 2; i &gt;= 0; i -= 2) {
        var from = linesToMove[i], to = linesToMove[i + 1];
        var line = cm.getLine(from);
        if (from == cm.lastLine())
          cm.replaceRange(&quot;&quot;, Pos(from - 1), Pos(from), &quot;+swapLine&quot;);
        else
          cm.replaceRange(&quot;&quot;, Pos(from, 0), Pos(from + 1, 0), &quot;+swapLine&quot;);
        cm.replaceRange(line + &quot;\n&quot;, Pos(to, 0), null, &quot;+swapLine&quot;);
      }
      cm.scrollIntoView();
    });
  };

  map[ctrl + &quot;/&quot;] = &quot;toggleComment&quot;;

  cmds[map[ctrl + &quot;J&quot;] = &quot;joinLines&quot;] = function(cm) {
    var ranges = cm.listSelections(), joined = [];
    for (var i = 0; i &lt; ranges.length; i++) {
      var range = ranges[i], from = range.from();
      var start = from.line, end = range.to().line;
      while (i &lt; ranges.length - 1 &amp;&amp; ranges[i + 1].from().line == end)
        end = ranges[++i].to().line;
      joined.push({start: start, end: end, anchor: !range.empty() &amp;&amp; from});
    }
    cm.operation(function() {
      var offset = 0, ranges = [];
      for (var i = 0; i &lt; joined.length; i++) {
        var obj = joined[i];
        var anchor = obj.anchor &amp;&amp; Pos(obj.anchor.line - offset, obj.anchor.ch), head;
        for (var line = obj.start; line &lt;= obj.end; line++) {
          var actual = line - offset;
          if (line == obj.end) head = Pos(actual, cm.getLine(actual).length + 1);
          if (actual &lt; cm.lastLine()) {
            cm.replaceRange(&quot; &quot;, Pos(actual), Pos(actual + 1, /^\s*/.exec(cm.getLine(actual + 1))[0].length));
            ++offset;
          }
        }
        ranges.push({anchor: anchor || head, head: head});
      }
      cm.setSelections(ranges, 0);
    });
  };

  cmds[map[&quot;Shift-&quot; + ctrl + &quot;D&quot;] = &quot;duplicateLine&quot;] = function(cm) {
    cm.operation(function() {
      var rangeCount = cm.listSelections().length;
      for (var i = 0; i &lt; rangeCount; i++) {
        var range = cm.listSelections()[i];
        if (range.empty())
          cm.replaceRange(cm.getLine(range.head.line) + &quot;\n&quot;, Pos(range.head.line, 0));
        else
          cm.replaceRange(cm.getRange(range.from(), range.to()), range.from());
      }
      cm.scrollIntoView();
    });
  };

  map[ctrl + &quot;T&quot;] = &quot;transposeChars&quot;;

  function sortLines(cm, caseSensitive) {
    var ranges = cm.listSelections(), toSort = [], selected;
    for (var i = 0; i &lt; ranges.length; i++) {
      var range = ranges[i];
      if (range.empty()) continue;
      var from = range.from().line, to = range.to().line;
      while (i &lt; ranges.length - 1 &amp;&amp; ranges[i + 1].from().line == to)
        to = range[++i].to().line;
      toSort.push(from, to);
    }
    if (toSort.length) selected = true;
    else toSort.push(cm.firstLine(), cm.lastLine());

    cm.operation(function() {
      var ranges = [];
      for (var i = 0; i &lt; toSort.length; i += 2) {
        var from = toSort[i], to = toSort[i + 1];
        var start = Pos(from, 0), end = Pos(to);
        var lines = cm.getRange(start, end, false);
        if (caseSensitive)
          lines.sort();
        else
          lines.sort(function(a, b) {
            var au = a.toUpperCase(), bu = b.toUpperCase();
            if (au != bu) { a = au; b = bu; }
            return a &lt; b ? -1 : a == b ? 0 : 1;
          });
        cm.replaceRange(lines, start, end);
        if (selected) ranges.push({anchor: start, head: end});
      }
      if (selected) cm.setSelections(ranges, 0);
    });
  }

  cmds[map[&quot;F9&quot;] = &quot;sortLines&quot;] = function(cm) { sortLines(cm, true); };
  cmds[map[ctrl + &quot;F9&quot;] = &quot;sortLinesInsensitive&quot;] = function(cm) { sortLines(cm, false); };

  cmds[map[&quot;F2&quot;] = &quot;nextBookmark&quot;] = function(cm) {
    var marks = cm.state.sublimeBookmarks;
    if (marks) while (marks.length) {
      var current = marks.shift();
      var found = current.find();
      if (found) {
        marks.push(current);
        return cm.setSelection(found.from, found.to);
      }
    }
  };

  cmds[map[&quot;Shift-F2&quot;] = &quot;prevBookmark&quot;] = function(cm) {
    var marks = cm.state.sublimeBookmarks;
    if (marks) while (marks.length) {
      marks.unshift(marks.pop());
      var found = marks[marks.length - 1].find();
      if (!found)
        marks.pop();
      else
        return cm.setSelection(found.from, found.to);
    }
  };

  cmds[map[ctrl + &quot;F2&quot;] = &quot;toggleBookmark&quot;] = function(cm) {
    var ranges = cm.listSelections();
    var marks = cm.state.sublimeBookmarks || (cm.state.sublimeBookmarks = []);
    for (var i = 0; i &lt; ranges.length; i++) {
      var from = ranges[i].from(), to = ranges[i].to();
      var found = cm.findMarks(from, to);
      for (var j = 0; j &lt; found.length; j++) {
        if (found[j].sublimeBookmark) {
          found[j].clear();
          for (var k = 0; k &lt; marks.length; k++)
            if (marks[k] == found[j])
              marks.splice(k--, 1);
          break;
        }
      }
      if (j == found.length)
        marks.push(cm.markText(from, to, {sublimeBookmark: true, clearWhenEmpty: false}));
    }
  };

  cmds[map[&quot;Shift-&quot; + ctrl + &quot;F2&quot;] = &quot;clearBookmarks&quot;] = function(cm) {
    var marks = cm.state.sublimeBookmarks;
    if (marks) for (var i = 0; i &lt; marks.length; i++) marks[i].clear();
    marks.length = 0;
  };

  cmds[map[&quot;Alt-F2&quot;] = &quot;selectBookmarks&quot;] = function(cm) {
    var marks = cm.state.sublimeBookmarks, ranges = [];
    if (marks) for (var i = 0; i &lt; marks.length; i++) {
      var found = marks[i].find();
      if (!found)
        marks.splice(i--, 0);
      else
        ranges.push({anchor: found.from, head: found.to});
    }
    if (ranges.length)
      cm.setSelections(ranges, 0);
  };

  map[&quot;Alt-Q&quot;] = &quot;wrapLines&quot;;

  var mapK = CodeMirror.keyMap[&quot;sublime-Ctrl-K&quot;] = {auto: &quot;sublime&quot;, nofallthrough: true};

  map[ctrl + &quot;K&quot;] = function(cm) {cm.setOption(&quot;keyMap&quot;, &quot;sublime-Ctrl-K&quot;);};

  function modifyWordOrSelection(cm, mod) {
    cm.operation(function() {
      var ranges = cm.listSelections(), indices = [], replacements = [];
      for (var i = 0; i &lt; ranges.length; i++) {
        var range = ranges[i];
        if (range.empty()) { indices.push(i); replacements.push(&quot;&quot;); }
        else replacements.push(mod(cm.getRange(range.from(), range.to())));
      }
      cm.replaceSelections(replacements, &quot;around&quot;, &quot;case&quot;);
      for (var i = indices.length - 1, at; i &gt;= 0; i--) {
        var range = ranges[indices[i]];
        if (at &amp;&amp; CodeMirror.cmpPos(range.head, at) &gt; 0) continue;
        var word = wordAt(cm, range.head);
        at = word.from;
        cm.replaceRange(mod(word.word), word.from, word.to);
      }
    });
  }

  mapK[ctrl + &quot;Backspace&quot;] = &quot;delLineLeft&quot;;

  cmds[mapK[ctrl + &quot;K&quot;] = &quot;delLineRight&quot;] = function(cm) {
    cm.operation(function() {
      var ranges = cm.listSelections();
      for (var i = ranges.length - 1; i &gt;= 0; i--)
        cm.replaceRange(&quot;&quot;, ranges[i].anchor, Pos(ranges[i].to().line), &quot;+delete&quot;);
      cm.scrollIntoView();
    });
  };

  cmds[mapK[ctrl + &quot;U&quot;] = &quot;upcaseAtCursor&quot;] = function(cm) {
    modifyWordOrSelection(cm, function(str) { return str.toUpperCase(); });
  };
  cmds[mapK[ctrl + &quot;L&quot;] = &quot;downcaseAtCursor&quot;] = function(cm) {
    modifyWordOrSelection(cm, function(str) { return str.toLowerCase(); });
  };

  cmds[mapK[ctrl + &quot;Space&quot;] = &quot;setSublimeMark&quot;] = function(cm) {
    if (cm.state.sublimeMark) cm.state.sublimeMark.clear();
    cm.state.sublimeMark = cm.setBookmark(cm.getCursor());
  };
  cmds[mapK[ctrl + &quot;A&quot;] = &quot;selectToSublimeMark&quot;] = function(cm) {
    var found = cm.state.sublimeMark &amp;&amp; cm.state.sublimeMark.find();
    if (found) cm.setSelection(cm.getCursor(), found);
  };
  cmds[mapK[ctrl + &quot;W&quot;] = &quot;deleteToSublimeMark&quot;] = function(cm) {
    var found = cm.state.sublimeMark &amp;&amp; cm.state.sublimeMark.find();
    if (found) {
      var from = cm.getCursor(), to = found;
      if (CodeMirror.cmpPos(from, to) &gt; 0) { var tmp = to; to = from; from = tmp; }
      cm.state.sublimeKilled = cm.getRange(from, to);
      cm.replaceRange(&quot;&quot;, from, to);
    }
  };
  cmds[mapK[ctrl + &quot;X&quot;] = &quot;swapWithSublimeMark&quot;] = function(cm) {
    var found = cm.state.sublimeMark &amp;&amp; cm.state.sublimeMark.find();
    if (found) {
      cm.state.sublimeMark.clear();
      cm.state.sublimeMark = cm.setBookmark(cm.getCursor());
      cm.setCursor(found);
    }
  };
  cmds[mapK[ctrl + &quot;Y&quot;] = &quot;sublimeYank&quot;] = function(cm) {
    if (cm.state.sublimeKilled != null)
      cm.replaceSelection(cm.state.sublimeKilled, null, &quot;paste&quot;);
  };

  mapK[ctrl + &quot;G&quot;] = &quot;clearBookmarks&quot;;
  cmds[mapK[ctrl + &quot;C&quot;] = &quot;showInCenter&quot;] = function(cm) {
    var pos = cm.cursorCoords(null, &quot;local&quot;);
    cm.scrollTo(null, (pos.top + pos.bottom) / 2 - cm.getScrollInfo().clientHeight / 2);
  };

  cmds[map[&quot;Shift-Alt-Up&quot;] = &quot;selectLinesUpward&quot;] = function(cm) {
    cm.operation(function() {
      var ranges = cm.listSelections();
      for (var i = 0; i &lt; ranges.length; i++) {
        var range = ranges[i];
        if (range.head.line &gt; cm.firstLine())
          cm.addSelection(Pos(range.head.line - 1, range.head.ch));
      }
    });
  };
  cmds[map[&quot;Shift-Alt-Down&quot;] = &quot;selectLinesDownward&quot;] = function(cm) {
    cm.operation(function() {
      var ranges = cm.listSelections();
      for (var i = 0; i &lt; ranges.length; i++) {
        var range = ranges[i];
        if (range.head.line &lt; cm.lastLine())
          cm.addSelection(Pos(range.head.line + 1, range.head.ch));
      }
    });
  };

  function getTarget(cm) {
    var from = cm.getCursor(&quot;from&quot;), to = cm.getCursor(&quot;to&quot;);
    if (CodeMirror.cmpPos(from, to) == 0) {
      var word = wordAt(cm, from);
      if (!word.word) return;
      from = word.from;
      to = word.to;
    }
    return {from: from, to: to, query: cm.getRange(from, to), word: word};
  }

  function findAndGoTo(cm, forward) {
    var target = getTarget(cm);
    if (!target) return;
    var query = target.query;
    var cur = cm.getSearchCursor(query, forward ? target.to : target.from);

    if (forward ? cur.findNext() : cur.findPrevious()) {
      cm.setSelection(cur.from(), cur.to());
    } else {
      cur = cm.getSearchCursor(query, forward ? Pos(cm.firstLine(), 0)
                                              : cm.clipPos(Pos(cm.lastLine())));
      if (forward ? cur.findNext() : cur.findPrevious())
        cm.setSelection(cur.from(), cur.to());
      else if (target.word)
        cm.setSelection(target.from, target.to);
    }
  };
  cmds[map[ctrl + &quot;F3&quot;] = &quot;findUnder&quot;] = function(cm) { findAndGoTo(cm, true); };
  cmds[map[&quot;Shift-&quot; + ctrl + &quot;F3&quot;] = &quot;findUnderPrevious&quot;] = function(cm) { findAndGoTo(cm,false); };
  cmds[map[&quot;Alt-F3&quot;] = &quot;findAllUnder&quot;] = function(cm) {
    var target = getTarget(cm);
    if (!target) return;
    var cur = cm.getSearchCursor(target.query);
    var matches = [];
    var primaryIndex = -1;
    while (cur.findNext()) {
      matches.push({anchor: cur.from(), head: cur.to()});
      if (cur.from().line &lt;= target.from.line &amp;&amp; cur.from().ch &lt;= target.from.ch)
        primaryIndex++;
    }
    cm.setSelections(matches, primaryIndex);
  };

  map[&quot;Shift-&quot; + ctrl + &quot;[&quot;] = &quot;fold&quot;;
  map[&quot;Shift-&quot; + ctrl + &quot;]&quot;] = &quot;unfold&quot;;
  mapK[ctrl + &quot;0&quot;] = mapK[ctrl + &quot;j&quot;] = &quot;unfoldAll&quot;;

  map[ctrl + &quot;I&quot;] = &quot;findIncremental&quot;;
  map[&quot;Shift-&quot; + ctrl + &quot;I&quot;] = &quot;findIncrementalReverse&quot;;
  map[ctrl + &quot;H&quot;] = &quot;replace&quot;;
  map[&quot;F3&quot;] = &quot;findNext&quot;;
  map[&quot;Shift-F3&quot;] = &quot;findPrev&quot;;

});
</code></pre>

</div>

<footer class="footer">
  Generated by <a href="https://esdoc.org">ESDoc<span data-ice="esdocVersion">(1.1.0)</span><img src="./image/esdoc-logo-mini-black.png"></a>
</footer>

<script src="script/search_index.js"></script>
<script src="script/search.js"></script>
<script src="script/pretty-print.js"></script>
<script src="script/inherited-summary.js"></script>
<script src="script/test-summary.js"></script>
<script src="script/inner-link.js"></script>
<script src="script/patch-for-local.js"></script>
</body>
</html>
