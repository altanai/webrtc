<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <base data-ice="baseUrl" href="../../../../../">
  <title data-ice="title">src/codemirror/addon/merge/merge.js | webrtcdevelopment</title>
  <link type="text/css" rel="stylesheet" href="css/style.css">
  <link type="text/css" rel="stylesheet" href="css/prettify-tomorrow.css">
  <script src="script/prettify/prettify.js"></script>
  <script src="script/manual.js"></script>
<meta name="description" content="webrtc based communication and collaboration client. Contains lot of experiments modules "><meta property="twitter:card" content="summary"><meta property="twitter:title" content="webrtcdevelopment"><meta property="twitter:description" content="webrtc based communication and collaboration client. Contains lot of experiments modules "></head>
<body class="layout-container" data-ice="rootContainer">

<header>
  <a href="./">Home</a>
  
  <a href="identifiers.html">Reference</a>
  <a href="source.html">Source</a>
  
  <div class="search-box">
  <span>
    <img src="./image/search.png">
    <span class="search-input-edge"></span><input class="search-input"><span class="search-input-edge"></span>
  </span>
    <ul class="search-result"></ul>
  </div>
<a style="position:relative; top:3px;" href="https://github.com/altanai/webrtc"><img width="20px" src="./image/github.png"></a></header>

<nav class="navigation" data-ice="nav"><div>
  <ul>
    
  <li data-ice="doc"><a data-ice="dirPath" class="nav-dir-path" href="identifiers.html#scripts">scripts</a><span data-ice="kind" class="kind-typedef">T</span><span data-ice="name"><span><a href="typedef/index.html#static-typedef-CanvasRecorder">CanvasRecorder</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-typedef">T</span><span data-ice="name"><span><a href="typedef/index.html#static-typedef-GetRecorderType">GetRecorderType</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-typedef">T</span><span data-ice="name"><span><a href="typedef/index.html#static-typedef-GifRecorder">GifRecorder</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-typedef">T</span><span data-ice="name"><span><a href="typedef/index.html#static-typedef-MRecordRTC">MRecordRTC</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-typedef">T</span><span data-ice="name"><span><a href="typedef/index.html#static-typedef-MediaStreamRecorder">MediaStreamRecorder</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-typedef">T</span><span data-ice="name"><span><a href="typedef/index.html#static-typedef-RecordRTC">RecordRTC</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-typedef">T</span><span data-ice="name"><span><a href="typedef/index.html#static-typedef-RecordRTCConfiguration">RecordRTCConfiguration</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-typedef">T</span><span data-ice="name"><span><a href="typedef/index.html#static-typedef-StereoAudioRecorder">StereoAudioRecorder</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-typedef">T</span><span data-ice="name"><span><a href="typedef/index.html#static-typedef-Whammy">Whammy</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-typedef">T</span><span data-ice="name"><span><a href="typedef/index.html#static-typedef-WhammyRecorder">WhammyRecorder</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-typedef">T</span><span data-ice="name"><span><a href="typedef/index.html#static-typedef-createFileSharingDiv">createFileSharingDiv</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-typedef">T</span><span data-ice="name"><span><a href="typedef/index.html#static-typedef-_turn.js">_turn.js</a></span></span></li>
<li data-ice="doc"><a data-ice="dirPath" class="nav-dir-path" href="identifiers.html#scripts-rtcconn">scripts/rtcconn</a><span data-ice="kind" class="kind-typedef">T</span><span data-ice="name"><span><a href="typedef/index.html#static-typedef-Whammy">Whammy</a></span></span></li>
</ul>
</div>
</nav>

<div class="content" data-ice="content"><h1 data-ice="title">src/codemirror/addon/merge/merge.js</h1>
<pre class="source-code line-number raw-source-code"><code class="prettyprint linenums" data-ice="content">// CodeMirror, copyright (c) by Marijn Haverbeke and others
// Distributed under an MIT license: http://codemirror.net/LICENSE

// declare global: diff_match_patch, DIFF_INSERT, DIFF_DELETE, DIFF_EQUAL

(function(mod) {
  if (typeof exports == &quot;object&quot; &amp;&amp; typeof module == &quot;object&quot;) // CommonJS
    mod(require(&quot;../../lib/codemirror&quot;), require(&quot;diff_match_patch&quot;));
  else if (typeof define == &quot;function&quot; &amp;&amp; define.amd) // AMD
    define([&quot;../../lib/codemirror&quot;, &quot;diff_match_patch&quot;], mod);
  else // Plain browser env
    mod(CodeMirror, diff_match_patch);
})(function(CodeMirror, diff_match_patch) {
  &quot;use strict&quot;;
  var Pos = CodeMirror.Pos;
  var svgNS = &quot;http://www.w3.org/2000/svg&quot;;

  function DiffView(mv, type) {
    this.mv = mv;
    this.type = type;
    this.classes = type == &quot;left&quot;
      ? {chunk: &quot;CodeMirror-merge-l-chunk&quot;,
         start: &quot;CodeMirror-merge-l-chunk-start&quot;,
         end: &quot;CodeMirror-merge-l-chunk-end&quot;,
         insert: &quot;CodeMirror-merge-l-inserted&quot;,
         del: &quot;CodeMirror-merge-l-deleted&quot;,
         connect: &quot;CodeMirror-merge-l-connect&quot;}
      : {chunk: &quot;CodeMirror-merge-r-chunk&quot;,
         start: &quot;CodeMirror-merge-r-chunk-start&quot;,
         end: &quot;CodeMirror-merge-r-chunk-end&quot;,
         insert: &quot;CodeMirror-merge-r-inserted&quot;,
         del: &quot;CodeMirror-merge-r-deleted&quot;,
         connect: &quot;CodeMirror-merge-r-connect&quot;};
  }

  DiffView.prototype = {
    constructor: DiffView,
    init: function(pane, orig, options) {
      this.edit = this.mv.edit;
      this.orig = CodeMirror(pane, copyObj({value: orig, readOnly: !this.mv.options.allowEditingOriginals}, copyObj(options)));

      this.diff = getDiff(asString(orig), asString(options.value));
      this.diffOutOfDate = false;

      this.showDifferences = options.showDifferences !== false;
      this.forceUpdate = registerUpdate(this);
      setScrollLock(this, true, false);
      registerScroll(this);
    },
    setShowDifferences: function(val) {
      val = val !== false;
      if (val != this.showDifferences) {
        this.showDifferences = val;
        this.forceUpdate(&quot;full&quot;);
      }
    }
  };

  function ensureDiff(dv) {
    if (dv.diffOutOfDate) {
      dv.diff = getDiff(dv.orig.getValue(), dv.edit.getValue());
      dv.diffOutOfDate = false;
      CodeMirror.signal(dv.edit, &quot;updateDiff&quot;, dv.diff);
    }
  }

  function registerUpdate(dv) {
    var edit = {from: 0, to: 0, marked: []};
    var orig = {from: 0, to: 0, marked: []};
    var debounceChange;
    function update(mode) {
      if (mode == &quot;full&quot;) {
        if (dv.svg) clear(dv.svg);
        if (dv.copyButtons) clear(dv.copyButtons);
        clearMarks(dv.edit, edit.marked, dv.classes);
        clearMarks(dv.orig, orig.marked, dv.classes);
        edit.from = edit.to = orig.from = orig.to = 0;
      }
      ensureDiff(dv);
      if (dv.showDifferences) {
        updateMarks(dv.edit, dv.diff, edit, DIFF_INSERT, dv.classes);
        updateMarks(dv.orig, dv.diff, orig, DIFF_DELETE, dv.classes);
      }
      drawConnectors(dv);
    }
    function set(slow) {
      clearTimeout(debounceChange);
      debounceChange = setTimeout(update, slow == true ? 250 : 100);
    }
    function change() {
      if (!dv.diffOutOfDate) {
        dv.diffOutOfDate = true;
        edit.from = edit.to = orig.from = orig.to = 0;
      }
      set(true);
    }
    dv.edit.on(&quot;change&quot;, change);
    dv.orig.on(&quot;change&quot;, change);
    dv.edit.on(&quot;markerAdded&quot;, set);
    dv.edit.on(&quot;markerCleared&quot;, set);
    dv.orig.on(&quot;markerAdded&quot;, set);
    dv.orig.on(&quot;markerCleared&quot;, set);
    dv.edit.on(&quot;viewportChange&quot;, set);
    dv.orig.on(&quot;viewportChange&quot;, set);
    update();
    return update;
  }

  function registerScroll(dv) {
    dv.edit.on(&quot;scroll&quot;, function() {
      syncScroll(dv, DIFF_INSERT) &amp;&amp; drawConnectors(dv);
    });
    dv.orig.on(&quot;scroll&quot;, function() {
      syncScroll(dv, DIFF_DELETE) &amp;&amp; drawConnectors(dv);
    });
  }

  function syncScroll(dv, type) {
    // Change handler will do a refresh after a timeout when diff is out of date
    if (dv.diffOutOfDate) return false;
    if (!dv.lockScroll) return true;
    var editor, other, now = +new Date;
    if (type == DIFF_INSERT) { editor = dv.edit; other = dv.orig; }
    else { editor = dv.orig; other = dv.edit; }
    // Don&apos;t take action if the position of this editor was recently set
    // (to prevent feedback loops)
    if (editor.state.scrollSetBy == dv &amp;&amp; (editor.state.scrollSetAt || 0) + 50 &gt; now) return false;

    var sInfo = editor.getScrollInfo(), halfScreen = .5 * sInfo.clientHeight, midY = sInfo.top + halfScreen;
    var mid = editor.lineAtHeight(midY, &quot;local&quot;);
    var around = chunkBoundariesAround(dv.diff, mid, type == DIFF_INSERT);
    var off = getOffsets(editor, type == DIFF_INSERT ? around.edit : around.orig);
    var offOther = getOffsets(other, type == DIFF_INSERT ? around.orig : around.edit);
    var ratio = (midY - off.top) / (off.bot - off.top);
    var targetPos = (offOther.top - halfScreen) + ratio * (offOther.bot - offOther.top);

    var botDist, mix;
    // Some careful tweaking to make sure no space is left out of view
    // when scrolling to top or bottom.
    if (targetPos &gt; sInfo.top &amp;&amp; (mix = sInfo.top / halfScreen) &lt; 1) {
      targetPos = targetPos * mix + sInfo.top * (1 - mix);
    } else if ((botDist = sInfo.height - sInfo.clientHeight - sInfo.top) &lt; halfScreen) {
      var otherInfo = other.getScrollInfo();
      var botDistOther = otherInfo.height - otherInfo.clientHeight - targetPos;
      if (botDistOther &gt; botDist &amp;&amp; (mix = botDist / halfScreen) &lt; 1)
        targetPos = targetPos * mix + (otherInfo.height - otherInfo.clientHeight - botDist) * (1 - mix);
    }

    other.scrollTo(sInfo.left, targetPos);
    other.state.scrollSetAt = now;
    other.state.scrollSetBy = dv;
    return true;
  }

  function getOffsets(editor, around) {
    var bot = around.after;
    if (bot == null) bot = editor.lastLine() + 1;
    return {top: editor.heightAtLine(around.before || 0, &quot;local&quot;),
            bot: editor.heightAtLine(bot, &quot;local&quot;)};
  }

  function setScrollLock(dv, val, action) {
    dv.lockScroll = val;
    if (val &amp;&amp; action != false) syncScroll(dv, DIFF_INSERT) &amp;&amp; drawConnectors(dv);
    dv.lockButton.innerHTML = val ? &quot;\u21db\u21da&quot; : &quot;\u21db&amp;nbsp;&amp;nbsp;\u21da&quot;;
  }

  // Updating the marks for editor content

  function clearMarks(editor, arr, classes) {
    for (var i = 0; i &lt; arr.length; ++i) {
      var mark = arr[i];
      if (mark instanceof CodeMirror.TextMarker) {
        mark.clear();
      } else if (mark.parent) {
        editor.removeLineClass(mark, &quot;background&quot;, classes.chunk);
        editor.removeLineClass(mark, &quot;background&quot;, classes.start);
        editor.removeLineClass(mark, &quot;background&quot;, classes.end);
      }
    }
    arr.length = 0;
  }

  // FIXME maybe add a margin around viewport to prevent too many updates
  function updateMarks(editor, diff, state, type, classes) {
    var vp = editor.getViewport();
    editor.operation(function() {
      if (state.from == state.to || vp.from - state.to &gt; 20 || state.from - vp.to &gt; 20) {
        clearMarks(editor, state.marked, classes);
        markChanges(editor, diff, type, state.marked, vp.from, vp.to, classes);
        state.from = vp.from; state.to = vp.to;
      } else {
        if (vp.from &lt; state.from) {
          markChanges(editor, diff, type, state.marked, vp.from, state.from, classes);
          state.from = vp.from;
        }
        if (vp.to &gt; state.to) {
          markChanges(editor, diff, type, state.marked, state.to, vp.to, classes);
          state.to = vp.to;
        }
      }
    });
  }

  function markChanges(editor, diff, type, marks, from, to, classes) {
    var pos = Pos(0, 0);
    var top = Pos(from, 0), bot = editor.clipPos(Pos(to - 1));
    var cls = type == DIFF_DELETE ? classes.del : classes.insert;
    function markChunk(start, end) {
      var bfrom = Math.max(from, start), bto = Math.min(to, end);
      for (var i = bfrom; i &lt; bto; ++i) {
        var line = editor.addLineClass(i, &quot;background&quot;, classes.chunk);
        if (i == start) editor.addLineClass(line, &quot;background&quot;, classes.start);
        if (i == end - 1) editor.addLineClass(line, &quot;background&quot;, classes.end);
        marks.push(line);
      }
      // When the chunk is empty, make sure a horizontal line shows up
      if (start == end &amp;&amp; bfrom == end &amp;&amp; bto == end) {
        if (bfrom)
          marks.push(editor.addLineClass(bfrom - 1, &quot;background&quot;, classes.end));
        else
          marks.push(editor.addLineClass(bfrom, &quot;background&quot;, classes.start));
      }
    }

    var chunkStart = 0;
    for (var i = 0; i &lt; diff.length; ++i) {
      var part = diff[i], tp = part[0], str = part[1];
      if (tp == DIFF_EQUAL) {
        var cleanFrom = pos.line + (startOfLineClean(diff, i) ? 0 : 1);
        moveOver(pos, str);
        var cleanTo = pos.line + (endOfLineClean(diff, i) ? 1 : 0);
        if (cleanTo &gt; cleanFrom) {
          if (i) markChunk(chunkStart, cleanFrom);
          chunkStart = cleanTo;
        }
      } else {
        if (tp == type) {
          var end = moveOver(pos, str, true);
          var a = posMax(top, pos), b = posMin(bot, end);
          if (!posEq(a, b))
            marks.push(editor.markText(a, b, {className: cls}));
          pos = end;
        }
      }
    }
    if (chunkStart &lt;= pos.line) markChunk(chunkStart, pos.line + 1);
  }

  // Updating the gap between editor and original

  function drawConnectors(dv) {
    if (!dv.showDifferences) return;

    if (dv.svg) {
      clear(dv.svg);
      var w = dv.gap.offsetWidth;
      attrs(dv.svg, &quot;width&quot;, w, &quot;height&quot;, dv.gap.offsetHeight);
    }
    if (dv.copyButtons) clear(dv.copyButtons);

    var flip = dv.type == &quot;left&quot;;
    var vpEdit = dv.edit.getViewport(), vpOrig = dv.orig.getViewport();
    var sTopEdit = dv.edit.getScrollInfo().top, sTopOrig = dv.orig.getScrollInfo().top;
    iterateChunks(dv.diff, function(topOrig, botOrig, topEdit, botEdit) {
      if (topEdit &gt; vpEdit.to || botEdit &lt; vpEdit.from ||
          topOrig &gt; vpOrig.to || botOrig &lt; vpOrig.from)
        return;
      var topLpx = dv.orig.heightAtLine(topOrig, &quot;local&quot;) - sTopOrig, top = topLpx;
      if (dv.svg) {
        var topRpx = dv.edit.heightAtLine(topEdit, &quot;local&quot;) - sTopEdit;
        if (flip) { var tmp = topLpx; topLpx = topRpx; topRpx = tmp; }
        var botLpx = dv.orig.heightAtLine(botOrig, &quot;local&quot;) - sTopOrig;
        var botRpx = dv.edit.heightAtLine(botEdit, &quot;local&quot;) - sTopEdit;
        if (flip) { var tmp = botLpx; botLpx = botRpx; botRpx = tmp; }
        var curveTop = &quot; C &quot; + w/2 + &quot; &quot; + topRpx + &quot; &quot; + w/2 + &quot; &quot; + topLpx + &quot; &quot; + (w + 2) + &quot; &quot; + topLpx;
        var curveBot = &quot; C &quot; + w/2 + &quot; &quot; + botLpx + &quot; &quot; + w/2 + &quot; &quot; + botRpx + &quot; -1 &quot; + botRpx;
        attrs(dv.svg.appendChild(document.createElementNS(svgNS, &quot;path&quot;)),
              &quot;d&quot;, &quot;M -1 &quot; + topRpx + curveTop + &quot; L &quot; + (w + 2) + &quot; &quot; + botLpx + curveBot + &quot; z&quot;,
              &quot;class&quot;, dv.classes.connect);
      }
      if (dv.copyButtons) {
        var copy = dv.copyButtons.appendChild(elt(&quot;div&quot;, dv.type == &quot;left&quot; ? &quot;\u21dd&quot; : &quot;\u21dc&quot;,
                                                  &quot;CodeMirror-merge-copy&quot;));
        var editOriginals = dv.mv.options.allowEditingOriginals;
        copy.title = editOriginals ? &quot;Push to left&quot; : &quot;Revert chunk&quot;;
        copy.chunk = {topEdit: topEdit, botEdit: botEdit, topOrig: topOrig, botOrig: botOrig};
        copy.style.top = top + &quot;px&quot;;

        if (editOriginals) {
          var topReverse = dv.orig.heightAtLine(topEdit, &quot;local&quot;) - sTopEdit;
          var copyReverse = dv.copyButtons.appendChild(elt(&quot;div&quot;, dv.type == &quot;right&quot; ? &quot;\u21dd&quot; : &quot;\u21dc&quot;,
                                                           &quot;CodeMirror-merge-copy-reverse&quot;));
          copyReverse.title = &quot;Push to right&quot;;
          copyReverse.chunk = {topEdit: topOrig, botEdit: botOrig, topOrig: topEdit, botOrig: botEdit};
          copyReverse.style.top = topReverse + &quot;px&quot;;
          dv.type == &quot;right&quot; ? copyReverse.style.left = &quot;2px&quot; : copyReverse.style.right = &quot;2px&quot;;
        }
      }
    });
  }

  function copyChunk(dv, to, from, chunk) {
    if (dv.diffOutOfDate) return;
    to.replaceRange(from.getRange(Pos(chunk.topOrig, 0), Pos(chunk.botOrig, 0)),
                         Pos(chunk.topEdit, 0), Pos(chunk.botEdit, 0));
  }

  // Merge view, containing 0, 1, or 2 diff views.

  var MergeView = CodeMirror.MergeView = function(node, options) {
    if (!(this instanceof MergeView)) return new MergeView(node, options);

    this.options = options;
    var origLeft = options.origLeft, origRight = options.origRight == null ? options.orig : options.origRight;
    var hasLeft = origLeft != null, hasRight = origRight != null;
    var panes = 1 + (hasLeft ? 1 : 0) + (hasRight ? 1 : 0);
    var wrap = [], left = this.left = null, right = this.right = null;

    if (hasLeft) {
      left = this.left = new DiffView(this, &quot;left&quot;);
      var leftPane = elt(&quot;div&quot;, null, &quot;CodeMirror-merge-pane&quot;);
      wrap.push(leftPane);
      wrap.push(buildGap(left));
    }

    var editPane = elt(&quot;div&quot;, null, &quot;CodeMirror-merge-pane&quot;);
    wrap.push(editPane);

    if (hasRight) {
      right = this.right = new DiffView(this, &quot;right&quot;);
      wrap.push(buildGap(right));
      var rightPane = elt(&quot;div&quot;, null, &quot;CodeMirror-merge-pane&quot;);
      wrap.push(rightPane);
    }

    (hasRight ? rightPane : editPane).className += &quot; CodeMirror-merge-pane-rightmost&quot;;

    wrap.push(elt(&quot;div&quot;, null, null, &quot;height: 0; clear: both;&quot;));

    var wrapElt = this.wrap = node.appendChild(elt(&quot;div&quot;, wrap, &quot;CodeMirror-merge CodeMirror-merge-&quot; + panes + &quot;pane&quot;));
    this.edit = CodeMirror(editPane, copyObj(options));

    if (left) left.init(leftPane, origLeft, options);
    if (right) right.init(rightPane, origRight, options);

    var onResize = function() {
      if (left) drawConnectors(left);
      if (right) drawConnectors(right);
    };
    CodeMirror.on(window, &quot;resize&quot;, onResize);
    var resizeInterval = setInterval(function() {
      for (var p = wrapElt.parentNode; p &amp;&amp; p != document.body; p = p.parentNode) {}
      if (!p) { clearInterval(resizeInterval); CodeMirror.off(window, &quot;resize&quot;, onResize); }
    }, 5000);
  };

  function buildGap(dv) {
    var lock = dv.lockButton = elt(&quot;div&quot;, null, &quot;CodeMirror-merge-scrolllock&quot;);
    lock.title = &quot;Toggle locked scrolling&quot;;
    var lockWrap = elt(&quot;div&quot;, [lock], &quot;CodeMirror-merge-scrolllock-wrap&quot;);
    CodeMirror.on(lock, &quot;click&quot;, function() { setScrollLock(dv, !dv.lockScroll); });
    var gapElts = [lockWrap];
    if (dv.mv.options.revertButtons !== false) {
      dv.copyButtons = elt(&quot;div&quot;, null, &quot;CodeMirror-merge-copybuttons-&quot; + dv.type);
      CodeMirror.on(dv.copyButtons, &quot;click&quot;, function(e) {
        var node = e.target || e.srcElement;
        if (!node.chunk) return;
        if (node.className == &quot;CodeMirror-merge-copy-reverse&quot;) {
          copyChunk(dv, dv.orig, dv.edit, node.chunk);
          return;
        }
        copyChunk(dv, dv.edit, dv.orig, node.chunk);
      });
      gapElts.unshift(dv.copyButtons);
    }
    var svg = document.createElementNS &amp;&amp; document.createElementNS(svgNS, &quot;svg&quot;);
    if (svg &amp;&amp; !svg.createSVGRect) svg = null;
    dv.svg = svg;
    if (svg) gapElts.push(svg);

    return dv.gap = elt(&quot;div&quot;, gapElts, &quot;CodeMirror-merge-gap&quot;);
  }

  MergeView.prototype = {
    constuctor: MergeView,
    editor: function() { return this.edit; },
    rightOriginal: function() { return this.right &amp;&amp; this.right.orig; },
    leftOriginal: function() { return this.left &amp;&amp; this.left.orig; },
    setShowDifferences: function(val) {
      if (this.right) this.right.setShowDifferences(val);
      if (this.left) this.left.setShowDifferences(val);
    },
    rightChunks: function() {
      return this.right &amp;&amp; getChunks(this.right);
    },
    leftChunks: function() {
      return this.left &amp;&amp; getChunks(this.left);
    }
  };

  function asString(obj) {
    if (typeof obj == &quot;string&quot;) return obj;
    else return obj.getValue();
  }

  // Operations on diffs

  var dmp = new diff_match_patch();
  function getDiff(a, b) {
    var diff = dmp.diff_main(a, b);
    dmp.diff_cleanupSemantic(diff);
    // The library sometimes leaves in empty parts, which confuse the algorithm
    for (var i = 0; i &lt; diff.length; ++i) {
      var part = diff[i];
      if (!part[1]) {
        diff.splice(i--, 1);
      } else if (i &amp;&amp; diff[i - 1][0] == part[0]) {
        diff.splice(i--, 1);
        diff[i][1] += part[1];
      }
    }
    return diff;
  }

  function iterateChunks(diff, f) {
    var startEdit = 0, startOrig = 0;
    var edit = Pos(0, 0), orig = Pos(0, 0);
    for (var i = 0; i &lt; diff.length; ++i) {
      var part = diff[i], tp = part[0];
      if (tp == DIFF_EQUAL) {
        var startOff = startOfLineClean(diff, i) ? 0 : 1;
        var cleanFromEdit = edit.line + startOff, cleanFromOrig = orig.line + startOff;
        moveOver(edit, part[1], null, orig);
        var endOff = endOfLineClean(diff, i) ? 1 : 0;
        var cleanToEdit = edit.line + endOff, cleanToOrig = orig.line + endOff;
        if (cleanToEdit &gt; cleanFromEdit) {
          if (i) f(startOrig, cleanFromOrig, startEdit, cleanFromEdit);
          startEdit = cleanToEdit; startOrig = cleanToOrig;
        }
      } else {
        moveOver(tp == DIFF_INSERT ? edit : orig, part[1]);
      }
    }
    if (startEdit &lt;= edit.line || startOrig &lt;= orig.line)
      f(startOrig, orig.line + 1, startEdit, edit.line + 1);
  }

  function getChunks(dv) {
    ensureDiff(dv);
    var collect = [];
    iterateChunks(dv.diff, function(topOrig, botOrig, topEdit, botEdit) {
      collect.push({origFrom: topOrig, origTo: botOrig,
                    editFrom: topEdit, editTo: botEdit});
    });
    return collect;
  }

  function endOfLineClean(diff, i) {
    if (i == diff.length - 1) return true;
    var next = diff[i + 1][1];
    if (next.length == 1 || next.charCodeAt(0) != 10) return false;
    if (i == diff.length - 2) return true;
    next = diff[i + 2][1];
    return next.length &gt; 1 &amp;&amp; next.charCodeAt(0) == 10;
  }

  function startOfLineClean(diff, i) {
    if (i == 0) return true;
    var last = diff[i - 1][1];
    if (last.charCodeAt(last.length - 1) != 10) return false;
    if (i == 1) return true;
    last = diff[i - 2][1];
    return last.charCodeAt(last.length - 1) == 10;
  }

  function chunkBoundariesAround(diff, n, nInEdit) {
    var beforeE, afterE, beforeO, afterO;
    iterateChunks(diff, function(fromOrig, toOrig, fromEdit, toEdit) {
      var fromLocal = nInEdit ? fromEdit : fromOrig;
      var toLocal = nInEdit ? toEdit : toOrig;
      if (afterE == null) {
        if (fromLocal &gt; n) { afterE = fromEdit; afterO = fromOrig; }
        else if (toLocal &gt; n) { afterE = toEdit; afterO = toOrig; }
      }
      if (toLocal &lt;= n) { beforeE = toEdit; beforeO = toOrig; }
      else if (fromLocal &lt;= n) { beforeE = fromEdit; beforeO = fromOrig; }
    });
    return {edit: {before: beforeE, after: afterE}, orig: {before: beforeO, after: afterO}};
  }

  // General utilities

  function elt(tag, content, className, style) {
    var e = document.createElement(tag);
    if (className) e.className = className;
    if (style) e.style.cssText = style;
    if (typeof content == &quot;string&quot;) e.appendChild(document.createTextNode(content));
    else if (content) for (var i = 0; i &lt; content.length; ++i) e.appendChild(content[i]);
    return e;
  }

  function clear(node) {
    for (var count = node.childNodes.length; count &gt; 0; --count)
      node.removeChild(node.firstChild);
  }

  function attrs(elt) {
    for (var i = 1; i &lt; arguments.length; i += 2)
      elt.setAttribute(arguments[i], arguments[i+1]);
  }

  function copyObj(obj, target) {
    if (!target) target = {};
    for (var prop in obj) if (obj.hasOwnProperty(prop)) target[prop] = obj[prop];
    return target;
  }

  function moveOver(pos, str, copy, other) {
    var out = copy ? Pos(pos.line, pos.ch) : pos, at = 0;
    for (;;) {
      var nl = str.indexOf(&quot;\n&quot;, at);
      if (nl == -1) break;
      ++out.line;
      if (other) ++other.line;
      at = nl + 1;
    }
    out.ch = (at ? 0 : out.ch) + (str.length - at);
    if (other) other.ch = (at ? 0 : other.ch) + (str.length - at);
    return out;
  }

  function posMin(a, b) { return (a.line - b.line || a.ch - b.ch) &lt; 0 ? a : b; }
  function posMax(a, b) { return (a.line - b.line || a.ch - b.ch) &gt; 0 ? a : b; }
  function posEq(a, b) { return a.line == b.line &amp;&amp; a.ch == b.ch; }
});
</code></pre>

</div>

<footer class="footer">
  Generated by <a href="https://esdoc.org">ESDoc<span data-ice="esdocVersion">(1.1.0)</span><img src="./image/esdoc-logo-mini-black.png"></a>
</footer>

<script src="script/search_index.js"></script>
<script src="script/search.js"></script>
<script src="script/pretty-print.js"></script>
<script src="script/inherited-summary.js"></script>
<script src="script/test-summary.js"></script>
<script src="script/inner-link.js"></script>
<script src="script/patch-for-local.js"></script>
</body>
</html>
