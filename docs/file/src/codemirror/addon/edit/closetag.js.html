<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <base data-ice="baseUrl" href="../../../../../">
  <title data-ice="title">src/codemirror/addon/edit/closetag.js | webrtcdevelopment</title>
  <link type="text/css" rel="stylesheet" href="css/style.css">
  <link type="text/css" rel="stylesheet" href="css/prettify-tomorrow.css">
  <script src="script/prettify/prettify.js"></script>
  <script src="script/manual.js"></script>
<meta name="description" content="webrtc based communication and collaboration client. Contains lot of experiments modules "><meta property="twitter:card" content="summary"><meta property="twitter:title" content="webrtcdevelopment"><meta property="twitter:description" content="webrtc based communication and collaboration client. Contains lot of experiments modules "></head>
<body class="layout-container" data-ice="rootContainer">

<header>
  <a href="./">Home</a>
  
  <a href="identifiers.html">Reference</a>
  <a href="source.html">Source</a>
  
  <div class="search-box">
  <span>
    <img src="./image/search.png">
    <span class="search-input-edge"></span><input class="search-input"><span class="search-input-edge"></span>
  </span>
    <ul class="search-result"></ul>
  </div>
<a style="position:relative; top:3px;" href="https://github.com/altanai/webrtc"><img width="20px" src="./image/github.png"></a></header>

<nav class="navigation" data-ice="nav"><div>
  <ul>
    
  <li data-ice="doc"><a data-ice="dirPath" class="nav-dir-path" href="identifiers.html#scripts">scripts</a><span data-ice="kind" class="kind-typedef">T</span><span data-ice="name"><span><a href="typedef/index.html#static-typedef-CanvasRecorder">CanvasRecorder</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-typedef">T</span><span data-ice="name"><span><a href="typedef/index.html#static-typedef-GetRecorderType">GetRecorderType</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-typedef">T</span><span data-ice="name"><span><a href="typedef/index.html#static-typedef-GifRecorder">GifRecorder</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-typedef">T</span><span data-ice="name"><span><a href="typedef/index.html#static-typedef-MRecordRTC">MRecordRTC</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-typedef">T</span><span data-ice="name"><span><a href="typedef/index.html#static-typedef-MediaStreamRecorder">MediaStreamRecorder</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-typedef">T</span><span data-ice="name"><span><a href="typedef/index.html#static-typedef-RecordRTC">RecordRTC</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-typedef">T</span><span data-ice="name"><span><a href="typedef/index.html#static-typedef-RecordRTCConfiguration">RecordRTCConfiguration</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-typedef">T</span><span data-ice="name"><span><a href="typedef/index.html#static-typedef-StereoAudioRecorder">StereoAudioRecorder</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-typedef">T</span><span data-ice="name"><span><a href="typedef/index.html#static-typedef-Whammy">Whammy</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-typedef">T</span><span data-ice="name"><span><a href="typedef/index.html#static-typedef-WhammyRecorder">WhammyRecorder</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-typedef">T</span><span data-ice="name"><span><a href="typedef/index.html#static-typedef-createFileSharingDiv">createFileSharingDiv</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-typedef">T</span><span data-ice="name"><span><a href="typedef/index.html#static-typedef-_turn.js">_turn.js</a></span></span></li>
<li data-ice="doc"><a data-ice="dirPath" class="nav-dir-path" href="identifiers.html#scripts-rtcconn">scripts/rtcconn</a><span data-ice="kind" class="kind-typedef">T</span><span data-ice="name"><span><a href="typedef/index.html#static-typedef-Whammy">Whammy</a></span></span></li>
</ul>
</div>
</nav>

<div class="content" data-ice="content"><h1 data-ice="title">src/codemirror/addon/edit/closetag.js</h1>
<pre class="source-code line-number raw-source-code"><code class="prettyprint linenums" data-ice="content">// CodeMirror, copyright (c) by Marijn Haverbeke and others
// Distributed under an MIT license: http://codemirror.net/LICENSE

/**
 * Tag-closer extension for CodeMirror.
 *
 * This extension adds an &quot;autoCloseTags&quot; option that can be set to
 * either true to get the default behavior, or an object to further
 * configure its behavior.
 *
 * These are supported options:
 *
 * `whenClosing` (default true)
 *   Whether to autoclose when the &apos;/&apos; of a closing tag is typed.
 * `whenOpening` (default true)
 *   Whether to autoclose the tag when the final &apos;&gt;&apos; of an opening
 *   tag is typed.
 * `dontCloseTags` (default is empty tags for HTML, none for XML)
 *   An array of tag names that should not be autoclosed.
 * `indentTags` (default is block tags for HTML, none for XML)
 *   An array of tag names that should, when opened, cause a
 *   blank line to be added inside the tag, and the blank line and
 *   closing line to be indented.
 *
 * See demos/closetag.html for a usage example.
 */

(function(mod) {
  if (typeof exports == &quot;object&quot; &amp;&amp; typeof module == &quot;object&quot;) // CommonJS
    mod(require(&quot;../../lib/codemirror&quot;), require(&quot;../fold/xml-fold&quot;));
  else if (typeof define == &quot;function&quot; &amp;&amp; define.amd) // AMD
    define([&quot;../../lib/codemirror&quot;, &quot;../fold/xml-fold&quot;], mod);
  else // Plain browser env
    mod(CodeMirror);
})(function(CodeMirror) {
  CodeMirror.defineOption(&quot;autoCloseTags&quot;, false, function(cm, val, old) {
    if (old != CodeMirror.Init &amp;&amp; old)
      cm.removeKeyMap(&quot;autoCloseTags&quot;);
    if (!val) return;
    var map = {name: &quot;autoCloseTags&quot;};
    if (typeof val != &quot;object&quot; || val.whenClosing)
      map[&quot;&apos;/&apos;&quot;] = function(cm) { return autoCloseSlash(cm); };
    if (typeof val != &quot;object&quot; || val.whenOpening)
      map[&quot;&apos;&gt;&apos;&quot;] = function(cm) { return autoCloseGT(cm); };
    cm.addKeyMap(map);
  });

  var htmlDontClose = [&quot;area&quot;, &quot;base&quot;, &quot;br&quot;, &quot;col&quot;, &quot;command&quot;, &quot;embed&quot;, &quot;hr&quot;, &quot;img&quot;, &quot;input&quot;, &quot;keygen&quot;, &quot;link&quot;, &quot;meta&quot;, &quot;param&quot;,
                       &quot;source&quot;, &quot;track&quot;, &quot;wbr&quot;];
  var htmlIndent = [&quot;applet&quot;, &quot;blockquote&quot;, &quot;body&quot;, &quot;button&quot;, &quot;div&quot;, &quot;dl&quot;, &quot;fieldset&quot;, &quot;form&quot;, &quot;frameset&quot;, &quot;h1&quot;, &quot;h2&quot;, &quot;h3&quot;, &quot;h4&quot;,
                    &quot;h5&quot;, &quot;h6&quot;, &quot;head&quot;, &quot;html&quot;, &quot;iframe&quot;, &quot;layer&quot;, &quot;legend&quot;, &quot;object&quot;, &quot;ol&quot;, &quot;p&quot;, &quot;select&quot;, &quot;table&quot;, &quot;ul&quot;];

  function autoCloseGT(cm) {
    if (cm.getOption(&quot;disableInput&quot;)) return CodeMirror.Pass;
    var ranges = cm.listSelections(), replacements = [];
    for (var i = 0; i &lt; ranges.length; i++) {
      if (!ranges[i].empty()) return CodeMirror.Pass;
      var pos = ranges[i].head, tok = cm.getTokenAt(pos);
      var inner = CodeMirror.innerMode(cm.getMode(), tok.state), state = inner.state;
      if (inner.mode.name != &quot;xml&quot; || !state.tagName) return CodeMirror.Pass;

      var opt = cm.getOption(&quot;autoCloseTags&quot;), html = inner.mode.configuration == &quot;html&quot;;
      var dontCloseTags = (typeof opt == &quot;object&quot; &amp;&amp; opt.dontCloseTags) || (html &amp;&amp; htmlDontClose);
      var indentTags = (typeof opt == &quot;object&quot; &amp;&amp; opt.indentTags) || (html &amp;&amp; htmlIndent);

      var tagName = state.tagName;
      if (tok.end &gt; pos.ch) tagName = tagName.slice(0, tagName.length - tok.end + pos.ch);
      var lowerTagName = tagName.toLowerCase();
      // Don&apos;t process the &apos;&gt;&apos; at the end of an end-tag or self-closing tag
      if (!tagName ||
          tok.type == &quot;string&quot; &amp;&amp; (tok.end != pos.ch || !/[\&quot;\&apos;]/.test(tok.string.charAt(tok.string.length - 1)) || tok.string.length == 1) ||
          tok.type == &quot;tag&quot; &amp;&amp; state.type == &quot;closeTag&quot; ||
          tok.string.indexOf(&quot;/&quot;) == (tok.string.length - 1) || // match something like &lt;someTagName /&gt;
          dontCloseTags &amp;&amp; indexOf(dontCloseTags, lowerTagName) &gt; -1 ||
          closingTagExists(cm, tagName, pos, state, true))
        return CodeMirror.Pass;

      var indent = indentTags &amp;&amp; indexOf(indentTags, lowerTagName) &gt; -1;
      replacements[i] = {indent: indent,
                         text: &quot;&gt;&quot; + (indent ? &quot;\n\n&quot; : &quot;&quot;) + &quot;&lt;/&quot; + tagName + &quot;&gt;&quot;,
                         newPos: indent ? CodeMirror.Pos(pos.line + 1, 0) : CodeMirror.Pos(pos.line, pos.ch + 1)};
    }

    for (var i = ranges.length - 1; i &gt;= 0; i--) {
      var info = replacements[i];
      cm.replaceRange(info.text, ranges[i].head, ranges[i].anchor, &quot;+insert&quot;);
      var sel = cm.listSelections().slice(0);
      sel[i] = {head: info.newPos, anchor: info.newPos};
      cm.setSelections(sel);
      if (info.indent) {
        cm.indentLine(info.newPos.line, null, true);
        cm.indentLine(info.newPos.line + 1, null, true);
      }
    }
  }

  function autoCloseSlash(cm) {
    if (cm.getOption(&quot;disableInput&quot;)) return CodeMirror.Pass;
    var ranges = cm.listSelections(), replacements = [];
    for (var i = 0; i &lt; ranges.length; i++) {
      if (!ranges[i].empty()) return CodeMirror.Pass;
      var pos = ranges[i].head, tok = cm.getTokenAt(pos);
      var inner = CodeMirror.innerMode(cm.getMode(), tok.state), state = inner.state;
      if (tok.type == &quot;string&quot; || tok.string.charAt(0) != &quot;&lt;&quot; ||
          tok.start != pos.ch - 1)
        return CodeMirror.Pass;
      // Kludge to get around the fact that we are not in XML mode
      // when completing in JS/CSS snippet in htmlmixed mode. Does not
      // work for other XML embedded languages (there is no general
      // way to go from a mixed mode to its current XML state).
      if (inner.mode.name != &quot;xml&quot;) {
        if (cm.getMode().name == &quot;htmlmixed&quot; &amp;&amp; inner.mode.name == &quot;javascript&quot;)
          replacements[i] = &quot;/script&gt;&quot;;
        else if (cm.getMode().name == &quot;htmlmixed&quot; &amp;&amp; inner.mode.name == &quot;css&quot;)
          replacements[i] = &quot;/style&gt;&quot;;
        else
          return CodeMirror.Pass;
      } else {
        if (!state.context || !state.context.tagName ||
            closingTagExists(cm, state.context.tagName, pos, state))
          return CodeMirror.Pass;
        replacements[i] = &quot;/&quot; + state.context.tagName + &quot;&gt;&quot;;
      }
    }
    cm.replaceSelections(replacements);
    ranges = cm.listSelections();
    for (var i = 0; i &lt; ranges.length; i++)
      if (i == ranges.length - 1 || ranges[i].head.line &lt; ranges[i + 1].head.line)
        cm.indentLine(ranges[i].head.line);
  }

  function indexOf(collection, elt) {
    if (collection.indexOf) return collection.indexOf(elt);
    for (var i = 0, e = collection.length; i &lt; e; ++i)
      if (collection[i] == elt) return i;
    return -1;
  }

  // If xml-fold is loaded, we use its functionality to try and verify
  // whether a given tag is actually unclosed.
  function closingTagExists(cm, tagName, pos, state, newTag) {
    if (!CodeMirror.scanForClosingTag) return false;
    var end = Math.min(cm.lastLine() + 1, pos.line + 500);
    var nextClose = CodeMirror.scanForClosingTag(cm, pos, null, end);
    if (!nextClose || nextClose.tag != tagName) return false;
    var cx = state.context;
    // If the immediate wrapping context contains onCx instances of
    // the same tag, a closing tag only exists if there are at least
    // that many closing tags of that type following.
    for (var onCx = newTag ? 1 : 0; cx &amp;&amp; cx.tagName == tagName; cx = cx.prev) ++onCx;
    pos = nextClose.to;
    for (var i = 1; i &lt; onCx; i++) {
      var next = CodeMirror.scanForClosingTag(cm, pos, null, end);
      if (!next || next.tag != tagName) return false;
      pos = next.to;
    }
    return true;
  }
});
</code></pre>

</div>

<footer class="footer">
  Generated by <a href="https://esdoc.org">ESDoc<span data-ice="esdocVersion">(1.1.0)</span><img src="./image/esdoc-logo-mini-black.png"></a>
</footer>

<script src="script/search_index.js"></script>
<script src="script/search.js"></script>
<script src="script/pretty-print.js"></script>
<script src="script/inherited-summary.js"></script>
<script src="script/test-summary.js"></script>
<script src="script/inner-link.js"></script>
<script src="script/patch-for-local.js"></script>
</body>
</html>
