<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <base data-ice="baseUrl" href="../../../../">
  <title data-ice="title">src/scripts/rtcconn/adapter.js | webrtcdevelopment</title>
  <link type="text/css" rel="stylesheet" href="css/style.css">
  <link type="text/css" rel="stylesheet" href="css/prettify-tomorrow.css">
  <script src="script/prettify/prettify.js"></script>
  <script src="script/manual.js"></script>
<meta name="description" content="webrtc based communication and collaboration client. Contains lot of experiments modules "><meta property="twitter:card" content="summary"><meta property="twitter:title" content="webrtcdevelopment"><meta property="twitter:description" content="webrtc based communication and collaboration client. Contains lot of experiments modules "></head>
<body class="layout-container" data-ice="rootContainer">

<header>
  <a href="./">Home</a>
  
  <a href="identifiers.html">Reference</a>
  <a href="source.html">Source</a>
  
  <div class="search-box">
  <span>
    <img src="./image/search.png">
    <span class="search-input-edge"></span><input class="search-input"><span class="search-input-edge"></span>
  </span>
    <ul class="search-result"></ul>
  </div>
<a style="position:relative; top:3px;" href="https://github.com/altanai/webrtc"><img width="20px" src="./image/github.png"></a></header>

<nav class="navigation" data-ice="nav"><div>
  <ul>
    
  <li data-ice="doc"><a data-ice="dirPath" class="nav-dir-path" href="identifiers.html#scripts">scripts</a><span data-ice="kind" class="kind-typedef">T</span><span data-ice="name"><span><a href="typedef/index.html#static-typedef-CanvasRecorder">CanvasRecorder</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-typedef">T</span><span data-ice="name"><span><a href="typedef/index.html#static-typedef-GetRecorderType">GetRecorderType</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-typedef">T</span><span data-ice="name"><span><a href="typedef/index.html#static-typedef-GifRecorder">GifRecorder</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-typedef">T</span><span data-ice="name"><span><a href="typedef/index.html#static-typedef-MRecordRTC">MRecordRTC</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-typedef">T</span><span data-ice="name"><span><a href="typedef/index.html#static-typedef-MediaStreamRecorder">MediaStreamRecorder</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-typedef">T</span><span data-ice="name"><span><a href="typedef/index.html#static-typedef-RecordRTC">RecordRTC</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-typedef">T</span><span data-ice="name"><span><a href="typedef/index.html#static-typedef-RecordRTCConfiguration">RecordRTCConfiguration</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-typedef">T</span><span data-ice="name"><span><a href="typedef/index.html#static-typedef-StereoAudioRecorder">StereoAudioRecorder</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-typedef">T</span><span data-ice="name"><span><a href="typedef/index.html#static-typedef-Whammy">Whammy</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-typedef">T</span><span data-ice="name"><span><a href="typedef/index.html#static-typedef-WhammyRecorder">WhammyRecorder</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-typedef">T</span><span data-ice="name"><span><a href="typedef/index.html#static-typedef-createFileSharingDiv">createFileSharingDiv</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-typedef">T</span><span data-ice="name"><span><a href="typedef/index.html#static-typedef-_turn.js">_turn.js</a></span></span></li>
<li data-ice="doc"><a data-ice="dirPath" class="nav-dir-path" href="identifiers.html#scripts-rtcconn">scripts/rtcconn</a><span data-ice="kind" class="kind-typedef">T</span><span data-ice="name"><span><a href="typedef/index.html#static-typedef-Whammy">Whammy</a></span></span></li>
</ul>
</div>
</nav>

<div class="content" data-ice="content"><h1 data-ice="title">src/scripts/rtcconn/adapter.js</h1>
<pre class="source-code line-number raw-source-code"><code class="prettyprint linenums" data-ice="content">(function(f) {
    if (typeof exports === &quot;object&quot; &amp;&amp; typeof module !== &quot;undefined&quot;) {
        module.exports = f()
    } else if (typeof define === &quot;function&quot; &amp;&amp; define.amd) {
        define([], f)
    } else {
        var g;
        if (typeof window !== &quot;undefined&quot;) {
            g = window
        } else if (typeof global !== &quot;undefined&quot;) {
            g = global
        } else if (typeof self !== &quot;undefined&quot;) {
            g = self
        } else {
            g = this
        }
        g.adapter = f()
    }
})(function() {
    var define, module, exports;
    return (function e(t, n, r) {
        function s(o, u) {
            if (!n[o]) {
                if (!t[o]) {
                    var a = typeof require == &quot;function&quot; &amp;&amp; require;
                    if (!u &amp;&amp; a) return a(o, !0);
                    if (i) return i(o, !0);
                    var f = new Error(&quot;Cannot find module &apos;&quot; + o + &quot;&apos;&quot;);
                    throw f.code = &quot;MODULE_NOT_FOUND&quot;, f
                }
                var l = n[o] = {
                    exports: {}
                };
                t[o][0].call(l.exports, function(e) {
                    var n = t[o][1][e];
                    return s(n ? n : e)
                }, l, l.exports, e, t, n, r)
            }
            return n[o].exports
        }
        var i = typeof require == &quot;function&quot; &amp;&amp; require;
        for (var o = 0; o &lt; r.length; o++) s(r[o]);
        return s
    })({
        1: [function(require, module, exports) {
            /* eslint-env node */
            &apos;use strict&apos;;

            // SDP helpers.
            var SDPUtils = {};

            // Generate an alphanumeric identifier for cname or mids.
            // TODO: use UUIDs instead? https://gist.github.com/jed/982883
            SDPUtils.generateIdentifier = function() {
                return Math.random().toString(36).substr(2, 10);
            };

            // The RTCP CNAME used by all peerconnections from the same JS.
            SDPUtils.localCName = SDPUtils.generateIdentifier();

            // Splits SDP into lines, dealing with both CRLF and LF.
            SDPUtils.splitLines = function(blob) {
                return blob.trim().split(&apos;\n&apos;).map(function(line) {
                    return line.trim();
                });
            };
            // Splits SDP into sessionpart and mediasections. Ensures CRLF.
            SDPUtils.splitSections = function(blob) {
                var parts = blob.split(&apos;\nm=&apos;);
                return parts.map(function(part, index) {
                    return (index &gt; 0 ? &apos;m=&apos; + part : part).trim() + &apos;\r\n&apos;;
                });
            };

            // Returns lines that start with a certain prefix.
            SDPUtils.matchPrefix = function(blob, prefix) {
                return SDPUtils.splitLines(blob).filter(function(line) {
                    return line.indexOf(prefix) === 0;
                });
            };

            // Parses an ICE candidate line. Sample input:
            // candidate:702786350 2 udp 41819902 8.8.8.8 60769 typ relay raddr 8.8.8.8
            // rport 55996&quot;
            SDPUtils.parseCandidate = function(line) {
                var parts;
                // Parse both variants.
                if (line.indexOf(&apos;a=candidate:&apos;) === 0) {
                    parts = line.substring(12).split(&apos; &apos;);
                } else {
                    parts = line.substring(10).split(&apos; &apos;);
                }

                var candidate = {
                    foundation: parts[0],
                    component: parseInt(parts[1], 10),
                    protocol: parts[2].toLowerCase(),
                    priority: parseInt(parts[3], 10),
                    ip: parts[4],
                    port: parseInt(parts[5], 10),
                    // skip parts[6] == &apos;typ&apos;
                    type: parts[7]
                };

                for (var i = 8; i &lt; parts.length; i += 2) {
                    switch (parts[i]) {
                        case &apos;raddr&apos;:
                            candidate.relatedAddress = parts[i + 1];
                            break;
                        case &apos;rport&apos;:
                            candidate.relatedPort = parseInt(parts[i + 1], 10);
                            break;
                        case &apos;tcptype&apos;:
                            candidate.tcpType = parts[i + 1];
                            break;
                        default: // extension handling, in particular ufrag
                            candidate[parts[i]] = parts[i + 1];
                            break;
                    }
                }
                return candidate;
            };

            // Translates a candidate object into SDP candidate attribute.
            SDPUtils.writeCandidate = function(candidate) {
                var sdp = [];
                sdp.push(candidate.foundation);
                sdp.push(candidate.component);
                sdp.push(candidate.protocol.toUpperCase());
                sdp.push(candidate.priority);
                sdp.push(candidate.ip);
                sdp.push(candidate.port);

                var type = candidate.type;
                sdp.push(&apos;typ&apos;);
                sdp.push(type);
                if (type !== &apos;host&apos; &amp;&amp; candidate.relatedAddress &amp;&amp;
                    candidate.relatedPort) {
                    sdp.push(&apos;raddr&apos;);
                    sdp.push(candidate.relatedAddress); // was: relAddr
                    sdp.push(&apos;rport&apos;);
                    sdp.push(candidate.relatedPort); // was: relPort
                }
                if (candidate.tcpType &amp;&amp; candidate.protocol.toLowerCase() === &apos;tcp&apos;) {
                    sdp.push(&apos;tcptype&apos;);
                    sdp.push(candidate.tcpType);
                }
                if (candidate.ufrag) {
                    sdp.push(&apos;ufrag&apos;);
                    sdp.push(candidate.ufrag);
                }
                return &apos;candidate:&apos; + sdp.join(&apos; &apos;);
            };

            // Parses an ice-options line, returns an array of option tags.
            // a=ice-options:foo bar
            SDPUtils.parseIceOptions = function(line) {
                return line.substr(14).split(&apos; &apos;);
            }

            // Parses an rtpmap line, returns RTCRtpCoddecParameters. Sample input:
            // a=rtpmap:111 opus/48000/2
            SDPUtils.parseRtpMap = function(line) {
                var parts = line.substr(9).split(&apos; &apos;);
                var parsed = {
                    payloadType: parseInt(parts.shift(), 10) // was: id
                };

                parts = parts[0].split(&apos;/&apos;);

                parsed.name = parts[0];
                parsed.clockRate = parseInt(parts[1], 10); // was: clockrate
                // was: channels
                parsed.numChannels = parts.length === 3 ? parseInt(parts[2], 10) : 1;
                return parsed;
            };

            // Generate an a=rtpmap line from RTCRtpCodecCapability or
            // RTCRtpCodecParameters.
            SDPUtils.writeRtpMap = function(codec) {
                var pt = codec.payloadType;
                if (codec.preferredPayloadType !== undefined) {
                    pt = codec.preferredPayloadType;
                }
                return &apos;a=rtpmap:&apos; + pt + &apos; &apos; + codec.name + &apos;/&apos; + codec.clockRate +
                    (codec.numChannels !== 1 ? &apos;/&apos; + codec.numChannels : &apos;&apos;) + &apos;\r\n&apos;;
            };

            // Parses an a=extmap line (headerextension from RFC 5285). Sample input:
            // a=extmap:2 urn:ietf:params:rtp-hdrext:toffset
            // a=extmap:2/sendonly urn:ietf:params:rtp-hdrext:toffset
            SDPUtils.parseExtmap = function(line) {
                var parts = line.substr(9).split(&apos; &apos;);
                return {
                    id: parseInt(parts[0], 10),
                    direction: parts[0].indexOf(&apos;/&apos;) &gt; 0 ? parts[0].split(&apos;/&apos;)[1] : &apos;sendrecv&apos;,
                    uri: parts[1]
                };
            };

            // Generates a=extmap line from RTCRtpHeaderExtensionParameters or
            // RTCRtpHeaderExtension.
            SDPUtils.writeExtmap = function(headerExtension) {
                return &apos;a=extmap:&apos; + (headerExtension.id || headerExtension.preferredId) +
                    (headerExtension.direction &amp;&amp; headerExtension.direction !== &apos;sendrecv&apos; ?
                        &apos;/&apos; + headerExtension.direction :
                        &apos;&apos;) +
                    &apos; &apos; + headerExtension.uri + &apos;\r\n&apos;;
            };

            // Parses an ftmp line, returns dictionary. Sample input:
            // a=fmtp:96 vbr=on;cng=on
            // Also deals with vbr=on; cng=on
            SDPUtils.parseFmtp = function(line) {
                var parsed = {};
                var kv;
                var parts = line.substr(line.indexOf(&apos; &apos;) + 1).split(&apos;;&apos;);
                for (var j = 0; j &lt; parts.length; j++) {
                    kv = parts[j].trim().split(&apos;=&apos;);
                    parsed[kv[0].trim()] = kv[1];
                }
                return parsed;
            };

            // Generates an a=ftmp line from RTCRtpCodecCapability or RTCRtpCodecParameters.
            SDPUtils.writeFmtp = function(codec) {
                var line = &apos;&apos;;
                var pt = codec.payloadType;
                if (codec.preferredPayloadType !== undefined) {
                    pt = codec.preferredPayloadType;
                }
                if (codec.parameters &amp;&amp; Object.keys(codec.parameters).length) {
                    var params = [];
                    Object.keys(codec.parameters).forEach(function(param) {
                        params.push(param + &apos;=&apos; + codec.parameters[param]);
                    });
                    line += &apos;a=fmtp:&apos; + pt + &apos; &apos; + params.join(&apos;;&apos;) + &apos;\r\n&apos;;
                }
                return line;
            };

            // Parses an rtcp-fb line, returns RTCPRtcpFeedback object. Sample input:
            // a=rtcp-fb:98 nack rpsi
            SDPUtils.parseRtcpFb = function(line) {
                var parts = line.substr(line.indexOf(&apos; &apos;) + 1).split(&apos; &apos;);
                return {
                    type: parts.shift(),
                    parameter: parts.join(&apos; &apos;)
                };
            };
            // Generate a=rtcp-fb lines from RTCRtpCodecCapability or RTCRtpCodecParameters.
            SDPUtils.writeRtcpFb = function(codec) {
                var lines = &apos;&apos;;
                var pt = codec.payloadType;
                if (codec.preferredPayloadType !== undefined) {
                    pt = codec.preferredPayloadType;
                }
                if (codec.rtcpFeedback &amp;&amp; codec.rtcpFeedback.length) {
                    // FIXME: special handling for trr-int?
                    codec.rtcpFeedback.forEach(function(fb) {
                        lines += &apos;a=rtcp-fb:&apos; + pt + &apos; &apos; + fb.type +
                            (fb.parameter &amp;&amp; fb.parameter.length ? &apos; &apos; + fb.parameter : &apos;&apos;) +
                            &apos;\r\n&apos;;
                    });
                }
                return lines;
            };

            // Parses an RFC 5576 ssrc media attribute. Sample input:
            // a=ssrc:3735928559 cname:something
            SDPUtils.parseSsrcMedia = function(line) {
                var sp = line.indexOf(&apos; &apos;);
                var parts = {
                    ssrc: parseInt(line.substr(7, sp - 7), 10)
                };
                var colon = line.indexOf(&apos;:&apos;, sp);
                if (colon &gt; -1) {
                    parts.attribute = line.substr(sp + 1, colon - sp - 1);
                    parts.value = line.substr(colon + 1);
                } else {
                    parts.attribute = line.substr(sp + 1);
                }
                return parts;
            };

            // Extracts the MID (RFC 5888) from a media section.
            // returns the MID or undefined if no mid line was found.
            SDPUtils.getMid = function(mediaSection) {
                var mid = SDPUtils.matchPrefix(mediaSection, &apos;a=mid:&apos;)[0];
                if (mid) {
                    return mid.substr(6);
                }
            }

            SDPUtils.parseFingerprint = function(line) {
                var parts = line.substr(14).split(&apos; &apos;);
                return {
                    algorithm: parts[0].toLowerCase(), // algorithm is case-sensitive in Edge.
                    value: parts[1]
                };
            };

            // Extracts DTLS parameters from SDP media section or sessionpart.
            // FIXME: for consistency with other functions this should only
            //   get the fingerprint line as input. See also getIceParameters.
            SDPUtils.getDtlsParameters = function(mediaSection, sessionpart) {
                var lines = SDPUtils.matchPrefix(mediaSection + sessionpart,
                    &apos;a=fingerprint:&apos;);
                // Note: a=setup line is ignored since we use the &apos;auto&apos; role.
                // Note2: &apos;algorithm&apos; is not case sensitive except in Edge.
                return {
                    role: &apos;auto&apos;,
                    fingerprints: lines.map(SDPUtils.parseFingerprint)
                };
            };

            // Serializes DTLS parameters to SDP.
            SDPUtils.writeDtlsParameters = function(params, setupType) {
                var sdp = &apos;a=setup:&apos; + setupType + &apos;\r\n&apos;;
                params.fingerprints.forEach(function(fp) {
                    sdp += &apos;a=fingerprint:&apos; + fp.algorithm + &apos; &apos; + fp.value + &apos;\r\n&apos;;
                });
                return sdp;
            };
            // Parses ICE information from SDP media section or sessionpart.
            // FIXME: for consistency with other functions this should only
            //   get the ice-ufrag and ice-pwd lines as input.
            SDPUtils.getIceParameters = function(mediaSection, sessionpart) {
                var lines = SDPUtils.splitLines(mediaSection);
                // Search in session part, too.
                lines = lines.concat(SDPUtils.splitLines(sessionpart));
                var iceParameters = {
                    usernameFragment: lines.filter(function(line) {
                        return line.indexOf(&apos;a=ice-ufrag:&apos;) === 0;
                    })[0].substr(12),
                    password: lines.filter(function(line) {
                        return line.indexOf(&apos;a=ice-pwd:&apos;) === 0;
                    })[0].substr(10)
                };
                return iceParameters;
            };

            // Serializes ICE parameters to SDP.
            SDPUtils.writeIceParameters = function(params) {
                return &apos;a=ice-ufrag:&apos; + params.usernameFragment + &apos;\r\n&apos; +
                    &apos;a=ice-pwd:&apos; + params.password + &apos;\r\n&apos;;
            };

            // Parses the SDP media section and returns RTCRtpParameters.
            SDPUtils.parseRtpParameters = function(mediaSection) {
                var description = {
                    codecs: [],
                    headerExtensions: [],
                    fecMechanisms: [],
                    rtcp: []
                };
                var lines = SDPUtils.splitLines(mediaSection);
                var mline = lines[0].split(&apos; &apos;);
                for (var i = 3; i &lt; mline.length; i++) { // find all codecs from mline[3..]
                    var pt = mline[i];
                    var rtpmapline = SDPUtils.matchPrefix(
                        mediaSection, &apos;a=rtpmap:&apos; + pt + &apos; &apos;)[0];
                    if (rtpmapline) {
                        var codec = SDPUtils.parseRtpMap(rtpmapline);
                        var fmtps = SDPUtils.matchPrefix(
                            mediaSection, &apos;a=fmtp:&apos; + pt + &apos; &apos;);
                        // Only the first a=fmtp:&lt;pt&gt; is considered.
                        codec.parameters = fmtps.length ? SDPUtils.parseFmtp(fmtps[0]) : {};
                        codec.rtcpFeedback = SDPUtils.matchPrefix(
                                mediaSection, &apos;a=rtcp-fb:&apos; + pt + &apos; &apos;)
                            .map(SDPUtils.parseRtcpFb);
                        description.codecs.push(codec);
                        // parse FEC mechanisms from rtpmap lines.
                        switch (codec.name.toUpperCase()) {
                            case &apos;RED&apos;:
                            case &apos;ULPFEC&apos;:
                                description.fecMechanisms.push(codec.name.toUpperCase());
                                break;
                            default: // only RED and ULPFEC are recognized as FEC mechanisms.
                                break;
                        }
                    }
                }
                SDPUtils.matchPrefix(mediaSection, &apos;a=extmap:&apos;).forEach(function(line) {
                    description.headerExtensions.push(SDPUtils.parseExtmap(line));
                });
                // FIXME: parse rtcp.
                return description;
            };

            // Generates parts of the SDP media section describing the capabilities /
            // parameters.
            SDPUtils.writeRtpDescription = function(kind, caps) {
                var sdp = &apos;&apos;;

                // Build the mline.
                sdp += &apos;m=&apos; + kind + &apos; &apos;;
                sdp += caps.codecs.length &gt; 0 ? &apos;9&apos; : &apos;0&apos;; // reject if no codecs.
                sdp += &apos; UDP/TLS/RTP/SAVPF &apos;;
                sdp += caps.codecs.map(function(codec) {
                    if (codec.preferredPayloadType !== undefined) {
                        return codec.preferredPayloadType;
                    }
                    return codec.payloadType;
                }).join(&apos; &apos;) + &apos;\r\n&apos;;

                sdp += &apos;c=IN IP4 0.0.0.0\r\n&apos;;
                sdp += &apos;a=rtcp:9 IN IP4 0.0.0.0\r\n&apos;;

                // Add a=rtpmap lines for each codec. Also fmtp and rtcp-fb.
                caps.codecs.forEach(function(codec) {
                    sdp += SDPUtils.writeRtpMap(codec);
                    sdp += SDPUtils.writeFmtp(codec);
                    sdp += SDPUtils.writeRtcpFb(codec);
                });
                var maxptime = 0;
                caps.codecs.forEach(function(codec) {
                    if (codec.maxptime &gt; maxptime) {
                        maxptime = codec.maxptime;
                    }
                });
                if (maxptime &gt; 0) {
                    sdp += &apos;a=maxptime:&apos; + maxptime + &apos;\r\n&apos;;
                }
                sdp += &apos;a=rtcp-mux\r\n&apos;;

                caps.headerExtensions.forEach(function(extension) {
                    sdp += SDPUtils.writeExtmap(extension);
                });
                // FIXME: write fecMechanisms.
                return sdp;
            };

            // Parses the SDP media section and returns an array of
            // RTCRtpEncodingParameters.
            SDPUtils.parseRtpEncodingParameters = function(mediaSection) {
                var encodingParameters = [];
                var description = SDPUtils.parseRtpParameters(mediaSection);
                var hasRed = description.fecMechanisms.indexOf(&apos;RED&apos;) !== -1;
                var hasUlpfec = description.fecMechanisms.indexOf(&apos;ULPFEC&apos;) !== -1;

                // filter a=ssrc:... cname:, ignore PlanB-msid
                var ssrcs = SDPUtils.matchPrefix(mediaSection, &apos;a=ssrc:&apos;)
                    .map(function(line) {
                        return SDPUtils.parseSsrcMedia(line);
                    })
                    .filter(function(parts) {
                        return parts.attribute === &apos;cname&apos;;
                    });
                var primarySsrc = ssrcs.length &gt; 0 &amp;&amp; ssrcs[0].ssrc;
                var secondarySsrc;

                var flows = SDPUtils.matchPrefix(mediaSection, &apos;a=ssrc-group:FID&apos;)
                    .map(function(line) {
                        var parts = line.split(&apos; &apos;);
                        parts.shift();
                        return parts.map(function(part) {
                            return parseInt(part, 10);
                        });
                    });
                if (flows.length &gt; 0 &amp;&amp; flows[0].length &gt; 1 &amp;&amp; flows[0][0] === primarySsrc) {
                    secondarySsrc = flows[0][1];
                }

                description.codecs.forEach(function(codec) {
                    if (codec.name.toUpperCase() === &apos;RTX&apos; &amp;&amp; codec.parameters.apt) {
                        var encParam = {
                            ssrc: primarySsrc,
                            codecPayloadType: parseInt(codec.parameters.apt, 10),
                            rtx: {
                                ssrc: secondarySsrc
                            }
                        };
                        encodingParameters.push(encParam);
                        if (hasRed) {
                            encParam = JSON.parse(JSON.stringify(encParam));
                            encParam.fec = {
                                ssrc: secondarySsrc,
                                mechanism: hasUlpfec ? &apos;red+ulpfec&apos; : &apos;red&apos;
                            };
                            encodingParameters.push(encParam);
                        }
                    }
                });
                if (encodingParameters.length === 0 &amp;&amp; primarySsrc) {
                    encodingParameters.push({
                        ssrc: primarySsrc
                    });
                }

                // we support both b=AS and b=TIAS but interpret AS as TIAS.
                var bandwidth = SDPUtils.matchPrefix(mediaSection, &apos;b=&apos;);
                if (bandwidth.length) {
                    if (bandwidth[0].indexOf(&apos;b=TIAS:&apos;) === 0) {
                        bandwidth = parseInt(bandwidth[0].substr(7), 10);
                    } else if (bandwidth[0].indexOf(&apos;b=AS:&apos;) === 0) {
                        // use formula from JSEP to convert b=AS to TIAS value.
                        bandwidth = parseInt(bandwidth[0].substr(5), 10) * 1000 * 0.95 -
                            (50 * 40 * 8);
                    } else {
                        bandwidth = undefined;
                    }
                    encodingParameters.forEach(function(params) {
                        params.maxBitrate = bandwidth;
                    });
                }
                return encodingParameters;
            };

            // parses http://draft.ortc.org/#rtcrtcpparameters*
            SDPUtils.parseRtcpParameters = function(mediaSection) {
                var rtcpParameters = {};

                var cname;
                // Gets the first SSRC. Note that with RTX there might be multiple
                // SSRCs.
                var remoteSsrc = SDPUtils.matchPrefix(mediaSection, &apos;a=ssrc:&apos;)
                    .map(function(line) {
                        return SDPUtils.parseSsrcMedia(line);
                    })
                    .filter(function(obj) {
                        return obj.attribute === &apos;cname&apos;;
                    })[0];
                if (remoteSsrc) {
                    rtcpParameters.cname = remoteSsrc.value;
                    rtcpParameters.ssrc = remoteSsrc.ssrc;
                }

                // Edge uses the compound attribute instead of reducedSize
                // compound is !reducedSize
                var rsize = SDPUtils.matchPrefix(mediaSection, &apos;a=rtcp-rsize&apos;);
                rtcpParameters.reducedSize = rsize.length &gt; 0;
                rtcpParameters.compound = rsize.length === 0;

                // parses the rtcp-mux attr&#x456;bute.
                // Note that Edge does not support unmuxed RTCP.
                var mux = SDPUtils.matchPrefix(mediaSection, &apos;a=rtcp-mux&apos;);
                rtcpParameters.mux = mux.length &gt; 0;

                return rtcpParameters;
            };

            // parses either a=msid: or a=ssrc:... msid lines and returns
            // the id of the MediaStream and MediaStreamTrack.
            SDPUtils.parseMsid = function(mediaSection) {
                var parts;
                var spec = SDPUtils.matchPrefix(mediaSection, &apos;a=msid:&apos;);
                if (spec.length === 1) {
                    parts = spec[0].substr(7).split(&apos; &apos;);
                    return {
                        stream: parts[0],
                        track: parts[1]
                    };
                }
                var planB = SDPUtils.matchPrefix(mediaSection, &apos;a=ssrc:&apos;)
                    .map(function(line) {
                        return SDPUtils.parseSsrcMedia(line);
                    })
                    .filter(function(parts) {
                        return parts.attribute === &apos;msid&apos;;
                    });
                if (planB.length &gt; 0) {
                    parts = planB[0].value.split(&apos; &apos;);
                    return {
                        stream: parts[0],
                        track: parts[1]
                    };
                }
            };

            // Generate a session ID for SDP.
            // https://tools.ietf.org/html/draft-ietf-rtcweb-jsep-20#section-5.2.1
            // recommends using a cryptographically random +ve 64-bit value
            // but right now this should be acceptable and within the right range
            SDPUtils.generateSessionId = function() {
                return Math.random().toString().substr(2, 21);
            };

            // Write boilder plate for start of SDP
            // sessId argument is optional - if not supplied it will
            // be generated randomly
            // sessVersion is optional and defaults to 2
            SDPUtils.writeSessionBoilerplate = function(sessId, sessVer) {
                var sessionId;
                var version = sessVer !== undefined ? sessVer : 2;
                if (sessId) {
                    sessionId = sessId;
                } else {
                    sessionId = SDPUtils.generateSessionId();
                }
                // FIXME: sess-id should be an NTP timestamp.
                return &apos;v=0\r\n&apos; +
                    &apos;o=thisisadapterortc &apos; + sessionId + &apos; &apos; + version + &apos; IN IP4 127.0.0.1\r\n&apos; +
                    &apos;s=-\r\n&apos; +
                    &apos;t=0 0\r\n&apos;;
            };

            SDPUtils.writeMediaSection = function(transceiver, caps, type, stream) {
                var sdp = SDPUtils.writeRtpDescription(transceiver.kind, caps);

                // Map ICE parameters (ufrag, pwd) to SDP.
                sdp += SDPUtils.writeIceParameters(
                    transceiver.iceGatherer.getLocalParameters());

                // Map DTLS parameters to SDP.
                sdp += SDPUtils.writeDtlsParameters(
                    transceiver.dtlsTransport.getLocalParameters(),
                    type === &apos;offer&apos; ? &apos;actpass&apos; : &apos;active&apos;);

                sdp += &apos;a=mid:&apos; + transceiver.mid + &apos;\r\n&apos;;

                if (transceiver.direction) {
                    sdp += &apos;a=&apos; + transceiver.direction + &apos;\r\n&apos;;
                } else if (transceiver.rtpSender &amp;&amp; transceiver.rtpReceiver) {
                    sdp += &apos;a=sendrecv\r\n&apos;;
                } else if (transceiver.rtpSender) {
                    sdp += &apos;a=sendonly\r\n&apos;;
                } else if (transceiver.rtpReceiver) {
                    sdp += &apos;a=recvonly\r\n&apos;;
                } else {
                    sdp += &apos;a=inactive\r\n&apos;;
                }

                if (transceiver.rtpSender) {
                    // spec.
                    var msid = &apos;msid:&apos; + stream.id + &apos; &apos; +
                        transceiver.rtpSender.track.id + &apos;\r\n&apos;;
                    sdp += &apos;a=&apos; + msid;

                    // for Chrome.
                    sdp += &apos;a=ssrc:&apos; + transceiver.sendEncodingParameters[0].ssrc +
                        &apos; &apos; + msid;
                    if (transceiver.sendEncodingParameters[0].rtx) {
                        sdp += &apos;a=ssrc:&apos; + transceiver.sendEncodingParameters[0].rtx.ssrc +
                            &apos; &apos; + msid;
                        sdp += &apos;a=ssrc-group:FID &apos; +
                            transceiver.sendEncodingParameters[0].ssrc + &apos; &apos; +
                            transceiver.sendEncodingParameters[0].rtx.ssrc +
                            &apos;\r\n&apos;;
                    }
                }
                // FIXME: this should be written by writeRtpDescription.
                sdp += &apos;a=ssrc:&apos; + transceiver.sendEncodingParameters[0].ssrc +
                    &apos; cname:&apos; + SDPUtils.localCName + &apos;\r\n&apos;;
                if (transceiver.rtpSender &amp;&amp; transceiver.sendEncodingParameters[0].rtx) {
                    sdp += &apos;a=ssrc:&apos; + transceiver.sendEncodingParameters[0].rtx.ssrc +
                        &apos; cname:&apos; + SDPUtils.localCName + &apos;\r\n&apos;;
                }
                return sdp;
            };

            // Gets the direction from the mediaSection or the sessionpart.
            SDPUtils.getDirection = function(mediaSection, sessionpart) {
                // Look for sendrecv, sendonly, recvonly, inactive, default to sendrecv.
                var lines = SDPUtils.splitLines(mediaSection);
                for (var i = 0; i &lt; lines.length; i++) {
                    switch (lines[i]) {
                        case &apos;a=sendrecv&apos;:
                        case &apos;a=sendonly&apos;:
                        case &apos;a=recvonly&apos;:
                        case &apos;a=inactive&apos;:
                            return lines[i].substr(2);
                        default:
                            // FIXME: What should happen here?
                    }
                }
                if (sessionpart) {
                    return SDPUtils.getDirection(sessionpart);
                }
                return &apos;sendrecv&apos;;
            };

            SDPUtils.getKind = function(mediaSection) {
                var lines = SDPUtils.splitLines(mediaSection);
                var mline = lines[0].split(&apos; &apos;);
                return mline[0].substr(2);
            };

            SDPUtils.isRejected = function(mediaSection) {
                return mediaSection.split(&apos; &apos;, 2)[1] === &apos;0&apos;;
            };

            // Expose public methods.
            module.exports = SDPUtils;

        }, {}],
        2: [function(require, module, exports) {
            (function(global) {
                /*
                 *  Copyright (c) 2016 The WebRTC project authors. All Rights Reserved.
                 *
                 *  Use of this source code is governed by a BSD-style license
                 *  that can be found in the LICENSE file in the root of the source
                 *  tree.
                 */
                /* eslint-env node */

                &apos;use strict&apos;;

                var adapterFactory = require(&apos;./adapter_factory.js&apos;);
                module.exports = adapterFactory({
                    window: global.window
                });

            }).call(this, typeof global !== &quot;undefined&quot; ? global : typeof self !== &quot;undefined&quot; ? self : typeof window !== &quot;undefined&quot; ? window : {})
        }, {
            &quot;./adapter_factory.js&quot;: 3
        }],
        3: [function(require, module, exports) {
            /*
             *  Copyright (c) 2016 The WebRTC project authors. All Rights Reserved.
             *
             *  Use of this source code is governed by a BSD-style license
             *  that can be found in the LICENSE file in the root of the source
             *  tree.
             */
            /* eslint-env node */

            &apos;use strict&apos;;

            // Shimming starts here.
            module.exports = function(dependencies, opts) {
                var window = dependencies &amp;&amp; dependencies.window;

                var options = {
                    shimChrome: true,
                    shimFirefox: true,
                    shimEdge: true,
                    shimSafari: true,
                };

                for (var key in opts) {
                    if (hasOwnProperty.call(opts, key)) {
                        options[key] = opts[key];
                    }
                }

                // Utils.
                var utils = require(&apos;./utils&apos;);
                var logging = utils.log;
                var browserDetails = utils.detectBrowser(window);

                // Export to the adapter global object visible in the browser.
                var adapter = {
                    browserDetails: browserDetails,
                    extractVersion: utils.extractVersion,
                    disableLog: utils.disableLog,
                    disableWarnings: utils.disableWarnings
                };

                // Uncomment the line below if you want logging to occur, including logging
                // for the switch statement below. Can also be turned on in the browser via
                // adapter.disableLog(false), but then logging from the switch statement below
                // will not appear.
                // require(&apos;./utils&apos;).disableLog(false);

                // Browser shims.
                var chromeShim = require(&apos;./chrome/chrome_shim&apos;) || null;
                var edgeShim = require(&apos;./edge/edge_shim&apos;) || null;
                var firefoxShim = require(&apos;./firefox/firefox_shim&apos;) || null;
                var safariShim = require(&apos;./safari/safari_shim&apos;) || null;

                // Shim browser if found.
                switch (browserDetails.browser) {
                    case &apos;chrome&apos;:
                        if (!chromeShim || !chromeShim.shimPeerConnection ||
                            !options.shimChrome) {
                            logging(&apos;Chrome shim is not included in this adapter release.&apos;);
                            return adapter;
                        }
                        logging(&apos;adapter.js shimming chrome.&apos;);
                        // Export to the adapter global object visible in the browser.
                        adapter.browserShim = chromeShim;

                        chromeShim.shimGetUserMedia(window);
                        chromeShim.shimMediaStream(window);
                        utils.shimCreateObjectURL(window);
                        chromeShim.shimSourceObject(window);
                        chromeShim.shimPeerConnection(window);
                        chromeShim.shimOnTrack(window);
                        chromeShim.shimAddTrackRemoveTrack(window);
                        chromeShim.shimGetSendersWithDtmf(window);
                        break;
                    case &apos;firefox&apos;:
                        if (!firefoxShim || !firefoxShim.shimPeerConnection ||
                            !options.shimFirefox) {
                            logging(&apos;Firefox shim is not included in this adapter release.&apos;);
                            return adapter;
                        }
                        logging(&apos;adapter.js shimming firefox.&apos;);
                        // Export to the adapter global object visible in the browser.
                        adapter.browserShim = firefoxShim;

                        firefoxShim.shimGetUserMedia(window);
                        utils.shimCreateObjectURL(window);
                        firefoxShim.shimSourceObject(window);
                        firefoxShim.shimPeerConnection(window);
                        firefoxShim.shimOnTrack(window);
                        break;
                    case &apos;edge&apos;:
                        if (!edgeShim || !edgeShim.shimPeerConnection || !options.shimEdge) {
                            logging(&apos;MS edge shim is not included in this adapter release.&apos;);
                            return adapter;
                        }
                        logging(&apos;adapter.js shimming edge.&apos;);
                        // Export to the adapter global object visible in the browser.
                        adapter.browserShim = edgeShim;

                        edgeShim.shimGetUserMedia(window);
                        utils.shimCreateObjectURL(window);
                        edgeShim.shimPeerConnection(window);
                        edgeShim.shimReplaceTrack(window);
                        break;
                    case &apos;safari&apos;:
                        if (!safariShim || !options.shimSafari) {
                            logging(&apos;Safari shim is not included in this adapter release.&apos;);
                            return adapter;
                        }
                        logging(&apos;adapter.js shimming safari.&apos;);
                        // Export to the adapter global object visible in the browser.
                        adapter.browserShim = safariShim;
                        // shim window.URL.createObjectURL Safari (technical preview)
                        utils.shimCreateObjectURL(window);
                        safariShim.shimRTCIceServerUrls(window);
                        safariShim.shimCallbacksAPI(window);
                        safariShim.shimLocalStreamsAPI(window);
                        safariShim.shimRemoteStreamsAPI(window);
                        safariShim.shimGetUserMedia(window);
                        break;
                    default:
                        logging(&apos;Unsupported browser!&apos;);
                        break;
                }

                return adapter;
            };

        }, {
            &quot;./chrome/chrome_shim&quot;: 4,
            &quot;./edge/edge_shim&quot;: 6,
            &quot;./firefox/firefox_shim&quot;: 9,
            &quot;./safari/safari_shim&quot;: 11,
            &quot;./utils&quot;: 12
        }],
        4: [function(require, module, exports) {

            /*
             *  Copyright (c) 2016 The WebRTC project authors. All Rights Reserved.
             *
             *  Use of this source code is governed by a BSD-style license
             *  that can be found in the LICENSE file in the root of the source
             *  tree.
             */
            /* eslint-env node */
            &apos;use strict&apos;;
            var utils = require(&apos;../utils.js&apos;);
            var logging = utils.log;

            var chromeShim = {
                shimMediaStream: function(window) {
                    window.MediaStream = window.MediaStream || window.webkitMediaStream;
                },

                shimOnTrack: function(window) {
                    if (typeof window === &apos;object&apos; &amp;&amp; window.RTCPeerConnection &amp;&amp; !(&apos;ontrack&apos; in
                            window.RTCPeerConnection.prototype)) {
                        Object.defineProperty(window.RTCPeerConnection.prototype, &apos;ontrack&apos;, {
                            get: function() {
                                return this._ontrack;
                            },
                            set: function(f) {
                                if (this._ontrack) {
                                    this.removeEventListener(&apos;track&apos;, this._ontrack);
                                }
                                this.addEventListener(&apos;track&apos;, this._ontrack = f);
                            }
                        });
                        var origSetRemoteDescription =
                            window.RTCPeerConnection.prototype.setRemoteDescription;
                        window.RTCPeerConnection.prototype.setRemoteDescription = function() {
                            var pc = this;
                            if (!pc._ontrackpoly) {
                                pc._ontrackpoly = function(e) {
                                    // onaddstream does not fire when a track is added to an existing
                                    // stream. But stream.onaddtrack is implemented so we use that.
                                    e.stream.addEventListener(&apos;addtrack&apos;, function(te) {
                                        var receiver;
                                        if (window.RTCPeerConnection.prototype.getReceivers) {
                                            receiver = pc.getReceivers().find(function(r) {
                                                return r.track.id === te.track.id;
                                            });
                                        } else {
                                            receiver = {
                                                track: te.track
                                            };
                                        }

                                        var event = new Event(&apos;track&apos;);
                                        event.track = te.track;
                                        event.receiver = receiver;
                                        event.streams = [e.stream];
                                        pc.dispatchEvent(event);
                                    });
                                    e.stream.getTracks().forEach(function(track) {
                                        var receiver;
                                        if (window.RTCPeerConnection.prototype.getReceivers) {
                                            receiver = pc.getReceivers().find(function(r) {
                                                return r.track.id === track.id;
                                            });
                                        } else {
                                            receiver = {
                                                track: track
                                            };
                                        }
                                        var event = new Event(&apos;track&apos;);
                                        event.track = track;
                                        event.receiver = receiver;
                                        event.streams = [e.stream];
                                        pc.dispatchEvent(event);
                                    });
                                };
                                pc.addEventListener(&apos;addstream&apos;, pc._ontrackpoly);
                            }
                            return origSetRemoteDescription.apply(pc, arguments);
                        };
                    }
                },

                shimGetSendersWithDtmf: function(window) {
                    // Overrides addTrack/removeTrack, depends on shimAddTrackRemoveTrack.
                    if (typeof window === &apos;object&apos; &amp;&amp; window.RTCPeerConnection &amp;&amp;
                        !(&apos;getSenders&apos; in window.RTCPeerConnection.prototype) &amp;&amp;
                        &apos;createDTMFSender&apos; in window.RTCPeerConnection.prototype) {
                        var shimSenderWithDtmf = function(pc, track) {
                            return {
                                track: track,
                                get dtmf() {
                                    if (this._dtmf === undefined) {
                                        if (track.kind === &apos;audio&apos;) {
                                            this._dtmf = pc.createDTMFSender(track);
                                        } else {
                                            this._dtmf = null;
                                        }
                                    }
                                    return this._dtmf;
                                },
                                _pc: pc
                            };
                        };

                        // augment addTrack when getSenders is not available.
                        if (!window.RTCPeerConnection.prototype.getSenders) {
                            window.RTCPeerConnection.prototype.getSenders = function() {
                                this._senders = this._senders || [];
                                return this._senders.slice(); // return a copy of the internal state.
                            };
                            var origAddTrack = window.RTCPeerConnection.prototype.addTrack;
                            window.RTCPeerConnection.prototype.addTrack = function(track, stream) {
                                var pc = this;
                                var sender = origAddTrack.apply(pc, arguments);
                                if (!sender) {
                                    sender = shimSenderWithDtmf(pc, track);
                                    pc._senders.push(sender);
                                }
                                return sender;
                            };

                            var origRemoveTrack = window.RTCPeerConnection.prototype.removeTrack;
                            window.RTCPeerConnection.prototype.removeTrack = function(sender) {
                                var pc = this;
                                origRemoveTrack.apply(pc, arguments);
                                var idx = pc._senders.indexOf(sender);
                                if (idx !== -1) {
                                    pc._senders.splice(idx, 1);
                                }
                            };
                        }
                        var origAddStream = window.RTCPeerConnection.prototype.addStream;
                        window.RTCPeerConnection.prototype.addStream = function(stream) {
                            var pc = this;
                            pc._senders = pc._senders || [];
                            origAddStream.apply(pc, [stream]);
                            stream.getTracks().forEach(function(track) {
                                pc._senders.push(shimSenderWithDtmf(pc, track));
                            });
                        };

                        var origRemoveStream = window.RTCPeerConnection.prototype.removeStream;
                        window.RTCPeerConnection.prototype.removeStream = function(stream) {
                            var pc = this;
                            pc._senders = pc._senders || [];
                            origRemoveStream.apply(pc, [(pc._streams[stream.id] || stream)]);

                            stream.getTracks().forEach(function(track) {
                                var sender = pc._senders.find(function(s) {
                                    return s.track === track;
                                });
                                if (sender) {
                                    pc._senders.splice(pc._senders.indexOf(sender), 1); // remove sender
                                }
                            });
                        };
                    } else if (typeof window === &apos;object&apos; &amp;&amp; window.RTCPeerConnection &amp;&amp;
                        &apos;getSenders&apos; in window.RTCPeerConnection.prototype &amp;&amp;
                        &apos;createDTMFSender&apos; in window.RTCPeerConnection.prototype &amp;&amp;
                        window.RTCRtpSender &amp;&amp;
                        !(&apos;dtmf&apos; in window.RTCRtpSender.prototype)) {
                        var origGetSenders = window.RTCPeerConnection.prototype.getSenders;
                        window.RTCPeerConnection.prototype.getSenders = function() {
                            var pc = this;
                            var senders = origGetSenders.apply(pc, []);
                            senders.forEach(function(sender) {
                                sender._pc = pc;
                            });
                            return senders;
                        };

                        Object.defineProperty(window.RTCRtpSender.prototype, &apos;dtmf&apos;, {
                            get: function() {
                                if (this._dtmf === undefined) {
                                    if (this.track.kind === &apos;audio&apos;) {
                                        this._dtmf = this._pc.createDTMFSender(this.track);
                                    } else {
                                        this._dtmf = null;
                                    }
                                }
                                return this._dtmf;
                            }
                        });
                    }
                },

                shimSourceObject: function(window) {
                    var URL = window &amp;&amp; window.URL;

                    if (typeof window === &apos;object&apos;) {
                        if (window.HTMLMediaElement &amp;&amp;
                            !(&apos;srcObject&apos; in window.HTMLMediaElement.prototype)) {
                            // Shim the srcObject property, once, when HTMLMediaElement is found.
                            Object.defineProperty(window.HTMLMediaElement.prototype, &apos;srcObject&apos;, {
                                get: function() {
                                    return this._srcObject;
                                },
                                set: function(stream) {
                                    var self = this;
                                    // Use _srcObject as a private property for this shim
                                    this._srcObject = stream;
                                    if (this.src) {
                                        URL.revokeObjectURL(this.src);
                                    }

                                    if (!stream) {
                                        this.src = &apos;&apos;;
                                        return undefined;
                                    }
                                    this.src = URL.createObjectURL(stream);
                                    // We need to recreate the blob url when a track is added or
                                    // removed. Doing it manually since we want to avoid a recursion.
                                    stream.addEventListener(&apos;addtrack&apos;, function() {
                                        if (self.src) {
                                            URL.revokeObjectURL(self.src);
                                        }
                                        self.src = URL.createObjectURL(stream);
                                    });
                                    stream.addEventListener(&apos;removetrack&apos;, function() {
                                        if (self.src) {
                                            URL.revokeObjectURL(self.src);
                                        }
                                        self.src = URL.createObjectURL(stream);
                                    });
                                }
                            });
                        }
                    }
                },

                shimAddTrackRemoveTrack: function(window) {
                    // shim addTrack and removeTrack.
                    if (window.RTCPeerConnection.prototype.addTrack) {
                        return;
                    }

                    // also shim pc.getLocalStreams when addTrack is shimmed
                    // to return the original streams.
                    var origGetLocalStreams = window.RTCPeerConnection.prototype
                        .getLocalStreams;
                    window.RTCPeerConnection.prototype.getLocalStreams = function() {
                        var self = this;
                        var nativeStreams = origGetLocalStreams.apply(this);
                        self._reverseStreams = self._reverseStreams || {};
                        return nativeStreams.map(function(stream) {
                            return self._reverseStreams[stream.id];
                        });
                    };

                    var origAddStream = window.RTCPeerConnection.prototype.addStream;
                    window.RTCPeerConnection.prototype.addStream = function(stream) {
                        var pc = this;
                        pc._streams = pc._streams || {};
                        pc._reverseStreams = pc._reverseStreams || {};

                        stream.getTracks().forEach(function(track) {
                            var alreadyExists = pc.getSenders().find(function(s) {
                                return s.track === track;
                            });
                            if (alreadyExists) {
                                throw new DOMException(&apos;Track already exists.&apos;,
                                    &apos;InvalidAccessError&apos;);
                            }
                        });
                        // Add identity mapping for consistency with addTrack.
                        // Unless this is being used with a stream from addTrack.
                        if (!pc._reverseStreams[stream.id]) {
                            var newStream = new window.MediaStream(stream.getTracks());
                            pc._streams[stream.id] = newStream;
                            pc._reverseStreams[newStream.id] = stream;
                            stream = newStream;
                        }
                        origAddStream.apply(pc, [stream]);
                    };

                    var origRemoveStream = window.RTCPeerConnection.prototype.removeStream;
                    window.RTCPeerConnection.prototype.removeStream = function(stream) {
                        var pc = this;
                        pc._streams = pc._streams || {};
                        pc._reverseStreams = pc._reverseStreams || {};

                        origRemoveStream.apply(pc, [(pc._streams[stream.id] || stream)]);
                        delete pc._reverseStreams[(pc._streams[stream.id] ?
                            pc._streams[stream.id].id : stream.id)];
                        delete pc._streams[stream.id];
                    };

                    window.RTCPeerConnection.prototype.addTrack = function(track, stream) {
                        var pc = this;
                        if (pc.signalingState === &apos;closed&apos;) {
                            throw new DOMException(
                                &apos;The RTCPeerConnection\&apos;s signalingState is \&apos;closed\&apos;.&apos;,
                                &apos;InvalidStateError&apos;);
                        }
                        var streams = [].slice.call(arguments, 1);
                        if (streams.length !== 1 ||
                            !streams[0].getTracks().find(function(t) {
                                return t === track;
                            })) {
                            // this is not fully correct but all we can manage without
                            // [[associated MediaStreams]] internal slot.
                            throw new DOMException(
                                &apos;The adapter.js addTrack polyfill only supports a single &apos; +
                                &apos; stream which is associated with the specified track.&apos;,
                                &apos;NotSupportedError&apos;);
                        }

                        var alreadyExists = pc.getSenders().find(function(s) {
                            return s.track === track;
                        });
                        if (alreadyExists) {
                            throw new DOMException(&apos;Track already exists.&apos;,
                                &apos;InvalidAccessError&apos;);
                        }

                        pc._streams = pc._streams || {};
                        pc._reverseStreams = pc._reverseStreams || {};
                        var oldStream = pc._streams[stream.id];
                        if (oldStream) {
                            // this is using odd Chrome behaviour, use with caution:
                            // https://bugs.chromium.org/p/webrtc/issues/detail?id=7815
                            // Note: we rely on the high-level addTrack/dtmf shim to
                            // create the sender with a dtmf sender.
                            oldStream.addTrack(track);
                            pc.dispatchEvent(new Event(&apos;negotiationneeded&apos;));
                        } else {
                            var newStream = new window.MediaStream([track]);
                            pc._streams[stream.id] = newStream;
                            pc._reverseStreams[newStream.id] = stream;
                            pc.addStream(newStream);
                        }
                        return pc.getSenders().find(function(s) {
                            return s.track === track;
                        });
                    };

                    window.RTCPeerConnection.prototype.removeTrack = function(sender) {
                        var pc = this;
                        if (pc.signalingState === &apos;closed&apos;) {
                            throw new DOMException(
                                &apos;The RTCPeerConnection\&apos;s signalingState is \&apos;closed\&apos;.&apos;,
                                &apos;InvalidStateError&apos;);
                        }
                        // We can not yet check for sender instanceof RTCRtpSender
                        // since we shim RTPSender. So we check if sender._pc is set.
                        if (!sender._pc) {
                            throw new DOMException(&apos;Argument 1 of RTCPeerConnection.removeTrack &apos; +
                                &apos;does not implement interface RTCRtpSender.&apos;, &apos;TypeError&apos;);
                        }
                        var isLocal = sender._pc === pc;
                        if (!isLocal) {
                            throw new DOMException(&apos;Sender was not created by this connection.&apos;,
                                &apos;InvalidAccessError&apos;);
                        }

                        // Search for the native stream the senders track belongs to.
                        pc._streams = pc._streams || {};
                        var stream;
                        Object.keys(pc._streams).forEach(function(streamid) {
                            var hasTrack = pc._streams[streamid].getTracks().find(function(track) {
                                return sender.track === track;
                            });
                            if (hasTrack) {
                                stream = pc._streams[streamid];
                            }
                        });

                        if (stream) {
                            if (stream.getTracks().length === 1) {
                                // if this is the last track of the stream, remove the stream. This
                                // takes care of any shimmed _senders.
                                pc.removeStream(stream);
                            } else {
                                // relying on the same odd chrome behaviour as above.
                                stream.removeTrack(sender.track);
                            }
                            pc.dispatchEvent(new Event(&apos;negotiationneeded&apos;));
                        }
                    };
                },

                shimPeerConnection: function(window) {
                    var browserDetails = utils.detectBrowser(window);

                    // The RTCPeerConnection object.
                    if (!window.RTCPeerConnection) {
                        window.RTCPeerConnection = function(pcConfig, pcConstraints) {
                            // Translate iceTransportPolicy to iceTransports,
                            // see https://code.google.com/p/webrtc/issues/detail?id=4869
                            // this was fixed in M56 along with unprefixing RTCPeerConnection.
                            logging(&apos;PeerConnection&apos;);
                            if (pcConfig &amp;&amp; pcConfig.iceTransportPolicy) {
                                pcConfig.iceTransports = pcConfig.iceTransportPolicy;
                            }

                            return new window.webkitRTCPeerConnection(pcConfig, pcConstraints);
                        };
                        window.RTCPeerConnection.prototype =
                            window.webkitRTCPeerConnection.prototype;
                        // wrap static methods. Currently just generateCertificate.
                        if (window.webkitRTCPeerConnection.generateCertificate) {
                            Object.defineProperty(window.RTCPeerConnection, &apos;generateCertificate&apos;, {
                                get: function() {
                                    return window.webkitRTCPeerConnection.generateCertificate;
                                }
                            });
                        }
                    } else {
                        // migrate from non-spec RTCIceServer.url to RTCIceServer.urls
                        var OrigPeerConnection = window.RTCPeerConnection;
                        window.RTCPeerConnection = function(pcConfig, pcConstraints) {
                            if (pcConfig &amp;&amp; pcConfig.iceServers) {
                                var newIceServers = [];
                                for (var i = 0; i &lt; pcConfig.iceServers.length; i++) {
                                    var server = pcConfig.iceServers[i];
                                    if (!server.hasOwnProperty(&apos;urls&apos;) &amp;&amp;
                                        server.hasOwnProperty(&apos;url&apos;)) {
                                        utils.deprecated(&apos;RTCIceServer.url&apos;, &apos;RTCIceServer.urls&apos;);
                                        server = JSON.parse(JSON.stringify(server));
                                        server.urls = server.url;
                                        newIceServers.push(server);
                                    } else {
                                        newIceServers.push(pcConfig.iceServers[i]);
                                    }
                                }
                                pcConfig.iceServers = newIceServers;
                            }
                            return new OrigPeerConnection(pcConfig, pcConstraints);
                        };
                        window.RTCPeerConnection.prototype = OrigPeerConnection.prototype;
                        // wrap static methods. Currently just generateCertificate.
                        Object.defineProperty(window.RTCPeerConnection, &apos;generateCertificate&apos;, {
                            get: function() {
                                return OrigPeerConnection.generateCertificate;
                            }
                        });
                    }

                    var origGetStats = window.RTCPeerConnection.prototype.getStats;
                    window.RTCPeerConnection.prototype.getStats = function(selector,
                        successCallback, errorCallback) {
                        var self = this;
                        var args = arguments;

                        // If selector is a function then we are in the old style stats so just
                        // pass back the original getStats format to avoid breaking old users.
                        if (arguments.length &gt; 0 &amp;&amp; typeof selector === &apos;function&apos;) {
                            return origGetStats.apply(this, arguments);
                        }

                        // When spec-style getStats is supported, return those when called with
                        // either no arguments or the selector argument is null.
                        if (origGetStats.length === 0 &amp;&amp; (arguments.length === 0 ||
                                typeof arguments[0] !== &apos;function&apos;)) {
                            return origGetStats.apply(this, []);
                        }

                        var fixChromeStats_ = function(response) {
                            var standardReport = {};
                            var reports = response.result();
                            reports.forEach(function(report) {
                                var standardStats = {
                                    id: report.id,
                                    timestamp: report.timestamp,
                                    type: {
                                        localcandidate: &apos;local-candidate&apos;,
                                        remotecandidate: &apos;remote-candidate&apos;
                                    }[report.type] || report.type
                                };
                                report.names().forEach(function(name) {
                                    standardStats[name] = report.stat(name);
                                });
                                standardReport[standardStats.id] = standardStats;
                            });

                            return standardReport;
                        };

                        // shim getStats with maplike support
                        var makeMapStats = function(stats) {
                            return new Map(Object.keys(stats).map(function(key) {
                                return [key, stats[key]];
                            }));
                        };

                        if (arguments.length &gt;= 2) {
                            var successCallbackWrapper_ = function(response) {
                                args[1](makeMapStats(fixChromeStats_(response)));
                            };

                            return origGetStats.apply(this, [successCallbackWrapper_,
                                arguments[0]
                            ]);
                        }

                        // promise-support
                        return new Promise(function(resolve, reject) {
                            origGetStats.apply(self, [
                                function(response) {
                                    resolve(makeMapStats(fixChromeStats_(response)));
                                },
                                reject
                            ]);
                        }).then(successCallback, errorCallback);
                    };

                    // add promise support -- natively available in Chrome 51
                    if (browserDetails.version &lt; 51) {
                        [&apos;setLocalDescription&apos;, &apos;setRemoteDescription&apos;, &apos;addIceCandidate&apos;]
                        .forEach(function(method) {
                            var nativeMethod = window.RTCPeerConnection.prototype[method];
                            window.RTCPeerConnection.prototype[method] = function() {
                                var args = arguments;
                                var self = this;
                                var promise = new Promise(function(resolve, reject) {
                                    nativeMethod.apply(self, [args[0], resolve, reject]);
                                });
                                if (args.length &lt; 2) {
                                    return promise;
                                }
                                return promise.then(function() {
                                        args[1].apply(null, []);
                                    },
                                    function(err) {
                                        if (args.length &gt;= 3) {
                                            args[2].apply(null, [err]);
                                        }
                                    });
                            };
                        });
                    }

                    // promise support for createOffer and createAnswer. Available (without
                    // bugs) since M52: crbug/619289
                    if (browserDetails.version &lt; 52) {
                        [&apos;createOffer&apos;, &apos;createAnswer&apos;].forEach(function(method) {
                            var nativeMethod = window.RTCPeerConnection.prototype[method];
                            window.RTCPeerConnection.prototype[method] = function() {
                                var self = this;
                                if (arguments.length &lt; 1 || (arguments.length === 1 &amp;&amp;
                                        typeof arguments[0] === &apos;object&apos;)) {
                                    var opts = arguments.length === 1 ? arguments[0] : undefined;
                                    return new Promise(function(resolve, reject) {
                                        nativeMethod.apply(self, [resolve, reject, opts]);
                                    });
                                }
                                return nativeMethod.apply(this, arguments);
                            };
                        });
                    }

                    // shim implicit creation of RTCSessionDescription/RTCIceCandidate
                    [&apos;setLocalDescription&apos;, &apos;setRemoteDescription&apos;, &apos;addIceCandidate&apos;]
                    .forEach(function(method) {
                        var nativeMethod = window.RTCPeerConnection.prototype[method];
                        window.RTCPeerConnection.prototype[method] = function() {
                            arguments[0] = new((method === &apos;addIceCandidate&apos;) ?
                                window.RTCIceCandidate :
                                window.RTCSessionDescription)(arguments[0]);
                            return nativeMethod.apply(this, arguments);
                        };
                    });

                    // support for addIceCandidate(null or undefined)
                    var nativeAddIceCandidate =
                        window.RTCPeerConnection.prototype.addIceCandidate;
                    window.RTCPeerConnection.prototype.addIceCandidate = function() {
                        if (!arguments[0]) {
                            if (arguments[1]) {
                                arguments[1].apply(null);
                            }
                            return Promise.resolve();
                        }
                        return nativeAddIceCandidate.apply(this, arguments);
                    };
                }
            };


            // Expose public methods.
            module.exports = {
                shimMediaStream: chromeShim.shimMediaStream,
                shimOnTrack: chromeShim.shimOnTrack,
                shimAddTrackRemoveTrack: chromeShim.shimAddTrackRemoveTrack,
                shimGetSendersWithDtmf: chromeShim.shimGetSendersWithDtmf,
                shimSourceObject: chromeShim.shimSourceObject,
                shimPeerConnection: chromeShim.shimPeerConnection,
                shimGetUserMedia: require(&apos;./getusermedia&apos;)
            };

        }, {
            &quot;../utils.js&quot;: 12,
            &quot;./getusermedia&quot;: 5
        }],
        5: [function(require, module, exports) {
            /*
             *  Copyright (c) 2016 The WebRTC project authors. All Rights Reserved.
             *
             *  Use of this source code is governed by a BSD-style license
             *  that can be found in the LICENSE file in the root of the source
             *  tree.
             */
            /* eslint-env node */
            &apos;use strict&apos;;
            var utils = require(&apos;../utils.js&apos;);
            var logging = utils.log;

            // Expose public methods.
            module.exports = function(window) {
                var browserDetails = utils.detectBrowser(window);
                var navigator = window &amp;&amp; window.navigator;

                var constraintsToChrome_ = function(c) {
                    if (typeof c !== &apos;object&apos; || c.mandatory || c.optional) {
                        return c;
                    }
                    var cc = {};
                    Object.keys(c).forEach(function(key) {
                        if (key === &apos;require&apos; || key === &apos;advanced&apos; || key === &apos;mediaSource&apos;) {
                            return;
                        }
                        var r = (typeof c[key] === &apos;object&apos;) ? c[key] : {
                            ideal: c[key]
                        };
                        if (r.exact !== undefined &amp;&amp; typeof r.exact === &apos;number&apos;) {
                            r.min = r.max = r.exact;
                        }
                        var oldname_ = function(prefix, name) {
                            if (prefix) {
                                return prefix + name.charAt(0).toUpperCase() + name.slice(1);
                            }
                            return (name === &apos;deviceId&apos;) ? &apos;sourceId&apos; : name;
                        };
                        if (r.ideal !== undefined) {
                            cc.optional = cc.optional || [];
                            var oc = {};
                            if (typeof r.ideal === &apos;number&apos;) {
                                oc[oldname_(&apos;min&apos;, key)] = r.ideal;
                                cc.optional.push(oc);
                                oc = {};
                                oc[oldname_(&apos;max&apos;, key)] = r.ideal;
                                cc.optional.push(oc);
                            } else {
                                oc[oldname_(&apos;&apos;, key)] = r.ideal;
                                cc.optional.push(oc);
                            }
                        }
                        if (r.exact !== undefined &amp;&amp; typeof r.exact !== &apos;number&apos;) {
                            cc.mandatory = cc.mandatory || {};
                            cc.mandatory[oldname_(&apos;&apos;, key)] = r.exact;
                        } else {
                            [&apos;min&apos;, &apos;max&apos;].forEach(function(mix) {
                                if (r[mix] !== undefined) {
                                    cc.mandatory = cc.mandatory || {};
                                    cc.mandatory[oldname_(mix, key)] = r[mix];
                                }
                            });
                        }
                    });
                    if (c.advanced) {
                        cc.optional = (cc.optional || []).concat(c.advanced);
                    }
                    return cc;
                };

                var shimConstraints_ = function(constraints, func) {
                    constraints = JSON.parse(JSON.stringify(constraints));
                    if (constraints &amp;&amp; typeof constraints.audio === &apos;object&apos;) {
                        var remap = function(obj, a, b) {
                            if (a in obj &amp;&amp; !(b in obj)) {
                                obj[b] = obj[a];
                                delete obj[a];
                            }
                        };
                        constraints = JSON.parse(JSON.stringify(constraints));
                        remap(constraints.audio, &apos;autoGainControl&apos;, &apos;googAutoGainControl&apos;);
                        remap(constraints.audio, &apos;noiseSuppression&apos;, &apos;googNoiseSuppression&apos;);
                        constraints.audio = constraintsToChrome_(constraints.audio);
                    }
                    if (constraints &amp;&amp; typeof constraints.video === &apos;object&apos;) {
                        // Shim facingMode for mobile &amp; surface pro.
                        var face = constraints.video.facingMode;
                        face = face &amp;&amp; ((typeof face === &apos;object&apos;) ? face : {
                            ideal: face
                        });
                        var getSupportedFacingModeLies = browserDetails.version &lt; 61;

                        if ((face &amp;&amp; (face.exact === &apos;user&apos; || face.exact === &apos;environment&apos; ||
                                face.ideal === &apos;user&apos; || face.ideal === &apos;environment&apos;)) &amp;&amp;
                            !(navigator.mediaDevices.getSupportedConstraints &amp;&amp;
                                navigator.mediaDevices.getSupportedConstraints().facingMode &amp;&amp;
                                !getSupportedFacingModeLies)) {
                            delete constraints.video.facingMode;
                            var matches;
                            if (face.exact === &apos;environment&apos; || face.ideal === &apos;environment&apos;) {
                                matches = [&apos;back&apos;, &apos;rear&apos;];
                            } else if (face.exact === &apos;user&apos; || face.ideal === &apos;user&apos;) {
                                matches = [&apos;front&apos;];
                            }
                            if (matches) {
                                // Look for matches in label, or use last cam for back (typical).
                                return navigator.mediaDevices.enumerateDevices()
                                    .then(function(devices) {
                                        devices = devices.filter(function(d) {
                                            return d.kind === &apos;videoinput&apos;;
                                        });
                                        var dev = devices.find(function(d) {
                                            return matches.some(function(match) {
                                                return d.label.toLowerCase().indexOf(match) !== -1;
                                            });
                                        });
                                        if (!dev &amp;&amp; devices.length &amp;&amp; matches.indexOf(&apos;back&apos;) !== -1) {
                                            dev = devices[devices.length - 1]; // more likely the back cam
                                        }
                                        if (dev) {
                                            constraints.video.deviceId = face.exact ? {
                                                exact: dev.deviceId
                                            } : {
                                                ideal: dev.deviceId
                                            };
                                        }
                                        constraints.video = constraintsToChrome_(constraints.video);
                                        logging(&apos;chrome: &apos; + JSON.stringify(constraints));
                                        return func(constraints);
                                    });
                            }
                        }
                        constraints.video = constraintsToChrome_(constraints.video);
                    }
                    logging(&apos;chrome: &apos; + JSON.stringify(constraints));
                    return func(constraints);
                };

                var shimError_ = function(e) {
                    return {
                        name: {
                            PermissionDeniedError: &apos;NotAllowedError&apos;,
                            InvalidStateError: &apos;NotReadableError&apos;,
                            DevicesNotFoundError: &apos;NotFoundError&apos;,
                            ConstraintNotSatisfiedError: &apos;OverconstrainedError&apos;,
                            TrackStartError: &apos;NotReadableError&apos;,
                            MediaDeviceFailedDueToShutdown: &apos;NotReadableError&apos;,
                            MediaDeviceKillSwitchOn: &apos;NotReadableError&apos;
                        }[e.name] || e.name,
                        message: e.message,
                        constraint: e.constraintName,
                        toString: function() {
                            return this.name + (this.message &amp;&amp; &apos;: &apos;) + this.message;
                        }
                    };
                };

                var getUserMedia_ = function(constraints, onSuccess, onError) {
                    shimConstraints_(constraints, function(c) {
                        navigator.webkitGetUserMedia(c, onSuccess, function(e) {
                            onError(shimError_(e));
                        });
                    });
                };

                navigator.getUserMedia = getUserMedia_;

                // Returns the result of getUserMedia as a Promise.
                var getUserMediaPromise_ = function(constraints) {
                    return new Promise(function(resolve, reject) {
                        navigator.getUserMedia(constraints, resolve, reject);
                    });
                };

                if (!navigator.mediaDevices) {
                    navigator.mediaDevices = {
                        getUserMedia: getUserMediaPromise_,
                        enumerateDevices: function() {
                            return new Promise(function(resolve) {
                                var kinds = {
                                    audio: &apos;audioinput&apos;,
                                    video: &apos;videoinput&apos;
                                };
                                return window.MediaStreamTrack.getSources(function(devices) {
                                    resolve(devices.map(function(device) {
                                        return {
                                            label: device.label,
                                            kind: kinds[device.kind],
                                            deviceId: device.id,
                                            groupId: &apos;&apos;
                                        };
                                    }));
                                });
                            });
                        },
                        getSupportedConstraints: function() {
                            return {
                                deviceId: true,
                                echoCancellation: true,
                                facingMode: true,
                                frameRate: true,
                                height: true,
                                width: true
                            };
                        }
                    };
                }

                // A shim for getUserMedia method on the mediaDevices object.
                // TODO(KaptenJansson) remove once implemented in Chrome stable.
                if (!navigator.mediaDevices.getUserMedia) {
                    navigator.mediaDevices.getUserMedia = function(constraints) {
                        return getUserMediaPromise_(constraints);
                    };
                } else {
                    // Even though Chrome 45 has navigator.mediaDevices and a getUserMedia
                    // function which returns a Promise, it does not accept spec-style
                    // constraints.
                    var origGetUserMedia = navigator.mediaDevices.getUserMedia.
                    bind(navigator.mediaDevices);
                    navigator.mediaDevices.getUserMedia = function(cs) {
                        return shimConstraints_(cs, function(c) {
                            return origGetUserMedia(c).then(function(stream) {
                                if (c.audio &amp;&amp; !stream.getAudioTracks().length ||
                                    c.video &amp;&amp; !stream.getVideoTracks().length) {
                                    stream.getTracks().forEach(function(track) {
                                        track.stop();
                                    });
                                    throw new DOMException(&apos;&apos;, &apos;NotFoundError&apos;);
                                }
                                return stream;
                            }, function(e) {
                                return Promise.reject(shimError_(e));
                            });
                        });
                    };
                }

                // Dummy devicechange event methods.
                // TODO(KaptenJansson) remove once implemented in Chrome stable.
                if (typeof navigator.mediaDevices.addEventListener === &apos;undefined&apos;) {
                    navigator.mediaDevices.addEventListener = function() {
                        logging(&apos;Dummy mediaDevices.addEventListener called.&apos;);
                    };
                }
                if (typeof navigator.mediaDevices.removeEventListener === &apos;undefined&apos;) {
                    navigator.mediaDevices.removeEventListener = function() {
                        logging(&apos;Dummy mediaDevices.removeEventListener called.&apos;);
                    };
                }
            };

        }, {
            &quot;../utils.js&quot;: 12
        }],
        6: [function(require, module, exports) {
            /*
             *  Copyright (c) 2016 The WebRTC project authors. All Rights Reserved.
             *
             *  Use of this source code is governed by a BSD-style license
             *  that can be found in the LICENSE file in the root of the source
             *  tree.
             */
            /* eslint-env node */
            &apos;use strict&apos;;

            var utils = require(&apos;../utils&apos;);
            var shimRTCPeerConnection = require(&apos;./rtcpeerconnection_shim&apos;);

            module.exports = {
                shimGetUserMedia: require(&apos;./getusermedia&apos;),
                shimPeerConnection: function(window) {
                    var browserDetails = utils.detectBrowser(window);

                    if (window.RTCIceGatherer) {
                        // ORTC defines an RTCIceCandidate object but no constructor.
                        // Not implemented in Edge.
                        if (!window.RTCIceCandidate) {
                            window.RTCIceCandidate = function(args) {
                                return args;
                            };
                        }
                        // ORTC does not have a session description object but
                        // other browsers (i.e. Chrome) that will support both PC and ORTC
                        // in the future might have this defined already.
                        if (!window.RTCSessionDescription) {
                            window.RTCSessionDescription = function(args) {
                                return args;
                            };
                        }
                        // this adds an additional event listener to MediaStrackTrack that signals
                        // when a tracks enabled property was changed. Workaround for a bug in
                        // addStream, see below. No longer required in 15025+
                        if (browserDetails.version &lt; 15025) {
                            var origMSTEnabled = Object.getOwnPropertyDescriptor(
                                window.MediaStreamTrack.prototype, &apos;enabled&apos;);
                            Object.defineProperty(window.MediaStreamTrack.prototype, &apos;enabled&apos;, {
                                set: function(value) {
                                    origMSTEnabled.set.call(this, value);
                                    var ev = new Event(&apos;enabled&apos;);
                                    ev.enabled = value;
                                    this.dispatchEvent(ev);
                                }
                            });
                        }
                    }

                    // ORTC defines the DTMF sender a bit different.
                    // https://github.com/w3c/ortc/issues/714
                    if (window.RTCRtpSender &amp;&amp; !(&apos;dtmf&apos; in window.RTCRtpSender.prototype)) {
                        Object.defineProperty(window.RTCRtpSender.prototype, &apos;dtmf&apos;, {
                            get: function() {
                                if (this._dtmf === undefined) {
                                    if (this.track.kind === &apos;audio&apos;) {
                                        this._dtmf = new window.RTCDtmfSender(this);
                                    } else if (this.track.kind === &apos;video&apos;) {
                                        this._dtmf = null;
                                    }
                                }
                                return this._dtmf;
                            }
                        });
                    }

                    window.RTCPeerConnection =
                        shimRTCPeerConnection(window, browserDetails.version);
                },
                shimReplaceTrack: function(window) {
                    // ORTC has replaceTrack -- https://github.com/w3c/ortc/issues/614
                    if (window.RTCRtpSender &amp;&amp;
                        !(&apos;replaceTrack&apos; in window.RTCRtpSender.prototype)) {
                        window.RTCRtpSender.prototype.replaceTrack =
                            window.RTCRtpSender.prototype.setTrack;
                    }
                }
            };

        }, {
            &quot;../utils&quot;: 12,
            &quot;./getusermedia&quot;: 7,
            &quot;./rtcpeerconnection_shim&quot;: 8
        }],
        7: [function(require, module, exports) {
            /*
             *  Copyright (c) 2016 The WebRTC project authors. All Rights Reserved.
             *
             *  Use of this source code is governed by a BSD-style license
             *  that can be found in the LICENSE file in the root of the source
             *  tree.
             */
            /* eslint-env node */
            &apos;use strict&apos;;

            // Expose public methods.
            module.exports = function(window) {
                var navigator = window &amp;&amp; window.navigator;

                var shimError_ = function(e) {
                    return {
                        name: {
                            PermissionDeniedError: &apos;NotAllowedError&apos;
                        }[e.name] || e.name,
                        message: e.message,
                        constraint: e.constraint,
                        toString: function() {
                            return this.name;
                        }
                    };
                };

                // getUserMedia error shim.
                var origGetUserMedia = navigator.mediaDevices.getUserMedia.
                bind(navigator.mediaDevices);
                navigator.mediaDevices.getUserMedia = function(c) {
                    return origGetUserMedia(c).catch(function(e) {
                        return Promise.reject(shimError_(e));
                    });
                };
            };

        }, {}],
        8: [function(require, module, exports) {
            /*
             *  Copyright (c) 2017 The WebRTC project authors. All Rights Reserved.
             *
             *  Use of this source code is governed by a BSD-style license
             *  that can be found in the LICENSE file in the root of the source
             *  tree.
             */
            /* eslint-env node */
            &apos;use strict&apos;;

            var SDPUtils = require(&apos;sdp&apos;);

            // sort tracks such that they follow an a-v-a-v...
            // pattern.
            function sortTracks(tracks) {
                var audioTracks = tracks.filter(function(track) {
                    return track.kind === &apos;audio&apos;;
                });
                var videoTracks = tracks.filter(function(track) {
                    return track.kind === &apos;video&apos;;
                });
                tracks = [];
                while (audioTracks.length || videoTracks.length) {
                    if (audioTracks.length) {
                        tracks.push(audioTracks.shift());
                    }
                    if (videoTracks.length) {
                        tracks.push(videoTracks.shift());
                    }
                }
                return tracks;
            }

            // Edge does not like
            // 1) stun:
            // 2) turn: that does not have all of turn:host:port?transport=udp
            // 3) turn: with ipv6 addresses
            // 4) turn: occurring muliple times
            function filterIceServers(iceServers, edgeVersion) {
                var hasTurn = false;
                iceServers = JSON.parse(JSON.stringify(iceServers));
                return iceServers.filter(function(server) {
                    if (server &amp;&amp; (server.urls || server.url)) {
                        var urls = server.urls || server.url;
                        if (server.url &amp;&amp; !server.urls) {
                            console.warn(&apos;RTCIceServer.url is deprecated! Use urls instead.&apos;);
                        }
                        var isString = typeof urls === &apos;string&apos;;
                        if (isString) {
                            urls = [urls];
                        }
                        urls = urls.filter(function(url) {
                            var validTurn = url.indexOf(&apos;turn:&apos;) === 0 &amp;&amp;
                                url.indexOf(&apos;transport=udp&apos;) !== -1 &amp;&amp;
                                url.indexOf(&apos;turn:[&apos;) === -1 &amp;&amp;
                                !hasTurn;

                            if (validTurn) {
                                hasTurn = true;
                                return true;
                            }
                            return url.indexOf(&apos;stun:&apos;) === 0 &amp;&amp; edgeVersion &gt;= 14393;
                        });

                        delete server.url;
                        server.urls = isString ? urls[0] : urls;
                        return !!urls.length;
                    }
                    return false;
                });
            }

            // Determines the intersection of local and remote capabilities.
            function getCommonCapabilities(localCapabilities, remoteCapabilities) {
                var commonCapabilities = {
                    codecs: [],
                    headerExtensions: [],
                    fecMechanisms: []
                };

                var findCodecByPayloadType = function(pt, codecs) {
                    pt = parseInt(pt, 10);
                    for (var i = 0; i &lt; codecs.length; i++) {
                        if (codecs[i].payloadType === pt ||
                            codecs[i].preferredPayloadType === pt) {
                            return codecs[i];
                        }
                    }
                };

                var rtxCapabilityMatches = function(lRtx, rRtx, lCodecs, rCodecs) {
                    var lCodec = findCodecByPayloadType(lRtx.parameters.apt, lCodecs);
                    var rCodec = findCodecByPayloadType(rRtx.parameters.apt, rCodecs);
                    return lCodec &amp;&amp; rCodec &amp;&amp;
                        lCodec.name.toLowerCase() === rCodec.name.toLowerCase();
                };

                localCapabilities.codecs.forEach(function(lCodec) {
                    for (var i = 0; i &lt; remoteCapabilities.codecs.length; i++) {
                        var rCodec = remoteCapabilities.codecs[i];
                        if (lCodec.name.toLowerCase() === rCodec.name.toLowerCase() &amp;&amp;
                            lCodec.clockRate === rCodec.clockRate) {
                            if (lCodec.name.toLowerCase() === &apos;rtx&apos; &amp;&amp;
                                lCodec.parameters &amp;&amp; rCodec.parameters.apt) {
                                // for RTX we need to find the local rtx that has a apt
                                // which points to the same local codec as the remote one.
                                if (!rtxCapabilityMatches(lCodec, rCodec,
                                        localCapabilities.codecs, remoteCapabilities.codecs)) {
                                    continue;
                                }
                            }
                            rCodec = JSON.parse(JSON.stringify(rCodec)); // deepcopy
                            // number of channels is the highest common number of channels
                            rCodec.numChannels = Math.min(lCodec.numChannels,
                                rCodec.numChannels);
                            // push rCodec so we reply with offerer payload type
                            commonCapabilities.codecs.push(rCodec);

                            // determine common feedback mechanisms
                            rCodec.rtcpFeedback = rCodec.rtcpFeedback.filter(function(fb) {
                                for (var j = 0; j &lt; lCodec.rtcpFeedback.length; j++) {
                                    if (lCodec.rtcpFeedback[j].type === fb.type &amp;&amp;
                                        lCodec.rtcpFeedback[j].parameter === fb.parameter) {
                                        return true;
                                    }
                                }
                                return false;
                            });
                            // FIXME: also need to determine .parameters
                            //  see https://github.com/openpeer/ortc/issues/569
                            break;
                        }
                    }
                });

                localCapabilities.headerExtensions.forEach(function(lHeaderExtension) {
                    for (var i = 0; i &lt; remoteCapabilities.headerExtensions.length; i++) {
                        var rHeaderExtension = remoteCapabilities.headerExtensions[i];
                        if (lHeaderExtension.uri === rHeaderExtension.uri) {
                            commonCapabilities.headerExtensions.push(rHeaderExtension);
                            break;
                        }
                    }
                });

                // FIXME: fecMechanisms
                return commonCapabilities;
            }

            // is action=setLocalDescription with type allowed in signalingState
            function isActionAllowedInSignalingState(action, type, signalingState) {
                return {
                    offer: {
                        setLocalDescription: [&apos;stable&apos;, &apos;have-local-offer&apos;],
                        setRemoteDescription: [&apos;stable&apos;, &apos;have-remote-offer&apos;]
                    },
                    answer: {
                        setLocalDescription: [&apos;have-remote-offer&apos;, &apos;have-local-pranswer&apos;],
                        setRemoteDescription: [&apos;have-local-offer&apos;, &apos;have-remote-pranswer&apos;]
                    }
                }[type][action].indexOf(signalingState) !== -1;
            }

            module.exports = function(window, edgeVersion) {
                var RTCPeerConnection = function(config) {
                    var self = this;

                    var _eventTarget = document.createDocumentFragment();
                    [&apos;addEventListener&apos;, &apos;removeEventListener&apos;, &apos;dispatchEvent&apos;]
                    .forEach(function(method) {
                        self[method] = _eventTarget[method].bind(_eventTarget);
                    });

                    this.needNegotiation = false;

                    this.onicecandidate = null;
                    this.onaddstream = null;
                    this.ontrack = null;
                    this.onremovestream = null;
                    this.onsignalingstatechange = null;
                    this.oniceconnectionstatechange = null;
                    this.onicegatheringstatechange = null;
                    this.onnegotiationneeded = null;
                    this.ondatachannel = null;
                    this.canTrickleIceCandidates = null;

                    this.localStreams = [];
                    this.remoteStreams = [];
                    this.getLocalStreams = function() {
                        return self.localStreams;
                    };
                    this.getRemoteStreams = function() {
                        return self.remoteStreams;
                    };

                    this.localDescription = new window.RTCSessionDescription({
                        type: &apos;&apos;,
                        sdp: &apos;&apos;
                    });
                    this.remoteDescription = new window.RTCSessionDescription({
                        type: &apos;&apos;,
                        sdp: &apos;&apos;
                    });
                    this.signalingState = &apos;stable&apos;;
                    this.iceConnectionState = &apos;new&apos;;
                    this.iceGatheringState = &apos;new&apos;;

                    this.iceOptions = {
                        gatherPolicy: &apos;all&apos;,
                        iceServers: []
                    };
                    if (config &amp;&amp; config.iceTransportPolicy) {
                        switch (config.iceTransportPolicy) {
                            case &apos;all&apos;:
                            case &apos;relay&apos;:
                                this.iceOptions.gatherPolicy = config.iceTransportPolicy;
                                break;
                            default:
                                // don&apos;t set iceTransportPolicy.
                                break;
                        }
                    }
                    this.usingBundle = config &amp;&amp; config.bundlePolicy === &apos;max-bundle&apos;;

                    if (config &amp;&amp; config.iceServers) {
                        this.iceOptions.iceServers = filterIceServers(config.iceServers,
                            edgeVersion);
                    }
                    this._config = config || {};

                    // per-track iceGathers, iceTransports, dtlsTransports, rtpSenders, ...
                    // everything that is needed to describe a SDP m-line.
                    this.transceivers = [];

                    // since the iceGatherer is currently created in createOffer but we
                    // must not emit candidates until after setLocalDescription we buffer
                    // them in this array.
                    this._localIceCandidatesBuffer = [];

                    this._sdpSessionId = SDPUtils.generateSessionId();
                };

                RTCPeerConnection.prototype._emitGatheringStateChange = function() {
                    var event = new Event(&apos;icegatheringstatechange&apos;);
                    this.dispatchEvent(event);
                    if (this.onicegatheringstatechange !== null) {
                        this.onicegatheringstatechange(event);
                    }
                };

                RTCPeerConnection.prototype._emitBufferedCandidates = function() {
                    var self = this;
                    var sections = SDPUtils.splitSections(self.localDescription.sdp);
                    // FIXME: need to apply ice candidates in a way which is async but
                    // in-order
                    this._localIceCandidatesBuffer.forEach(function(event) {
                        var end = !event.candidate || Object.keys(event.candidate).length === 0;
                        if (end) {
                            for (var j = 1; j &lt; sections.length; j++) {
                                if (sections[j].indexOf(&apos;\r\na=end-of-candidates\r\n&apos;) === -1) {
                                    sections[j] += &apos;a=end-of-candidates\r\n&apos;;
                                }
                            }
                        } else {
                            sections[event.candidate.sdpMLineIndex + 1] +=
                                &apos;a=&apos; + event.candidate.candidate + &apos;\r\n&apos;;
                        }
                        self.localDescription.sdp = sections.join(&apos;&apos;);
                        self.dispatchEvent(event);
                        if (self.onicecandidate !== null) {
                            self.onicecandidate(event);
                        }
                        if (!event.candidate &amp;&amp; self.iceGatheringState !== &apos;complete&apos;) {
                            var complete = self.transceivers.every(function(transceiver) {
                                return transceiver.iceGatherer &amp;&amp;
                                    transceiver.iceGatherer.state === &apos;completed&apos;;
                            });
                            if (complete &amp;&amp; self.iceGatheringStateChange !== &apos;complete&apos;) {
                                self.iceGatheringState = &apos;complete&apos;;
                                self._emitGatheringStateChange();
                            }
                        }
                    });
                    this._localIceCandidatesBuffer = [];
                };

                RTCPeerConnection.prototype.getConfiguration = function() {
                    return this._config;
                };

                // internal helper to create a transceiver object.
                // (whih is not yet the same as the WebRTC 1.0 transceiver)
                RTCPeerConnection.prototype._createTransceiver = function(kind) {
                    var hasBundleTransport = this.transceivers.length &gt; 0;
                    var transceiver = {
                        track: null,
                        iceGatherer: null,
                        iceTransport: null,
                        dtlsTransport: null,
                        localCapabilities: null,
                        remoteCapabilities: null,
                        rtpSender: null,
                        rtpReceiver: null,
                        kind: kind,
                        mid: null,
                        sendEncodingParameters: null,
                        recvEncodingParameters: null,
                        stream: null,
                        wantReceive: true
                    };
                    if (this.usingBundle &amp;&amp; hasBundleTransport) {
                        transceiver.iceTransport = this.transceivers[0].iceTransport;
                        transceiver.dtlsTransport = this.transceivers[0].dtlsTransport;
                    } else {
                        var transports = this._createIceAndDtlsTransports();
                        transceiver.iceTransport = transports.iceTransport;
                        transceiver.dtlsTransport = transports.dtlsTransport;
                    }
                    this.transceivers.push(transceiver);
                    return transceiver;
                };

                RTCPeerConnection.prototype.addTrack = function(track, stream) {
                    var transceiver;
                    for (var i = 0; i &lt; this.transceivers.length; i++) {
                        if (!this.transceivers[i].track &amp;&amp;
                            this.transceivers[i].kind === track.kind) {
                            transceiver = this.transceivers[i];
                        }
                    }
                    if (!transceiver) {
                        transceiver = this._createTransceiver(track.kind);
                    }

                    transceiver.track = track;
                    transceiver.stream = stream;
                    transceiver.rtpSender = new window.RTCRtpSender(track,
                        transceiver.dtlsTransport);

                    this._maybeFireNegotiationNeeded();
                    return transceiver.rtpSender;
                };

                RTCPeerConnection.prototype.addStream = function(stream) {
                    var self = this;
                    if (edgeVersion &gt;= 15025) {
                        this.localStreams.push(stream);
                        stream.getTracks().forEach(function(track) {
                            self.addTrack(track, stream);
                        });
                    } else {
                        // Clone is necessary for local demos mostly, attaching directly
                        // to two different senders does not work (build 10547).
                        // Fixed in 15025 (or earlier)
                        var clonedStream = stream.clone();
                        stream.getTracks().forEach(function(track, idx) {
                            var clonedTrack = clonedStream.getTracks()[idx];
                            track.addEventListener(&apos;enabled&apos;, function(event) {
                                clonedTrack.enabled = event.enabled;
                            });
                        });
                        clonedStream.getTracks().forEach(function(track) {
                            self.addTrack(track, clonedStream);
                        });
                        this.localStreams.push(clonedStream);
                    }
                    this._maybeFireNegotiationNeeded();
                };

                RTCPeerConnection.prototype.removeStream = function(stream) {
                    var idx = this.localStreams.indexOf(stream);
                    if (idx &gt; -1) {
                        this.localStreams.splice(idx, 1);
                        this._maybeFireNegotiationNeeded();
                    }
                };

                RTCPeerConnection.prototype.getSenders = function() {
                    return this.transceivers.filter(function(transceiver) {
                            return !!transceiver.rtpSender;
                        })
                        .map(function(transceiver) {
                            return transceiver.rtpSender;
                        });
                };

                RTCPeerConnection.prototype.getReceivers = function() {
                    return this.transceivers.filter(function(transceiver) {
                            return !!transceiver.rtpReceiver;
                        })
                        .map(function(transceiver) {
                            return transceiver.rtpReceiver;
                        });
                };

                // Create ICE gatherer and hook it up.
                RTCPeerConnection.prototype._createIceGatherer = function(mid,
                    sdpMLineIndex) {
                    var self = this;
                    var iceGatherer = new window.RTCIceGatherer(self.iceOptions);
                    iceGatherer.onlocalcandidate = function(evt) {
                        var event = new Event(&apos;icecandidate&apos;);
                        event.candidate = {
                            sdpMid: mid,
                            sdpMLineIndex: sdpMLineIndex
                        };

                        var cand = evt.candidate;
                        var end = !cand || Object.keys(cand).length === 0;
                        // Edge emits an empty object for RTCIceCandidateComplete&#x2025;
                        if (end) {
                            // polyfill since RTCIceGatherer.state is not implemented in
                            // Edge 10547 yet.
                            if (iceGatherer.state === undefined) {
                                iceGatherer.state = &apos;completed&apos;;
                            }
                        } else {
                            // RTCIceCandidate doesn&apos;t have a component, needs to be added
                            cand.component = 1;
                            event.candidate.candidate = SDPUtils.writeCandidate(cand);
                        }

                        // update local description.
                        var sections = SDPUtils.splitSections(self.localDescription.sdp);
                        if (!end) {
                            sections[event.candidate.sdpMLineIndex + 1] +=
                                &apos;a=&apos; + event.candidate.candidate + &apos;\r\n&apos;;
                        } else {
                            sections[event.candidate.sdpMLineIndex + 1] +=
                                &apos;a=end-of-candidates\r\n&apos;;
                        }
                        self.localDescription.sdp = sections.join(&apos;&apos;);
                        var transceivers = self._pendingOffer ? self._pendingOffer :
                            self.transceivers;
                        var complete = transceivers.every(function(transceiver) {
                            return transceiver.iceGatherer &amp;&amp;
                                transceiver.iceGatherer.state === &apos;completed&apos;;
                        });

                        // Emit candidate if localDescription is set.
                        // Also emits null candidate when all gatherers are complete.
                        switch (self.iceGatheringState) {
                            case &apos;new&apos;:
                                if (!end) {
                                    self._localIceCandidatesBuffer.push(event);
                                }
                                if (end &amp;&amp; complete) {
                                    self._localIceCandidatesBuffer.push(
                                        new Event(&apos;icecandidate&apos;));
                                }
                                break;
                            case &apos;gathering&apos;:
                                self._emitBufferedCandidates();
                                if (!end) {
                                    self.dispatchEvent(event);
                                    if (self.onicecandidate !== null) {
                                        self.onicecandidate(event);
                                    }
                                }
                                if (complete) {
                                    self.dispatchEvent(new Event(&apos;icecandidate&apos;));
                                    if (self.onicecandidate !== null) {
                                        self.onicecandidate(new Event(&apos;icecandidate&apos;));
                                    }
                                    self.iceGatheringState = &apos;complete&apos;;
                                    self._emitGatheringStateChange();
                                }
                                break;
                            case &apos;complete&apos;:
                                // should not happen... currently!
                                break;
                            default: // no-op.
                                break;
                        }
                    };
                    return iceGatherer;
                };

                // Create ICE transport and DTLS transport.
                RTCPeerConnection.prototype._createIceAndDtlsTransports = function() {
                    var self = this;
                    var iceTransport = new window.RTCIceTransport(null);
                    iceTransport.onicestatechange = function() {
                        self._updateConnectionState();
                    };

                    var dtlsTransport = new window.RTCDtlsTransport(iceTransport);
                    dtlsTransport.ondtlsstatechange = function() {
                        self._updateConnectionState();
                    };
                    dtlsTransport.onerror = function() {
                        // onerror does not set state to failed by itself.
                        Object.defineProperty(dtlsTransport, &apos;state&apos;, {
                            value: &apos;failed&apos;,
                            writable: true
                        });
                        self._updateConnectionState();
                    };

                    return {
                        iceTransport: iceTransport,
                        dtlsTransport: dtlsTransport
                    };
                };

                // Destroy ICE gatherer, ICE transport and DTLS transport.
                // Without triggering the callbacks.
                RTCPeerConnection.prototype._disposeIceAndDtlsTransports = function(
                    sdpMLineIndex) {
                    var iceGatherer = this.transceivers[sdpMLineIndex].iceGatherer;
                    if (iceGatherer) {
                        delete iceGatherer.onlocalcandidate;
                        delete this.transceivers[sdpMLineIndex].iceGatherer;
                    }
                    var iceTransport = this.transceivers[sdpMLineIndex].iceTransport;
                    if (iceTransport) {
                        delete iceTransport.onicestatechange;
                        delete this.transceivers[sdpMLineIndex].iceTransport;
                    }
                    var dtlsTransport = this.transceivers[sdpMLineIndex].dtlsTransport;
                    if (dtlsTransport) {
                        delete dtlsTransport.ondtlsstatechange;
                        delete dtlsTransport.onerror;
                        delete this.transceivers[sdpMLineIndex].dtlsTransport;
                    }
                };

                // Start the RTP Sender and Receiver for a transceiver.
                RTCPeerConnection.prototype._transceive = function(transceiver,
                    send, recv) {
                    var params = getCommonCapabilities(transceiver.localCapabilities,
                        transceiver.remoteCapabilities);
                    if (send &amp;&amp; transceiver.rtpSender) {
                        params.encodings = transceiver.sendEncodingParameters;
                        params.rtcp = {
                            cname: SDPUtils.localCName,
                            compound: transceiver.rtcpParameters.compound
                        };
                        if (transceiver.recvEncodingParameters.length) {
                            params.rtcp.ssrc = transceiver.recvEncodingParameters[0].ssrc;
                        }
                        transceiver.rtpSender.send(params);
                    }
                    if (recv &amp;&amp; transceiver.rtpReceiver) {
                        // remove RTX field in Edge 14942
                        if (transceiver.kind === &apos;video&apos; &amp;&amp;
                            transceiver.recvEncodingParameters &amp;&amp;
                            edgeVersion &lt; 15019) {
                            transceiver.recvEncodingParameters.forEach(function(p) {
                                delete p.rtx;
                            });
                        }
                        params.encodings = transceiver.recvEncodingParameters;
                        params.rtcp = {
                            cname: transceiver.rtcpParameters.cname,
                            compound: transceiver.rtcpParameters.compound
                        };
                        if (transceiver.sendEncodingParameters.length) {
                            params.rtcp.ssrc = transceiver.sendEncodingParameters[0].ssrc;
                        }
                        transceiver.rtpReceiver.receive(params);
                    }
                };

                RTCPeerConnection.prototype.setLocalDescription = function(description) {
                    var self = this;

                    if (!isActionAllowedInSignalingState(&apos;setLocalDescription&apos;,
                            description.type, this.signalingState)) {
                        var e = new Error(&apos;Can not set local &apos; + description.type +
                            &apos; in state &apos; + this.signalingState);
                        e.name = &apos;InvalidStateError&apos;;
                        if (arguments.length &gt; 2 &amp;&amp; typeof arguments[2] === &apos;function&apos;) {
                            window.setTimeout(arguments[2], 0, e);
                        }
                        return Promise.reject(e);
                    }

                    var sections;
                    var sessionpart;
                    if (description.type === &apos;offer&apos;) {
                        // FIXME: What was the purpose of this empty if statement?
                        // if (!this._pendingOffer) {
                        // } else {
                        if (this._pendingOffer) {
                            // VERY limited support for SDP munging. Limited to:
                            // * changing the order of codecs
                            sections = SDPUtils.splitSections(description.sdp);
                            sessionpart = sections.shift();
                            sections.forEach(function(mediaSection, sdpMLineIndex) {
                                var caps = SDPUtils.parseRtpParameters(mediaSection);
                                self._pendingOffer[sdpMLineIndex].localCapabilities = caps;
                            });
                            this.transceivers = this._pendingOffer;
                            delete this._pendingOffer;
                        }
                    } else if (description.type === &apos;answer&apos;) {
                        sections = SDPUtils.splitSections(self.remoteDescription.sdp);
                        sessionpart = sections.shift();
                        var isIceLite = SDPUtils.matchPrefix(sessionpart,
                            &apos;a=ice-lite&apos;).length &gt; 0;
                        sections.forEach(function(mediaSection, sdpMLineIndex) {
                            var transceiver = self.transceivers[sdpMLineIndex];
                            var iceGatherer = transceiver.iceGatherer;
                            var iceTransport = transceiver.iceTransport;
                            var dtlsTransport = transceiver.dtlsTransport;
                            var localCapabilities = transceiver.localCapabilities;
                            var remoteCapabilities = transceiver.remoteCapabilities;

                            var rejected = SDPUtils.isRejected(mediaSection);

                            if (!rejected &amp;&amp; !transceiver.isDatachannel) {
                                var remoteIceParameters = SDPUtils.getIceParameters(
                                    mediaSection, sessionpart);
                                var remoteDtlsParameters = SDPUtils.getDtlsParameters(
                                    mediaSection, sessionpart);
                                if (isIceLite) {
                                    remoteDtlsParameters.role = &apos;server&apos;;
                                }

                                if (!self.usingBundle || sdpMLineIndex === 0) {
                                    iceTransport.start(iceGatherer, remoteIceParameters,
                                        isIceLite ? &apos;controlling&apos; : &apos;controlled&apos;);
                                    dtlsTransport.start(remoteDtlsParameters);
                                }

                                // Calculate intersection of capabilities.
                                var params = getCommonCapabilities(localCapabilities,
                                    remoteCapabilities);

                                // Start the RTCRtpSender. The RTCRtpReceiver for this
                                // transceiver has already been started in setRemoteDescription.
                                self._transceive(transceiver,
                                    params.codecs.length &gt; 0,
                                    false);
                            }
                        });
                    }

                    this.localDescription = {
                        type: description.type,
                        sdp: description.sdp
                    };
                    switch (description.type) {
                        case &apos;offer&apos;:
                            this._updateSignalingState(&apos;have-local-offer&apos;);
                            break;
                        case &apos;answer&apos;:
                            this._updateSignalingState(&apos;stable&apos;);
                            break;
                        default:
                            throw new TypeError(&apos;unsupported type &quot;&apos; + description.type +
                                &apos;&quot;&apos;);
                    }

                    // If a success callback was provided, emit ICE candidates after it
                    // has been executed. Otherwise, emit callback after the Promise is
                    // resolved.
                    var hasCallback = arguments.length &gt; 1 &amp;&amp;
                        typeof arguments[1] === &apos;function&apos;;
                    if (hasCallback) {
                        var cb = arguments[1];
                        window.setTimeout(function() {
                            cb();
                            if (self.iceGatheringState === &apos;new&apos;) {
                                self.iceGatheringState = &apos;gathering&apos;;
                                self._emitGatheringStateChange();
                            }
                            self._emitBufferedCandidates();
                        }, 0);
                    }
                    var p = Promise.resolve();
                    p.then(function() {
                        if (!hasCallback) {
                            if (self.iceGatheringState === &apos;new&apos;) {
                                self.iceGatheringState = &apos;gathering&apos;;
                                self._emitGatheringStateChange();
                            }
                            // Usually candidates will be emitted earlier.
                            window.setTimeout(self._emitBufferedCandidates.bind(self), 500);
                        }
                    });
                    return p;
                };

                RTCPeerConnection.prototype.setRemoteDescription = function(description) {
                    var self = this;

                    if (!isActionAllowedInSignalingState(&apos;setRemoteDescription&apos;,
                            description.type, this.signalingState)) {
                        var e = new Error(&apos;Can not set remote &apos; + description.type +
                            &apos; in state &apos; + this.signalingState);
                        e.name = &apos;InvalidStateError&apos;;
                        if (arguments.length &gt; 2 &amp;&amp; typeof arguments[2] === &apos;function&apos;) {
                            window.setTimeout(arguments[2], 0, e);
                        }
                        return Promise.reject(e);
                    }

                    var streams = {};
                    var receiverList = [];
                    var sections = SDPUtils.splitSections(description.sdp);
                    var sessionpart = sections.shift();
                    var isIceLite = SDPUtils.matchPrefix(sessionpart,
                        &apos;a=ice-lite&apos;).length &gt; 0;
                    var usingBundle = SDPUtils.matchPrefix(sessionpart,
                        &apos;a=group:BUNDLE &apos;).length &gt; 0;
                    this.usingBundle = usingBundle;
                    var iceOptions = SDPUtils.matchPrefix(sessionpart,
                        &apos;a=ice-options:&apos;)[0];
                    if (iceOptions) {
                        this.canTrickleIceCandidates = iceOptions.substr(14).split(&apos; &apos;)
                            .indexOf(&apos;trickle&apos;) &gt;= 0;
                    } else {
                        this.canTrickleIceCandidates = false;
                    }

                    sections.forEach(function(mediaSection, sdpMLineIndex) {
                        var lines = SDPUtils.splitLines(mediaSection);
                        var kind = SDPUtils.getKind(mediaSection);
                        var rejected = SDPUtils.isRejected(mediaSection);
                        var protocol = lines[0].substr(2).split(&apos; &apos;)[2];

                        var direction = SDPUtils.getDirection(mediaSection, sessionpart);
                        var remoteMsid = SDPUtils.parseMsid(mediaSection);

                        var mid = SDPUtils.getMid(mediaSection) || SDPUtils.generateIdentifier();

                        // Reject datachannels which are not implemented yet.
                        if (kind === &apos;application&apos; &amp;&amp; protocol === &apos;DTLS/SCTP&apos;) {
                            self.transceivers[sdpMLineIndex] = {
                                mid: mid,
                                isDatachannel: true
                            };
                            return;
                        }

                        var transceiver;
                        var iceGatherer;
                        var iceTransport;
                        var dtlsTransport;
                        var rtpReceiver;
                        var sendEncodingParameters;
                        var recvEncodingParameters;
                        var localCapabilities;

                        var track;
                        // FIXME: ensure the mediaSection has rtcp-mux set.
                        var remoteCapabilities = SDPUtils.parseRtpParameters(mediaSection);
                        var remoteIceParameters;
                        var remoteDtlsParameters;
                        if (!rejected) {
                            remoteIceParameters = SDPUtils.getIceParameters(mediaSection,
                                sessionpart);
                            remoteDtlsParameters = SDPUtils.getDtlsParameters(mediaSection,
                                sessionpart);
                            remoteDtlsParameters.role = &apos;client&apos;;
                        }
                        recvEncodingParameters =
                            SDPUtils.parseRtpEncodingParameters(mediaSection);

                        var rtcpParameters = SDPUtils.parseRtcpParameters(mediaSection);

                        var isComplete = SDPUtils.matchPrefix(mediaSection,
                            &apos;a=end-of-candidates&apos;, sessionpart).length &gt; 0;
                        var cands = SDPUtils.matchPrefix(mediaSection, &apos;a=candidate:&apos;)
                            .map(function(cand) {
                                return SDPUtils.parseCandidate(cand);
                            })
                            .filter(function(cand) {
                                return cand.component === &apos;1&apos; || cand.component === 1;
                            });

                        // Check if we can use BUNDLE and dispose transports.
                        if ((description.type === &apos;offer&apos; || description.type === &apos;answer&apos;) &amp;&amp;
                            !rejected &amp;&amp; usingBundle &amp;&amp; sdpMLineIndex &gt; 0 &amp;&amp;
                            self.transceivers[sdpMLineIndex]) {
                            self._disposeIceAndDtlsTransports(sdpMLineIndex);
                            self.transceivers[sdpMLineIndex].iceGatherer =
                                self.transceivers[0].iceGatherer;
                            self.transceivers[sdpMLineIndex].iceTransport =
                                self.transceivers[0].iceTransport;
                            self.transceivers[sdpMLineIndex].dtlsTransport =
                                self.transceivers[0].dtlsTransport;
                            if (self.transceivers[sdpMLineIndex].rtpSender) {
                                self.transceivers[sdpMLineIndex].rtpSender.setTransport(
                                    self.transceivers[0].dtlsTransport);
                            }
                            if (self.transceivers[sdpMLineIndex].rtpReceiver) {
                                self.transceivers[sdpMLineIndex].rtpReceiver.setTransport(
                                    self.transceivers[0].dtlsTransport);
                            }
                        }
                        if (description.type === &apos;offer&apos; &amp;&amp; !rejected) {
                            transceiver = self.transceivers[sdpMLineIndex] ||
                                self._createTransceiver(kind);
                            transceiver.mid = mid;

                            if (!transceiver.iceGatherer) {
                                transceiver.iceGatherer = usingBundle &amp;&amp; sdpMLineIndex &gt; 0 ?
                                    self.transceivers[0].iceGatherer :
                                    self._createIceGatherer(mid, sdpMLineIndex);
                            }

                            if (isComplete &amp;&amp; cands.length &amp;&amp;
                                (!usingBundle || sdpMLineIndex === 0)) {
                                transceiver.iceTransport.setRemoteCandidates(cands);
                            }

                            localCapabilities = window.RTCRtpReceiver.getCapabilities(kind);

                            // filter RTX until additional stuff needed for RTX is implemented
                            // in adapter.js
                            if (edgeVersion &lt; 15019) {
                                localCapabilities.codecs = localCapabilities.codecs.filter(
                                    function(codec) {
                                        return codec.name !== &apos;rtx&apos;;
                                    });
                            }

                            sendEncodingParameters = [{
                                ssrc: (2 * sdpMLineIndex + 2) * 1001
                            }];

                            if (direction === &apos;sendrecv&apos; || direction === &apos;sendonly&apos;) {
                                rtpReceiver = new window.RTCRtpReceiver(transceiver.dtlsTransport,
                                    kind);

                                track = rtpReceiver.track;
                                // FIXME: does not work with Plan B.
                                if (remoteMsid) {
                                    if (!streams[remoteMsid.stream]) {
                                        streams[remoteMsid.stream] = new window.MediaStream();
                                        Object.defineProperty(streams[remoteMsid.stream], &apos;id&apos;, {
                                            get: function() {
                                                return remoteMsid.stream;
                                            }
                                        });
                                    }
                                    Object.defineProperty(track, &apos;id&apos;, {
                                        get: function() {
                                            return remoteMsid.track;
                                        }
                                    });
                                    streams[remoteMsid.stream].addTrack(track);
                                    receiverList.push([track, rtpReceiver,
                                        streams[remoteMsid.stream]
                                    ]);
                                } else {
                                    if (!streams.default) {
                                        streams.default = new window.MediaStream();
                                    }
                                    streams.default.addTrack(track);
                                    receiverList.push([track, rtpReceiver, streams.default]);
                                }
                            }

                            transceiver.localCapabilities = localCapabilities;
                            transceiver.remoteCapabilities = remoteCapabilities;
                            transceiver.rtpReceiver = rtpReceiver;
                            transceiver.rtcpParameters = rtcpParameters;
                            transceiver.sendEncodingParameters = sendEncodingParameters;
                            transceiver.recvEncodingParameters = recvEncodingParameters;

                            // Start the RTCRtpReceiver now. The RTPSender is started in
                            // setLocalDescription.
                            self._transceive(self.transceivers[sdpMLineIndex],
                                false,
                                direction === &apos;sendrecv&apos; || direction === &apos;sendonly&apos;);
                        } else if (description.type === &apos;answer&apos; &amp;&amp; !rejected) {
                            transceiver = self.transceivers[sdpMLineIndex];
                            iceGatherer = transceiver.iceGatherer;
                            iceTransport = transceiver.iceTransport;
                            dtlsTransport = transceiver.dtlsTransport;
                            rtpReceiver = transceiver.rtpReceiver;
                            sendEncodingParameters = transceiver.sendEncodingParameters;
                            localCapabilities = transceiver.localCapabilities;

                            self.transceivers[sdpMLineIndex].recvEncodingParameters =
                                recvEncodingParameters;
                            self.transceivers[sdpMLineIndex].remoteCapabilities =
                                remoteCapabilities;
                            self.transceivers[sdpMLineIndex].rtcpParameters = rtcpParameters;

                            if (!usingBundle || sdpMLineIndex === 0) {
                                if ((isIceLite || isComplete) &amp;&amp; cands.length) {
                                    iceTransport.setRemoteCandidates(cands);
                                }
                                iceTransport.start(iceGatherer, remoteIceParameters,
                                    &apos;controlling&apos;);
                                dtlsTransport.start(remoteDtlsParameters);
                            }

                            self._transceive(transceiver,
                                direction === &apos;sendrecv&apos; || direction === &apos;recvonly&apos;,
                                direction === &apos;sendrecv&apos; || direction === &apos;sendonly&apos;);

                            if (rtpReceiver &amp;&amp;
                                (direction === &apos;sendrecv&apos; || direction === &apos;sendonly&apos;)) {
                                track = rtpReceiver.track;
                                if (remoteMsid) {
                                    if (!streams[remoteMsid.stream]) {
                                        streams[remoteMsid.stream] = new window.MediaStream();
                                    }
                                    streams[remoteMsid.stream].addTrack(track);
                                    receiverList.push([track, rtpReceiver, streams[remoteMsid.stream]]);
                                } else {
                                    if (!streams.default) {
                                        streams.default = new window.MediaStream();
                                    }
                                    streams.default.addTrack(track);
                                    receiverList.push([track, rtpReceiver, streams.default]);
                                }
                            } else {
                                // FIXME: actually the receiver should be created later.
                                delete transceiver.rtpReceiver;
                            }
                        }
                    });

                    this.remoteDescription = {
                        type: description.type,
                        sdp: description.sdp
                    };
                    switch (description.type) {
                        case &apos;offer&apos;:
                            this._updateSignalingState(&apos;have-remote-offer&apos;);
                            break;
                        case &apos;answer&apos;:
                            this._updateSignalingState(&apos;stable&apos;);
                            break;
                        default:
                            throw new TypeError(&apos;unsupported type &quot;&apos; + description.type +
                                &apos;&quot;&apos;);
                    }
                    Object.keys(streams).forEach(function(sid) {
                        var stream = streams[sid];
                        if (stream.getTracks().length) {
                            self.remoteStreams.push(stream);
                            var event = new Event(&apos;addstream&apos;);
                            event.stream = stream;
                            self.dispatchEvent(event);
                            if (self.onaddstream !== null) {
                                window.setTimeout(function() {
                                    self.onaddstream(event);
                                }, 0);
                            }

                            receiverList.forEach(function(item) {
                                var track = item[0];
                                var receiver = item[1];
                                if (stream.id !== item[2].id) {
                                    return;
                                }
                                var trackEvent = new Event(&apos;track&apos;);
                                trackEvent.track = track;
                                trackEvent.receiver = receiver;
                                trackEvent.streams = [stream];
                                self.dispatchEvent(trackEvent);
                                if (self.ontrack !== null) {
                                    window.setTimeout(function() {
                                        self.ontrack(trackEvent);
                                    }, 0);
                                }
                            });
                        }
                    });

                    // check whether addIceCandidate({}) was called within four seconds after
                    // setRemoteDescription.
                    window.setTimeout(function() {
                        if (!(self &amp;&amp; self.transceivers)) {
                            return;
                        }
                        self.transceivers.forEach(function(transceiver) {
                            if (transceiver.iceTransport &amp;&amp;
                                transceiver.iceTransport.state === &apos;new&apos; &amp;&amp;
                                transceiver.iceTransport.getRemoteCandidates().length &gt; 0) {
                                console.warn(&apos;Timeout for addRemoteCandidate. Consider sending &apos; +
                                    &apos;an end-of-candidates notification&apos;);
                                transceiver.iceTransport.addRemoteCandidate({});
                            }
                        });
                    }, 4000);

                    if (arguments.length &gt; 1 &amp;&amp; typeof arguments[1] === &apos;function&apos;) {
                        window.setTimeout(arguments[1], 0);
                    }
                    return Promise.resolve();
                };

                RTCPeerConnection.prototype.close = function() {
                    this.transceivers.forEach(function(transceiver) {
                        /* not yet
                        if (transceiver.iceGatherer) {
                          transceiver.iceGatherer.close();
                        }
                        */
                        if (transceiver.iceTransport) {
                            transceiver.iceTransport.stop();
                        }
                        if (transceiver.dtlsTransport) {
                            transceiver.dtlsTransport.stop();
                        }
                        if (transceiver.rtpSender) {
                            transceiver.rtpSender.stop();
                        }
                        if (transceiver.rtpReceiver) {
                            transceiver.rtpReceiver.stop();
                        }
                    });
                    // FIXME: clean up tracks, local streams, remote streams, etc
                    this._updateSignalingState(&apos;closed&apos;);
                };

                // Update the signaling state.
                RTCPeerConnection.prototype._updateSignalingState = function(newState) {
                    this.signalingState = newState;
                    var event = new Event(&apos;signalingstatechange&apos;);
                    this.dispatchEvent(event);
                    if (this.onsignalingstatechange !== null) {
                        this.onsignalingstatechange(event);
                    }
                };

                // Determine whether to fire the negotiationneeded event.
                RTCPeerConnection.prototype._maybeFireNegotiationNeeded = function() {
                    var self = this;
                    if (this.signalingState !== &apos;stable&apos; || this.needNegotiation === true) {
                        return;
                    }
                    this.needNegotiation = true;
                    window.setTimeout(function() {
                        if (self.needNegotiation === false) {
                            return;
                        }
                        self.needNegotiation = false;
                        var event = new Event(&apos;negotiationneeded&apos;);
                        self.dispatchEvent(event);
                        if (self.onnegotiationneeded !== null) {
                            self.onnegotiationneeded(event);
                        }
                    }, 0);
                };

                // Update the connection state.
                RTCPeerConnection.prototype._updateConnectionState = function() {
                    var self = this;
                    var newState;
                    var states = {
                        &apos;new&apos;: 0,
                        closed: 0,
                        connecting: 0,
                        checking: 0,
                        connected: 0,
                        completed: 0,
                        disconnected: 0,
                        failed: 0
                    };
                    this.transceivers.forEach(function(transceiver) {
                        states[transceiver.iceTransport.state]++;
                        states[transceiver.dtlsTransport.state]++;
                    });
                    // ICETransport.completed and connected are the same for this purpose.
                    states.connected += states.completed;

                    newState = &apos;new&apos;;
                    if (states.failed &gt; 0) {
                        newState = &apos;failed&apos;;
                    } else if (states.connecting &gt; 0 || states.checking &gt; 0) {
                        newState = &apos;connecting&apos;;
                    } else if (states.disconnected &gt; 0) {
                        newState = &apos;disconnected&apos;;
                    } else if (states.new &gt; 0) {
                        newState = &apos;new&apos;;
                    } else if (states.connected &gt; 0 || states.completed &gt; 0) {
                        newState = &apos;connected&apos;;
                    }

                    if (newState !== self.iceConnectionState) {
                        self.iceConnectionState = newState;
                        var event = new Event(&apos;iceconnectionstatechange&apos;);
                        this.dispatchEvent(event);
                        if (this.oniceconnectionstatechange !== null) {
                            this.oniceconnectionstatechange(event);
                        }
                    }
                };

                RTCPeerConnection.prototype.createOffer = function() {
                    var self = this;
                    if (this._pendingOffer) {
                        throw new Error(&apos;createOffer called while there is a pending offer.&apos;);
                    }
                    var offerOptions;
                    if (arguments.length === 1 &amp;&amp; typeof arguments[0] !== &apos;function&apos;) {
                        offerOptions = arguments[0];
                    } else if (arguments.length === 3) {
                        offerOptions = arguments[2];
                    }

                    var numAudioTracks = this.transceivers.filter(function(t) {
                        return t.kind === &apos;audio&apos;;
                    }).length;
                    var numVideoTracks = this.transceivers.filter(function(t) {
                        return t.kind === &apos;video&apos;;
                    }).length;

                    // Determine number of audio and video tracks we need to send/recv.
                    if (offerOptions) {
                        // Reject Chrome legacy constraints.
                        if (offerOptions.mandatory || offerOptions.optional) {
                            throw new TypeError(
                                &apos;Legacy mandatory/optional constraints not supported.&apos;);
                        }
                        if (offerOptions.offerToReceiveAudio !== undefined) {
                            if (offerOptions.offerToReceiveAudio === true) {
                                numAudioTracks = 1;
                            } else if (offerOptions.offerToReceiveAudio === false) {
                                numAudioTracks = 0;
                            } else {
                                numAudioTracks = offerOptions.offerToReceiveAudio;
                            }
                        }
                        if (offerOptions.offerToReceiveVideo !== undefined) {
                            if (offerOptions.offerToReceiveVideo === true) {
                                numVideoTracks = 1;
                            } else if (offerOptions.offerToReceiveVideo === false) {
                                numVideoTracks = 0;
                            } else {
                                numVideoTracks = offerOptions.offerToReceiveVideo;
                            }
                        }
                    }

                    this.transceivers.forEach(function(transceiver) {
                        if (transceiver.kind === &apos;audio&apos;) {
                            numAudioTracks--;
                            if (numAudioTracks &lt; 0) {
                                transceiver.wantReceive = false;
                            }
                        } else if (transceiver.kind === &apos;video&apos;) {
                            numVideoTracks--;
                            if (numVideoTracks &lt; 0) {
                                transceiver.wantReceive = false;
                            }
                        }
                    });

                    // Create M-lines for recvonly streams.
                    while (numAudioTracks &gt; 0 || numVideoTracks &gt; 0) {
                        if (numAudioTracks &gt; 0) {
                            this._createTransceiver(&apos;audio&apos;);
                            numAudioTracks--;
                        }
                        if (numVideoTracks &gt; 0) {
                            this._createTransceiver(&apos;video&apos;);
                            numVideoTracks--;
                        }
                    }
                    // reorder tracks
                    var transceivers = sortTracks(this.transceivers);

                    var sdp = SDPUtils.writeSessionBoilerplate(this._sdpSessionId);
                    transceivers.forEach(function(transceiver, sdpMLineIndex) {
                        // For each track, create an ice gatherer, ice transport,
                        // dtls transport, potentially rtpsender and rtpreceiver.
                        var track = transceiver.track;
                        var kind = transceiver.kind;
                        var mid = SDPUtils.generateIdentifier();
                        transceiver.mid = mid;

                        if (!transceiver.iceGatherer) {
                            transceiver.iceGatherer = self.usingBundle &amp;&amp; sdpMLineIndex &gt; 0 ?
                                transceivers[0].iceGatherer :
                                self._createIceGatherer(mid, sdpMLineIndex);
                        }

                        var localCapabilities = window.RTCRtpSender.getCapabilities(kind);
                        // filter RTX until additional stuff needed for RTX is implemented
                        // in adapter.js
                        if (edgeVersion &lt; 15019) {
                            localCapabilities.codecs = localCapabilities.codecs.filter(
                                function(codec) {
                                    return codec.name !== &apos;rtx&apos;;
                                });
                        }
                        localCapabilities.codecs.forEach(function(codec) {
                            // work around https://bugs.chromium.org/p/webrtc/issues/detail?id=6552
                            // by adding level-asymmetry-allowed=1
                            if (codec.name === &apos;H264&apos; &amp;&amp;
                                codec.parameters[&apos;level-asymmetry-allowed&apos;] === undefined) {
                                codec.parameters[&apos;level-asymmetry-allowed&apos;] = &apos;1&apos;;
                            }
                        });

                        // generate an ssrc now, to be used later in rtpSender.send
                        var sendEncodingParameters = [{
                            ssrc: (2 * sdpMLineIndex + 1) * 1001
                        }];
                        if (track) {
                            // add RTX
                            if (edgeVersion &gt;= 15019 &amp;&amp; kind === &apos;video&apos;) {
                                sendEncodingParameters[0].rtx = {
                                    ssrc: (2 * sdpMLineIndex + 1) * 1001 + 1
                                };
                            }
                        }

                        if (transceiver.wantReceive) {
                            transceiver.rtpReceiver = new window.RTCRtpReceiver(
                                transceiver.dtlsTransport,
                                kind
                            );
                        }

                        transceiver.localCapabilities = localCapabilities;
                        transceiver.sendEncodingParameters = sendEncodingParameters;
                    });

                    // always offer BUNDLE and dispose on return if not supported.
                    if (this._config.bundlePolicy !== &apos;max-compat&apos;) {
                        sdp += &apos;a=group:BUNDLE &apos; + transceivers.map(function(t) {
                            return t.mid;
                        }).join(&apos; &apos;) + &apos;\r\n&apos;;
                    }
                    sdp += &apos;a=ice-options:trickle\r\n&apos;;

                    transceivers.forEach(function(transceiver, sdpMLineIndex) {
                        sdp += SDPUtils.writeMediaSection(transceiver,
                            transceiver.localCapabilities, &apos;offer&apos;, transceiver.stream);
                        sdp += &apos;a=rtcp-rsize\r\n&apos;;
                    });

                    this._pendingOffer = transceivers;
                    var desc = new window.RTCSessionDescription({
                        type: &apos;offer&apos;,
                        sdp: sdp
                    });
                    if (arguments.length &amp;&amp; typeof arguments[0] === &apos;function&apos;) {
                        window.setTimeout(arguments[0], 0, desc);
                    }
                    return Promise.resolve(desc);
                };

                RTCPeerConnection.prototype.createAnswer = function() {
                    var sdp = SDPUtils.writeSessionBoilerplate(this._sdpSessionId);
                    if (this.usingBundle) {
                        sdp += &apos;a=group:BUNDLE &apos; + this.transceivers.map(function(t) {
                            return t.mid;
                        }).join(&apos; &apos;) + &apos;\r\n&apos;;
                    }
                    this.transceivers.forEach(function(transceiver, sdpMLineIndex) {
                        if (transceiver.isDatachannel) {
                            sdp += &apos;m=application 0 DTLS/SCTP 5000\r\n&apos; +
                                &apos;c=IN IP4 0.0.0.0\r\n&apos; +
                                &apos;a=mid:&apos; + transceiver.mid + &apos;\r\n&apos;;
                            return;
                        }

                        // FIXME: look at direction.
                        if (transceiver.stream) {
                            var localTrack;
                            if (transceiver.kind === &apos;audio&apos;) {
                                localTrack = transceiver.stream.getAudioTracks()[0];
                            } else if (transceiver.kind === &apos;video&apos;) {
                                localTrack = transceiver.stream.getVideoTracks()[0];
                            }
                            if (localTrack) {
                                // add RTX
                                if (edgeVersion &gt;= 15019 &amp;&amp; transceiver.kind === &apos;video&apos;) {
                                    transceiver.sendEncodingParameters[0].rtx = {
                                        ssrc: (2 * sdpMLineIndex + 2) * 1001 + 1
                                    };
                                }
                            }
                        }

                        // Calculate intersection of capabilities.
                        var commonCapabilities = getCommonCapabilities(
                            transceiver.localCapabilities,
                            transceiver.remoteCapabilities);

                        var hasRtx = commonCapabilities.codecs.filter(function(c) {
                            return c.name.toLowerCase() === &apos;rtx&apos;;
                        }).length;
                        if (!hasRtx &amp;&amp; transceiver.sendEncodingParameters[0].rtx) {
                            delete transceiver.sendEncodingParameters[0].rtx;
                        }

                        sdp += SDPUtils.writeMediaSection(transceiver, commonCapabilities,
                            &apos;answer&apos;, transceiver.stream);
                        if (transceiver.rtcpParameters &amp;&amp;
                            transceiver.rtcpParameters.reducedSize) {
                            sdp += &apos;a=rtcp-rsize\r\n&apos;;
                        }
                    });

                    var desc = new window.RTCSessionDescription({
                        type: &apos;answer&apos;,
                        sdp: sdp
                    });
                    if (arguments.length &amp;&amp; typeof arguments[0] === &apos;function&apos;) {
                        window.setTimeout(arguments[0], 0, desc);
                    }
                    return Promise.resolve(desc);
                };

                RTCPeerConnection.prototype.addIceCandidate = function(candidate) {
                    if (!candidate) {
                        for (var j = 0; j &lt; this.transceivers.length; j++) {
                            this.transceivers[j].iceTransport.addRemoteCandidate({});
                            if (this.usingBundle) {
                                return Promise.resolve();
                            }
                        }
                    } else {
                        var mLineIndex = candidate.sdpMLineIndex;
                        if (candidate.sdpMid) {
                            for (var i = 0; i &lt; this.transceivers.length; i++) {
                                if (this.transceivers[i].mid === candidate.sdpMid) {
                                    mLineIndex = i;
                                    break;
                                }
                            }
                        }
                        var transceiver = this.transceivers[mLineIndex];
                        if (transceiver) {
                            var cand = Object.keys(candidate.candidate).length &gt; 0 ?
                                SDPUtils.parseCandidate(candidate.candidate) : {};
                            // Ignore Chrome&apos;s invalid candidates since Edge does not like them.
                            if (cand.protocol === &apos;tcp&apos; &amp;&amp; (cand.port === 0 || cand.port === 9)) {
                                return Promise.resolve();
                            }
                            // Ignore RTCP candidates, we assume RTCP-MUX.
                            if (cand.component &amp;&amp;
                                !(cand.component === &apos;1&apos; || cand.component === 1)) {
                                return Promise.resolve();
                            }
                            transceiver.iceTransport.addRemoteCandidate(cand);

                            // update the remoteDescription.
                            var sections = SDPUtils.splitSections(this.remoteDescription.sdp);
                            sections[mLineIndex + 1] += (cand.type ? candidate.candidate.trim() :
                                &apos;a=end-of-candidates&apos;) + &apos;\r\n&apos;;
                            this.remoteDescription.sdp = sections.join(&apos;&apos;);
                        }
                    }
                    if (arguments.length &gt; 1 &amp;&amp; typeof arguments[1] === &apos;function&apos;) {
                        window.setTimeout(arguments[1], 0);
                    }
                    return Promise.resolve();
                };

                RTCPeerConnection.prototype.getStats = function() {
                    var promises = [];
                    this.transceivers.forEach(function(transceiver) {
                        [&apos;rtpSender&apos;, &apos;rtpReceiver&apos;, &apos;iceGatherer&apos;, &apos;iceTransport&apos;,
                            &apos;dtlsTransport&apos;
                        ].forEach(function(method) {
                            if (transceiver[method]) {
                                promises.push(transceiver[method].getStats());
                            }
                        });
                    });
                    var cb = arguments.length &gt; 1 &amp;&amp; typeof arguments[1] === &apos;function&apos; &amp;&amp;
                        arguments[1];
                    var fixStatsType = function(stat) {
                        return {
                            inboundrtp: &apos;inbound-rtp&apos;,
                            outboundrtp: &apos;outbound-rtp&apos;,
                            candidatepair: &apos;candidate-pair&apos;,
                            localcandidate: &apos;local-candidate&apos;,
                            remotecandidate: &apos;remote-candidate&apos;
                        }[stat.type] || stat.type;
                    };
                    return new Promise(function(resolve) {
                        // shim getStats with maplike support
                        var results = new Map();
                        Promise.all(promises).then(function(res) {
                            res.forEach(function(result) {
                                Object.keys(result).forEach(function(id) {
                                    result[id].type = fixStatsType(result[id]);
                                    results.set(id, result[id]);
                                });
                            });
                            if (cb) {
                                window.setTimeout(cb, 0, results);
                            }
                            resolve(results);
                        });
                    });
                };
                return RTCPeerConnection;
            };

        }, {
            &quot;sdp&quot;: 1
        }],
        9: [function(require, module, exports) {
            /*
             *  Copyright (c) 2016 The WebRTC project authors. All Rights Reserved.
             *
             *  Use of this source code is governed by a BSD-style license
             *  that can be found in the LICENSE file in the root of the source
             *  tree.
             */
            /* eslint-env node */
            &apos;use strict&apos;;

            var utils = require(&apos;../utils&apos;);

            var firefoxShim = {
                shimOnTrack: function(window) {
                    if (typeof window === &apos;object&apos; &amp;&amp; window.RTCPeerConnection &amp;&amp; !(&apos;ontrack&apos; in
                            window.RTCPeerConnection.prototype)) {
                        Object.defineProperty(window.RTCPeerConnection.prototype, &apos;ontrack&apos;, {
                            get: function() {
                                return this._ontrack;
                            },
                            set: function(f) {
                                if (this._ontrack) {
                                    this.removeEventListener(&apos;track&apos;, this._ontrack);
                                    this.removeEventListener(&apos;addstream&apos;, this._ontrackpoly);
                                }
                                this.addEventListener(&apos;track&apos;, this._ontrack = f);
                                this.addEventListener(&apos;addstream&apos;, this._ontrackpoly = function(e) {
                                    e.stream.getTracks().forEach(function(track) {
                                        var event = new Event(&apos;track&apos;);
                                        event.track = track;
                                        event.receiver = {
                                            track: track
                                        };
                                        event.streams = [e.stream];
                                        this.dispatchEvent(event);
                                    }.bind(this));
                                }.bind(this));
                            }
                        });
                    }
                },

                shimSourceObject: function(window) {
                    // Firefox has supported mozSrcObject since FF22, unprefixed in 42.
                    if (typeof window === &apos;object&apos;) {
                        if (window.HTMLMediaElement &amp;&amp;
                            !(&apos;srcObject&apos; in window.HTMLMediaElement.prototype)) {
                            // Shim the srcObject property, once, when HTMLMediaElement is found.
                            Object.defineProperty(window.HTMLMediaElement.prototype, &apos;srcObject&apos;, {
                                get: function() {
                                    return this.mozSrcObject;
                                },
                                set: function(stream) {
                                    this.mozSrcObject = stream;
                                }
                            });
                        }
                    }
                },

                shimPeerConnection: function(window) {
                    var browserDetails = utils.detectBrowser(window);

                    if (typeof window !== &apos;object&apos; || !(window.RTCPeerConnection ||
                            window.mozRTCPeerConnection)) {
                        return; // probably media.peerconnection.enabled=false in about:config
                    }
                    // The RTCPeerConnection object.
                    if (!window.RTCPeerConnection) {
                        window.RTCPeerConnection = function(pcConfig, pcConstraints) {
                            if (browserDetails.version &lt; 38) {
                                // .urls is not supported in FF &lt; 38.
                                // create RTCIceServers with a single url.
                                if (pcConfig &amp;&amp; pcConfig.iceServers) {
                                    var newIceServers = [];
                                    for (var i = 0; i &lt; pcConfig.iceServers.length; i++) {
                                        var server = pcConfig.iceServers[i];
                                        if (server.hasOwnProperty(&apos;urls&apos;)) {
                                            for (var j = 0; j &lt; server.urls.length; j++) {
                                                var newServer = {
                                                    url: server.urls[j]
                                                };
                                                if (server.urls[j].indexOf(&apos;turn&apos;) === 0) {
                                                    newServer.username = server.username;
                                                    newServer.credential = server.credential;
                                                }
                                                newIceServers.push(newServer);
                                            }
                                        } else {
                                            newIceServers.push(pcConfig.iceServers[i]);
                                        }
                                    }
                                    pcConfig.iceServers = newIceServers;
                                }
                            }
                            return new window.mozRTCPeerConnection(pcConfig, pcConstraints);
                        };
                        window.RTCPeerConnection.prototype =
                            window.mozRTCPeerConnection.prototype;

                        // wrap static methods. Currently just generateCertificate.
                        if (window.mozRTCPeerConnection.generateCertificate) {
                            Object.defineProperty(window.RTCPeerConnection, &apos;generateCertificate&apos;, {
                                get: function() {
                                    return window.mozRTCPeerConnection.generateCertificate;
                                }
                            });
                        }

                        window.RTCSessionDescription = window.mozRTCSessionDescription;
                        window.RTCIceCandidate = window.mozRTCIceCandidate;
                    }

                    // shim away need for obsolete RTCIceCandidate/RTCSessionDescription.
                    [&apos;setLocalDescription&apos;, &apos;setRemoteDescription&apos;, &apos;addIceCandidate&apos;]
                    .forEach(function(method) {
                        var nativeMethod = window.RTCPeerConnection.prototype[method];
                        window.RTCPeerConnection.prototype[method] = function() {
                            arguments[0] = new((method === &apos;addIceCandidate&apos;) ?
                                window.RTCIceCandidate :
                                window.RTCSessionDescription)(arguments[0]);
                            return nativeMethod.apply(this, arguments);
                        };
                    });

                    // support for addIceCandidate(null or undefined)
                    var nativeAddIceCandidate =
                        window.RTCPeerConnection.prototype.addIceCandidate;
                    window.RTCPeerConnection.prototype.addIceCandidate = function() {
                        if (!arguments[0]) {
                            if (arguments[1]) {
                                arguments[1].apply(null);
                            }
                            return Promise.resolve();
                        }
                        return nativeAddIceCandidate.apply(this, arguments);
                    };

                    // shim getStats with maplike support
                    var makeMapStats = function(stats) {
                        var map = new Map();
                        Object.keys(stats).forEach(function(key) {
                            map.set(key, stats[key]);
                            map[key] = stats[key];
                        });
                        return map;
                    };

                    var modernStatsTypes = {
                        inboundrtp: &apos;inbound-rtp&apos;,
                        outboundrtp: &apos;outbound-rtp&apos;,
                        candidatepair: &apos;candidate-pair&apos;,
                        localcandidate: &apos;local-candidate&apos;,
                        remotecandidate: &apos;remote-candidate&apos;
                    };

                    var nativeGetStats = window.RTCPeerConnection.prototype.getStats;
                    window.RTCPeerConnection.prototype.getStats = function(
                        selector,
                        onSucc,
                        onErr
                    ) {
                        return nativeGetStats.apply(this, [selector || null])
                            .then(function(stats) {
                                if (browserDetails.version &lt; 48) {
                                    stats = makeMapStats(stats);
                                }
                                if (browserDetails.version &lt; 53 &amp;&amp; !onSucc) {
                                    // Shim only promise getStats with spec-hyphens in type names
                                    // Leave callback version alone; misc old uses of forEach before Map
                                    try {
                                        stats.forEach(function(stat) {
                                            stat.type = modernStatsTypes[stat.type] || stat.type;
                                        });
                                    } catch (e) {
                                        if (e.name !== &apos;TypeError&apos;) {
                                            throw e;
                                        }
                                        // Avoid TypeError: &quot;type&quot; is read-only, in old versions. 34-43ish
                                        stats.forEach(function(stat, i) {
                                            stats.set(i, Object.assign({}, stat, {
                                                type: modernStatsTypes[stat.type] || stat.type
                                            }));
                                        });
                                    }
                                }
                                return stats;
                            })
                            .then(onSucc, onErr);
                    };
                }
            };

            // Expose public methods.
            module.exports = {
                shimOnTrack: firefoxShim.shimOnTrack,
                shimSourceObject: firefoxShim.shimSourceObject,
                shimPeerConnection: firefoxShim.shimPeerConnection,
                shimGetUserMedia: require(&apos;./getusermedia&apos;)
            };

        }, {
            &quot;../utils&quot;: 12,
            &quot;./getusermedia&quot;: 10
        }],
        10: [function(require, module, exports) {
            /*
             *  Copyright (c) 2016 The WebRTC project authors. All Rights Reserved.
             *
             *  Use of this source code is governed by a BSD-style license
             *  that can be found in the LICENSE file in the root of the source
             *  tree.
             */
            /* eslint-env node */
            &apos;use strict&apos;;

            var utils = require(&apos;../utils&apos;);
            var logging = utils.log;

            // Expose public methods.
            module.exports = function(window) {
                var browserDetails = utils.detectBrowser(window);
                var navigator = window &amp;&amp; window.navigator;
                var MediaStreamTrack = window &amp;&amp; window.MediaStreamTrack;

                var shimError_ = function(e) {
                    return {
                        name: {
                            InternalError: &apos;NotReadableError&apos;,
                            NotSupportedError: &apos;TypeError&apos;,
                            PermissionDeniedError: &apos;NotAllowedError&apos;,
                            SecurityError: &apos;NotAllowedError&apos;
                        }[e.name] || e.name,
                        message: {
                            &apos;The operation is insecure.&apos;: &apos;The request is not allowed by the &apos; +
                                &apos;user agent or the platform in the current context.&apos;
                        }[e.message] || e.message,
                        constraint: e.constraint,
                        toString: function() {
                            return this.name + (this.message &amp;&amp; &apos;: &apos;) + this.message;
                        }
                    };
                };

                // getUserMedia constraints shim.
                var getUserMedia_ = function(constraints, onSuccess, onError) {
                    var constraintsToFF37_ = function(c) {
                        if (typeof c !== &apos;object&apos; || c.require) {
                            return c;
                        }
                        var require = [];
                        Object.keys(c).forEach(function(key) {
                            if (key === &apos;require&apos; || key === &apos;advanced&apos; || key === &apos;mediaSource&apos;) {
                                return;
                            }
                            var r = c[key] = (typeof c[key] === &apos;object&apos;) ?
                                c[key] : {
                                    ideal: c[key]
                                };
                            if (r.min !== undefined ||
                                r.max !== undefined || r.exact !== undefined) {
                                require.push(key);
                            }
                            if (r.exact !== undefined) {
                                if (typeof r.exact === &apos;number&apos;) {
                                    r.min = r.max = r.exact;
                                } else {
                                    c[key] = r.exact;
                                }
                                delete r.exact;
                            }
                            if (r.ideal !== undefined) {
                                c.advanced = c.advanced || [];
                                var oc = {};
                                if (typeof r.ideal === &apos;number&apos;) {
                                    oc[key] = {
                                        min: r.ideal,
                                        max: r.ideal
                                    };
                                } else {
                                    oc[key] = r.ideal;
                                }
                                c.advanced.push(oc);
                                delete r.ideal;
                                if (!Object.keys(r).length) {
                                    delete c[key];
                                }
                            }
                        });
                        if (require.length) {
                            c.require = require;
                        }
                        return c;
                    };
                    constraints = JSON.parse(JSON.stringify(constraints));
                    if (browserDetails.version &lt; 38) {
                        logging(&apos;spec: &apos; + JSON.stringify(constraints));
                        if (constraints.audio) {
                            constraints.audio = constraintsToFF37_(constraints.audio);
                        }
                        if (constraints.video) {
                            constraints.video = constraintsToFF37_(constraints.video);
                        }
                        logging(&apos;ff37: &apos; + JSON.stringify(constraints));
                    }
                    return navigator.mozGetUserMedia(constraints, onSuccess, function(e) {
                        onError(shimError_(e));
                    });
                };

                // Returns the result of getUserMedia as a Promise.
                var getUserMediaPromise_ = function(constraints) {
                    return new Promise(function(resolve, reject) {
                        getUserMedia_(constraints, resolve, reject);
                    });
                };

                // Shim for mediaDevices on older versions.
                if (!navigator.mediaDevices) {
                    navigator.mediaDevices = {
                        getUserMedia: getUserMediaPromise_,
                        addEventListener: function() {},
                        removeEventListener: function() {}
                    };
                }
                navigator.mediaDevices.enumerateDevices =
                    navigator.mediaDevices.enumerateDevices || function() {
                        return new Promise(function(resolve) {
                            var infos = [{
                                    kind: &apos;audioinput&apos;,
                                    deviceId: &apos;default&apos;,
                                    label: &apos;&apos;,
                                    groupId: &apos;&apos;
                                },
                                {
                                    kind: &apos;videoinput&apos;,
                                    deviceId: &apos;default&apos;,
                                    label: &apos;&apos;,
                                    groupId: &apos;&apos;
                                }
                            ];
                            resolve(infos);
                        });
                    };

                if (browserDetails.version &lt; 41) {
                    // Work around http://bugzil.la/1169665
                    var orgEnumerateDevices =
                        navigator.mediaDevices.enumerateDevices.bind(navigator.mediaDevices);
                    navigator.mediaDevices.enumerateDevices = function() {
                        return orgEnumerateDevices().then(undefined, function(e) {
                            if (e.name === &apos;NotFoundError&apos;) {
                                return [];
                            }
                            throw e;
                        });
                    };
                }
                if (browserDetails.version &lt; 49) {
                    var origGetUserMedia = navigator.mediaDevices.getUserMedia.
                    bind(navigator.mediaDevices);
                    navigator.mediaDevices.getUserMedia = function(c) {
                        return origGetUserMedia(c).then(function(stream) {
                            // Work around https://bugzil.la/802326
                            if (c.audio &amp;&amp; !stream.getAudioTracks().length ||
                                c.video &amp;&amp; !stream.getVideoTracks().length) {
                                stream.getTracks().forEach(function(track) {
                                    track.stop();
                                });
                                throw new DOMException(&apos;The object can not be found here.&apos;,
                                    &apos;NotFoundError&apos;);
                            }
                            return stream;
                        }, function(e) {
                            return Promise.reject(shimError_(e));
                        });
                    };
                }
                if (!(browserDetails.version &gt; 55 &amp;&amp;
                        &apos;autoGainControl&apos; in navigator.mediaDevices.getSupportedConstraints())) {
                    var remap = function(obj, a, b) {
                        if (a in obj &amp;&amp; !(b in obj)) {
                            obj[b] = obj[a];
                            delete obj[a];
                        }
                    };

                    var nativeGetUserMedia = navigator.mediaDevices.getUserMedia.
                    bind(navigator.mediaDevices);
                    navigator.mediaDevices.getUserMedia = function(c) {
                        if (typeof c === &apos;object&apos; &amp;&amp; typeof c.audio === &apos;object&apos;) {
                            c = JSON.parse(JSON.stringify(c));
                            remap(c.audio, &apos;autoGainControl&apos;, &apos;mozAutoGainControl&apos;);
                            remap(c.audio, &apos;noiseSuppression&apos;, &apos;mozNoiseSuppression&apos;);
                        }
                        return nativeGetUserMedia(c);
                    };

                    if (MediaStreamTrack &amp;&amp; MediaStreamTrack.prototype.getSettings) {
                        var nativeGetSettings = MediaStreamTrack.prototype.getSettings;
                        MediaStreamTrack.prototype.getSettings = function() {
                            var obj = nativeGetSettings.apply(this, arguments);
                            remap(obj, &apos;mozAutoGainControl&apos;, &apos;autoGainControl&apos;);
                            remap(obj, &apos;mozNoiseSuppression&apos;, &apos;noiseSuppression&apos;);
                            return obj;
                        };
                    }

                    if (MediaStreamTrack &amp;&amp; MediaStreamTrack.prototype.applyConstraints) {
                        var nativeApplyConstraints = MediaStreamTrack.prototype.applyConstraints;
                        MediaStreamTrack.prototype.applyConstraints = function(c) {
                            if (this.kind === &apos;audio&apos; &amp;&amp; typeof c === &apos;object&apos;) {
                                c = JSON.parse(JSON.stringify(c));
                                remap(c, &apos;autoGainControl&apos;, &apos;mozAutoGainControl&apos;);
                                remap(c, &apos;noiseSuppression&apos;, &apos;mozNoiseSuppression&apos;);
                            }
                            return nativeApplyConstraints.apply(this, [c]);
                        };
                    }
                }
                navigator.getUserMedia = function(constraints, onSuccess, onError) {
                    if (browserDetails.version &lt; 44) {
                        return getUserMedia_(constraints, onSuccess, onError);
                    }
                    // Replace Firefox 44+&apos;s deprecation warning with unprefixed version.
                    utils.deprecated(&apos;navigator.getUserMedia&apos;,
                        &apos;navigator.mediaDevices.getUserMedia&apos;);
                    navigator.mediaDevices.getUserMedia(constraints).then(onSuccess, onError);
                };
            };

        }, {
            &quot;../utils&quot;: 12
        }],
        11: [function(require, module, exports) {
            /*
             *  Copyright (c) 2016 The WebRTC project authors. All Rights Reserved.
             *
             *  Use of this source code is governed by a BSD-style license
             *  that can be found in the LICENSE file in the root of the source
             *  tree.
             */
            &apos;use strict&apos;;
            var utils = require(&apos;../utils&apos;);

            var safariShim = {
                // TODO: DrAlex, should be here, double check against LayoutTests

                // TODO: once the back-end for the mac port is done, add.
                // TODO: check for webkitGTK+
                // shimPeerConnection: function() { },

                shimLocalStreamsAPI: function(window) {
                    if (typeof window !== &apos;object&apos; || !window.RTCPeerConnection) {
                        return;
                    }
                    if (!(&apos;getLocalStreams&apos; in window.RTCPeerConnection.prototype)) {
                        window.RTCPeerConnection.prototype.getLocalStreams = function() {
                            if (!this._localStreams) {
                                this._localStreams = [];
                            }
                            return this._localStreams;
                        };
                    }
                    if (!(&apos;getStreamById&apos; in window.RTCPeerConnection.prototype)) {
                        window.RTCPeerConnection.prototype.getStreamById = function(id) {
                            var result = null;
                            if (this._localStreams) {
                                this._localStreams.forEach(function(stream) {
                                    if (stream.id === id) {
                                        result = stream;
                                    }
                                });
                            }
                            if (this._remoteStreams) {
                                this._remoteStreams.forEach(function(stream) {
                                    if (stream.id === id) {
                                        result = stream;
                                    }
                                });
                            }
                            return result;
                        };
                    }
                    if (!(&apos;addStream&apos; in window.RTCPeerConnection.prototype)) {
                        var _addTrack = window.RTCPeerConnection.prototype.addTrack;
                        window.RTCPeerConnection.prototype.addStream = function(stream) {
                            if (!this._localStreams) {
                                this._localStreams = [];
                            }
                            if (this._localStreams.indexOf(stream) === -1) {
                                this._localStreams.push(stream);
                            }
                            var self = this;
                            stream.getTracks().forEach(function(track) {
                                _addTrack.call(self, track, stream);
                            });
                        };

                        window.RTCPeerConnection.prototype.addTrack = function(track, stream) {
                            if (stream) {
                                if (!this._localStreams) {
                                    this._localStreams = [stream];
                                } else if (this._localStreams.indexOf(stream) === -1) {
                                    this._localStreams.push(stream);
                                }
                            }
                            _addTrack.call(this, track, stream);
                        };
                    }
                    if (!(&apos;removeStream&apos; in window.RTCPeerConnection.prototype)) {
                        window.RTCPeerConnection.prototype.removeStream = function(stream) {
                            if (!this._localStreams) {
                                this._localStreams = [];
                            }
                            var index = this._localStreams.indexOf(stream);
                            if (index === -1) {
                                return;
                            }
                            this._localStreams.splice(index, 1);
                            var self = this;
                            var tracks = stream.getTracks();
                            this.getSenders().forEach(function(sender) {
                                if (tracks.indexOf(sender.track) !== -1) {
                                    self.removeTrack(sender);
                                }
                            });
                        };
                    }
                },
                shimRemoteStreamsAPI: function(window) {
                    if (typeof window !== &apos;object&apos; || !window.RTCPeerConnection) {
                        return;
                    }
                    if (!(&apos;getRemoteStreams&apos; in window.RTCPeerConnection.prototype)) {
                        window.RTCPeerConnection.prototype.getRemoteStreams = function() {
                            return this._remoteStreams ? this._remoteStreams : [];
                        };
                    }
                    if (!(&apos;onaddstream&apos; in window.RTCPeerConnection.prototype)) {
                        Object.defineProperty(window.RTCPeerConnection.prototype, &apos;onaddstream&apos;, {
                            get: function() {
                                return this._onaddstream;
                            },
                            set: function(f) {
                                if (this._onaddstream) {
                                    this.removeEventListener(&apos;addstream&apos;, this._onaddstream);
                                    this.removeEventListener(&apos;track&apos;, this._onaddstreampoly);
                                }
                                this.addEventListener(&apos;addstream&apos;, this._onaddstream = f);
                                this.addEventListener(&apos;track&apos;, this._onaddstreampoly = function(e) {
                                    var stream = e.streams[0];
                                    if (!this._remoteStreams) {
                                        this._remoteStreams = [];
                                    }
                                    if (this._remoteStreams.indexOf(stream) &gt;= 0) {
                                        return;
                                    }
                                    this._remoteStreams.push(stream);
                                    var event = new Event(&apos;addstream&apos;);
                                    event.stream = e.streams[0];
                                    this.dispatchEvent(event);
                                }.bind(this));
                            }
                        });
                    }
                },
                shimCallbacksAPI: function(window) {
                    if (typeof window !== &apos;object&apos; || !window.RTCPeerConnection) {
                        return;
                    }
                    var prototype = window.RTCPeerConnection.prototype;
                    var createOffer = prototype.createOffer;
                    var createAnswer = prototype.createAnswer;
                    var setLocalDescription = prototype.setLocalDescription;
                    var setRemoteDescription = prototype.setRemoteDescription;
                    var addIceCandidate = prototype.addIceCandidate;

                    prototype.createOffer = function(successCallback, failureCallback) {
                        var options = (arguments.length &gt;= 2) ? arguments[2] : arguments[0];
                        var promise = createOffer.apply(this, [options]);
                        if (!failureCallback) {
                            return promise;
                        }
                        promise.then(successCallback, failureCallback);
                        return Promise.resolve();
                    };

                    prototype.createAnswer = function(successCallback, failureCallback) {
                        var options = (arguments.length &gt;= 2) ? arguments[2] : arguments[0];
                        var promise = createAnswer.apply(this, [options]);
                        if (!failureCallback) {
                            return promise;
                        }
                        promise.then(successCallback, failureCallback);
                        return Promise.resolve();
                    };

                    var withCallback = function(description, successCallback, failureCallback) {
                        var promise = setLocalDescription.apply(this, [description]);
                        if (!failureCallback) {
                            return promise;
                        }
                        promise.then(successCallback, failureCallback);
                        return Promise.resolve();
                    };
                    prototype.setLocalDescription = withCallback;

                    withCallback = function(description, successCallback, failureCallback) {
                        var promise = setRemoteDescription.apply(this, [description]);
                        if (!failureCallback) {
                            return promise;
                        }
                        promise.then(successCallback, failureCallback);
                        return Promise.resolve();
                    };
                    prototype.setRemoteDescription = withCallback;

                    withCallback = function(candidate, successCallback, failureCallback) {
                        var promise = addIceCandidate.apply(this, [candidate]);
                        if (!failureCallback) {
                            return promise;
                        }
                        promise.then(successCallback, failureCallback);
                        return Promise.resolve();
                    };
                    prototype.addIceCandidate = withCallback;
                },
                shimGetUserMedia: function(window) {
                    var navigator = window &amp;&amp; window.navigator;

                    if (!navigator.getUserMedia) {
                        if (navigator.webkitGetUserMedia) {
                            navigator.getUserMedia = navigator.webkitGetUserMedia.bind(navigator);
                        } else if (navigator.mediaDevices &amp;&amp;
                            navigator.mediaDevices.getUserMedia) {
                            navigator.getUserMedia = function(constraints, cb, errcb) {
                                navigator.mediaDevices.getUserMedia(constraints)
                                    .then(cb, errcb);
                            }.bind(navigator);
                        }
                    }
                },
                shimRTCIceServerUrls: function(window) {
                    // migrate from non-spec RTCIceServer.url to RTCIceServer.urls
                    var OrigPeerConnection = window.RTCPeerConnection;
                    window.RTCPeerConnection = function(pcConfig, pcConstraints) {
                        if (pcConfig &amp;&amp; pcConfig.iceServers) {
                            var newIceServers = [];
                            for (var i = 0; i &lt; pcConfig.iceServers.length; i++) {
                                var server = pcConfig.iceServers[i];
                                if (!server.hasOwnProperty(&apos;urls&apos;) &amp;&amp;
                                    server.hasOwnProperty(&apos;url&apos;)) {
                                    utils.deprecated(&apos;RTCIceServer.url&apos;, &apos;RTCIceServer.urls&apos;);
                                    server = JSON.parse(JSON.stringify(server));
                                    server.urls = server.url;
                                    delete server.url;
                                    newIceServers.push(server);
                                } else {
                                    newIceServers.push(pcConfig.iceServers[i]);
                                }
                            }
                            pcConfig.iceServers = newIceServers;
                        }
                        return new OrigPeerConnection(pcConfig, pcConstraints);
                    };
                    window.RTCPeerConnection.prototype = OrigPeerConnection.prototype;
                    // wrap static methods. Currently just generateCertificate.
                    Object.defineProperty(window.RTCPeerConnection, &apos;generateCertificate&apos;, {
                        get: function() {
                            return OrigPeerConnection.generateCertificate;
                        }
                    });
                }
            };

            // Expose public methods.
            module.exports = {
                shimCallbacksAPI: safariShim.shimCallbacksAPI,
                shimLocalStreamsAPI: safariShim.shimLocalStreamsAPI,
                shimRemoteStreamsAPI: safariShim.shimRemoteStreamsAPI,
                shimGetUserMedia: safariShim.shimGetUserMedia,
                shimRTCIceServerUrls: safariShim.shimRTCIceServerUrls
                // TODO
                // shimPeerConnection: safariShim.shimPeerConnection
            };

        }, {
            &quot;../utils&quot;: 12
        }],
        12: [function(require, module, exports) {
            /*
             *  Copyright (c) 2016 The WebRTC project authors. All Rights Reserved.
             *
             *  Use of this source code is governed by a BSD-style license
             *  that can be found in the LICENSE file in the root of the source
             *  tree.
             */
            /* eslint-env node */
            &apos;use strict&apos;;

            var logDisabled_ = true;
            var deprecationWarnings_ = true;

            // Utility methods.
            var utils = {
                disableLog: function(bool) {
                    if (typeof bool !== &apos;boolean&apos;) {
                        return new Error(&apos;Argument type: &apos; + typeof bool +
                            &apos;. Please use a boolean.&apos;);
                    }
                    logDisabled_ = bool;
                    return (bool) ? &apos;adapter.js logging disabled&apos; :
                        &apos;adapter.js logging enabled&apos;;
                },

                /**
                 * Disable or enable deprecation warnings
                 * @param {!boolean} bool set to true to disable warnings.
                 */
                disableWarnings: function(bool) {
                    if (typeof bool !== &apos;boolean&apos;) {
                        return new Error(&apos;Argument type: &apos; + typeof bool +
                            &apos;. Please use a boolean.&apos;);
                    }
                    deprecationWarnings_ = !bool;
                    return &apos;adapter.js deprecation warnings &apos; + (bool ? &apos;disabled&apos; : &apos;enabled&apos;);
                },

                log: function() {
                    if (typeof window === &apos;object&apos;) {
                        if (logDisabled_) {
                            return;
                        }
                        if (typeof console !== &apos;undefined&apos; &amp;&amp; typeof console.log === &apos;function&apos;) {
                            console.log.apply(console, arguments);
                        }
                    }
                },

                /**
                 * Shows a deprecation warning suggesting the modern and spec-compatible API.
                 */
                deprecated: function(oldMethod, newMethod) {
                    if (!deprecationWarnings_) {
                        return;
                    }
                    console.warn(oldMethod + &apos; is deprecated, please use &apos; + newMethod +
                        &apos; instead.&apos;);
                },

                /**
                 * Extract browser version out of the provided user agent string.
                 *
                 * @param {!string} uastring userAgent string.
                 * @param {!string} expr Regular expression used as match criteria.
                 * @param {!number} pos position in the version string to be returned.
                 * @return {!number} browser version.
                 */
                extractVersion: function(uastring, expr, pos) {
                    var match = uastring.match(expr);
                    return match &amp;&amp; match.length &gt;= pos &amp;&amp; parseInt(match[pos], 10);
                },

                /**
                 * Browser detector.
                 *
                 * @return {object} result containing browser and version
                 *     properties.
                 */
                detectBrowser: function(window) {
                    var navigator = window &amp;&amp; window.navigator;

                    // Returned result object.
                    var result = {};
                    result.browser = null;
                    result.version = null;

                    // Fail early if it&apos;s not a browser
                    if (typeof window === &apos;undefined&apos; || !window.navigator) {
                        result.browser = &apos;Not a browser.&apos;;
                        return result;
                    }

                    // Firefox.
                    if (navigator.mozGetUserMedia) {
                        result.browser = &apos;firefox&apos;;
                        result.version = this.extractVersion(navigator.userAgent,
                            /Firefox\/(\d+)\./, 1);
                    } else if (navigator.webkitGetUserMedia) {
                        // Chrome, Chromium, Webview, Opera, all use the chrome shim for now
                        if (window.webkitRTCPeerConnection) {
                            result.browser = &apos;chrome&apos;;
                            result.version = this.extractVersion(navigator.userAgent,
                                /Chrom(e|ium)\/(\d+)\./, 2);
                        } else { // Safari (in an unpublished version) or unknown webkit-based.
                            if (navigator.userAgent.match(/Version\/(\d+).(\d+)/)) {
                                result.browser = &apos;safari&apos;;
                                result.version = this.extractVersion(navigator.userAgent,
                                    /AppleWebKit\/(\d+)\./, 1);
                            } else { // unknown webkit-based browser.
                                result.browser = &apos;Unsupported webkit-based browser &apos; +
                                    &apos;with GUM support but no WebRTC support.&apos;;
                                return result;
                            }
                        }
                    } else if (navigator.mediaDevices &amp;&amp;
                        navigator.userAgent.match(/Edge\/(\d+).(\d+)$/)) { // Edge.
                        result.browser = &apos;edge&apos;;
                        result.version = this.extractVersion(navigator.userAgent,
                            /Edge\/(\d+).(\d+)$/, 2);
                    } else if (navigator.mediaDevices &amp;&amp;
                        navigator.userAgent.match(/AppleWebKit\/(\d+)\./)) {
                        // Safari, with webkitGetUserMedia removed.
                        result.browser = &apos;safari&apos;;
                        result.version = this.extractVersion(navigator.userAgent,
                            /AppleWebKit\/(\d+)\./, 1);
                    } else { // Default fallthrough: not supported.
                        result.browser = &apos;Not a supported browser.&apos;;
                        return result;
                    }

                    return result;
                },

                // shimCreateObjectURL must be called before shimSourceObject to avoid loop.

                shimCreateObjectURL: function(window) {
                    var URL = window &amp;&amp; window.URL;

                    if (!(typeof window === &apos;object&apos; &amp;&amp; window.HTMLMediaElement &amp;&amp;
                            &apos;srcObject&apos; in window.HTMLMediaElement.prototype)) {
                        // Only shim CreateObjectURL using srcObject if srcObject exists.
                        return undefined;
                    }

                    var nativeCreateObjectURL = URL.createObjectURL.bind(URL);
                    var nativeRevokeObjectURL = URL.revokeObjectURL.bind(URL);
                    var streams = new Map(),
                        newId = 0;

                    URL.createObjectURL = function(stream) {
                        if (&apos;getTracks&apos; in stream) {
                            var url = &apos;polyblob:&apos; + (++newId);
                            streams.set(url, stream);
                            utils.deprecated(&apos;URL.createObjectURL(stream)&apos;,
                                &apos;elem.srcObject = stream&apos;);
                            return url;
                        }
                        return nativeCreateObjectURL(stream);
                    };
                    URL.revokeObjectURL = function(url) {
                        nativeRevokeObjectURL(url);
                        streams.delete(url);
                    };

                    var dsc = Object.getOwnPropertyDescriptor(window.HTMLMediaElement.prototype,
                        &apos;src&apos;);
                    Object.defineProperty(window.HTMLMediaElement.prototype, &apos;src&apos;, {
                        get: function() {
                            return dsc.get.apply(this);
                        },
                        set: function(url) {
                            this.srcObject = streams.get(url) || null;
                            return dsc.set.apply(this, [url]);
                        }
                    });

                    var nativeSetAttribute = window.HTMLMediaElement.prototype.setAttribute;
                    window.HTMLMediaElement.prototype.setAttribute = function() {
                        if (arguments.length === 2 &amp;&amp;
                            (&apos;&apos; + arguments[0]).toLowerCase() === &apos;src&apos;) {
                            this.srcObject = streams.get(arguments[1]) || null;
                        }
                        return nativeSetAttribute.apply(this, arguments);
                    };
                }
            };

            // Export.
            module.exports = {
                log: utils.log,
                deprecated: utils.deprecated,
                disableLog: utils.disableLog,
                disableWarnings: utils.disableWarnings,
                extractVersion: utils.extractVersion,
                shimCreateObjectURL: utils.shimCreateObjectURL,
                detectBrowser: utils.detectBrowser.bind(utils)
            };

        }, {}]
    }, {}, [2])(2)
});
</code></pre>

</div>

<footer class="footer">
  Generated by <a href="https://esdoc.org">ESDoc<span data-ice="esdocVersion">(1.1.0)</span><img src="./image/esdoc-logo-mini-black.png"></a>
</footer>

<script src="script/search_index.js"></script>
<script src="script/search.js"></script>
<script src="script/pretty-print.js"></script>
<script src="script/inherited-summary.js"></script>
<script src="script/test-summary.js"></script>
<script src="script/inner-link.js"></script>
<script src="script/patch-for-local.js"></script>
</body>
</html>
