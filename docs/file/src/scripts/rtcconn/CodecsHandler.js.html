<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <base data-ice="baseUrl" href="../../../../">
  <title data-ice="title">src/scripts/rtcconn/CodecsHandler.js | webrtcdevelopment</title>
  <link type="text/css" rel="stylesheet" href="css/style.css">
  <link type="text/css" rel="stylesheet" href="css/prettify-tomorrow.css">
  <script src="script/prettify/prettify.js"></script>
  <script src="script/manual.js"></script>
<meta name="description" content="webrtc based communication and collaboration client. Contains lot of experiments modules "><meta property="twitter:card" content="summary"><meta property="twitter:title" content="webrtcdevelopment"><meta property="twitter:description" content="webrtc based communication and collaboration client. Contains lot of experiments modules "></head>
<body class="layout-container" data-ice="rootContainer">

<header>
  <a href="./">Home</a>
  
  <a href="identifiers.html">Reference</a>
  <a href="source.html">Source</a>
  
  <div class="search-box">
  <span>
    <img src="./image/search.png">
    <span class="search-input-edge"></span><input class="search-input"><span class="search-input-edge"></span>
  </span>
    <ul class="search-result"></ul>
  </div>
<a style="position:relative; top:3px;" href="https://github.com/altanai/webrtc"><img width="20px" src="./image/github.png"></a></header>

<nav class="navigation" data-ice="nav"><div>
  <ul>
    
  <li data-ice="doc"><a data-ice="dirPath" class="nav-dir-path" href="identifiers.html#scripts">scripts</a><span data-ice="kind" class="kind-typedef">T</span><span data-ice="name"><span><a href="typedef/index.html#static-typedef-CanvasRecorder">CanvasRecorder</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-typedef">T</span><span data-ice="name"><span><a href="typedef/index.html#static-typedef-GetRecorderType">GetRecorderType</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-typedef">T</span><span data-ice="name"><span><a href="typedef/index.html#static-typedef-GifRecorder">GifRecorder</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-typedef">T</span><span data-ice="name"><span><a href="typedef/index.html#static-typedef-MRecordRTC">MRecordRTC</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-typedef">T</span><span data-ice="name"><span><a href="typedef/index.html#static-typedef-MediaStreamRecorder">MediaStreamRecorder</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-typedef">T</span><span data-ice="name"><span><a href="typedef/index.html#static-typedef-RecordRTC">RecordRTC</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-typedef">T</span><span data-ice="name"><span><a href="typedef/index.html#static-typedef-RecordRTCConfiguration">RecordRTCConfiguration</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-typedef">T</span><span data-ice="name"><span><a href="typedef/index.html#static-typedef-StereoAudioRecorder">StereoAudioRecorder</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-typedef">T</span><span data-ice="name"><span><a href="typedef/index.html#static-typedef-Whammy">Whammy</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-typedef">T</span><span data-ice="name"><span><a href="typedef/index.html#static-typedef-WhammyRecorder">WhammyRecorder</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-typedef">T</span><span data-ice="name"><span><a href="typedef/index.html#static-typedef-createFileSharingDiv">createFileSharingDiv</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-typedef">T</span><span data-ice="name"><span><a href="typedef/index.html#static-typedef-_turn.js">_turn.js</a></span></span></li>
<li data-ice="doc"><a data-ice="dirPath" class="nav-dir-path" href="identifiers.html#scripts-rtcconn">scripts/rtcconn</a><span data-ice="kind" class="kind-typedef">T</span><span data-ice="name"><span><a href="typedef/index.html#static-typedef-Whammy">Whammy</a></span></span></li>
</ul>
</div>
</nav>

<div class="content" data-ice="content"><h1 data-ice="title">src/scripts/rtcconn/CodecsHandler.js</h1>
<pre class="source-code line-number raw-source-code"><code class="prettyprint linenums" data-ice="content">// CodecsHandler.js

var CodecsHandler = (function() {
    function preferCodec(sdp, codecName) {
        var info = splitLines(sdp);

        if (!info.videoCodecNumbers) {
            return sdp;
        }

        if (codecName === &apos;vp8&apos; &amp;&amp; info.vp8LineNumber === info.videoCodecNumbers[0]) {
            return sdp;
        }

        if (codecName === &apos;vp9&apos; &amp;&amp; info.vp9LineNumber === info.videoCodecNumbers[0]) {
            return sdp;
        }

        if (codecName === &apos;h264&apos; &amp;&amp; info.h264LineNumber === info.videoCodecNumbers[0]) {
            return sdp;
        }

        sdp = preferCodecHelper(sdp, codecName, info);

        return sdp;
    }

    function preferCodecHelper(sdp, codec, info, ignore) {
        var preferCodecNumber = &apos;&apos;;

        if (codec === &apos;vp8&apos;) {
            if (!info.vp8LineNumber) {
                return sdp;
            }
            preferCodecNumber = info.vp8LineNumber;
        }

        if (codec === &apos;vp9&apos;) {
            if (!info.vp9LineNumber) {
                return sdp;
            }
            preferCodecNumber = info.vp9LineNumber;
        }

        if (codec === &apos;h264&apos;) {
            if (!info.h264LineNumber) {
                return sdp;
            }

            preferCodecNumber = info.h264LineNumber;
        }

        var newLine = info.videoCodecNumbersOriginal.split(&apos;SAVPF&apos;)[0] + &apos;SAVPF &apos;;

        var newOrder = [preferCodecNumber];

        if (ignore) {
            newOrder = [];
        }

        info.videoCodecNumbers.forEach(function(codecNumber) {
            if (codecNumber === preferCodecNumber) return;
            newOrder.push(codecNumber);
        });

        newLine += newOrder.join(&apos; &apos;);

        sdp = sdp.replace(info.videoCodecNumbersOriginal, newLine);
        return sdp;
    }

    function splitLines(sdp) {
        var info = {};
        sdp.split(&apos;\n&apos;).forEach(function(line) {
            if (line.indexOf(&apos;m=video&apos;) === 0) {
                info.videoCodecNumbers = [];
                line.split(&apos;SAVPF&apos;)[1].split(&apos; &apos;).forEach(function(codecNumber) {
                    codecNumber = codecNumber.trim();
                    if (!codecNumber || !codecNumber.length) return;
                    info.videoCodecNumbers.push(codecNumber);
                    info.videoCodecNumbersOriginal = line;
                });
            }

            if (line.indexOf(&apos;VP8/90000&apos;) !== -1 &amp;&amp; !info.vp8LineNumber) {
                info.vp8LineNumber = line.replace(&apos;a=rtpmap:&apos;, &apos;&apos;).split(&apos; &apos;)[0];
            }

            if (line.indexOf(&apos;VP9/90000&apos;) !== -1 &amp;&amp; !info.vp9LineNumber) {
                info.vp9LineNumber = line.replace(&apos;a=rtpmap:&apos;, &apos;&apos;).split(&apos; &apos;)[0];
            }

            if (line.indexOf(&apos;H264/90000&apos;) !== -1 &amp;&amp; !info.h264LineNumber) {
                info.h264LineNumber = line.replace(&apos;a=rtpmap:&apos;, &apos;&apos;).split(&apos; &apos;)[0];
            }
        });

        return info;
    }

    function removeVPX(sdp) {
        var info = splitLines(sdp);

        // last parameter below means: ignore these codecs
        sdp = preferCodecHelper(sdp, &apos;vp9&apos;, info, true);
        sdp = preferCodecHelper(sdp, &apos;vp8&apos;, info, true);

        return sdp;
    }

    function disableNACK(sdp) {
        if (!sdp || typeof sdp !== &apos;string&apos;) {
            throw &apos;Invalid arguments.&apos;;
        }

        sdp = sdp.replace(&apos;a=rtcp-fb:126 nack\r\n&apos;, &apos;&apos;);
        sdp = sdp.replace(&apos;a=rtcp-fb:126 nack pli\r\n&apos;, &apos;a=rtcp-fb:126 pli\r\n&apos;);
        sdp = sdp.replace(&apos;a=rtcp-fb:97 nack\r\n&apos;, &apos;&apos;);
        sdp = sdp.replace(&apos;a=rtcp-fb:97 nack pli\r\n&apos;, &apos;a=rtcp-fb:97 pli\r\n&apos;);

        return sdp;
    }

    function prioritize(codecMimeType, peer) {
        if (!peer || !peer.getSenders || !peer.getSenders().length) {
            return;
        }

        if (!codecMimeType || typeof codecMimeType !== &apos;string&apos;) {
            throw &apos;Invalid arguments.&apos;;
        }

        peer.getSenders().forEach(function(sender) {
            var params = sender.getParameters();
            for (var i = 0; i &lt; params.codecs.length; i++) {
                if (params.codecs[i].mimeType == codecMimeType) {
                    params.codecs.unshift(params.codecs.splice(i, 1));
                    break;
                }
            }
            sender.setParameters(params);
        });
    }

    function removeNonG722(sdp) {
        return sdp.replace(/m=audio ([0-9]+) RTP\/SAVPF ([0-9 ]*)/g, &apos;m=audio $1 RTP\/SAVPF 9&apos;);
    }

    function setBAS(sdp, bandwidth, isScreen) {
        if (!bandwidth) {
            return sdp;
        }

        if (typeof isFirefox !== &apos;undefined&apos; &amp;&amp; isFirefox) {
            return sdp;
        }

        if (isScreen) {
            if (!bandwidth.screen) {
                console.warn(&apos;It seems that you are not using bandwidth for screen. Screen sharing is expected to fail.&apos;);
            } else if (bandwidth.screen &lt; 300) {
                console.warn(&apos;It seems that you are using wrong bandwidth value for screen. Screen sharing is expected to fail.&apos;);
            }
        }

        // if screen; must use at least 300kbs
        if (bandwidth.screen &amp;&amp; isScreen) {
            sdp = sdp.replace(/b=AS([^\r\n]+\r\n)/g, &apos;&apos;);
            sdp = sdp.replace(/a=mid:video\r\n/g, &apos;a=mid:video\r\nb=AS:&apos; + bandwidth.screen + &apos;\r\n&apos;);
        }

        // remove existing bandwidth lines
        if (bandwidth.audio || bandwidth.video) {
            sdp = sdp.replace(/b=AS([^\r\n]+\r\n)/g, &apos;&apos;);
        }

        if (bandwidth.audio) {
            sdp = sdp.replace(/a=mid:audio\r\n/g, &apos;a=mid:audio\r\nb=AS:&apos; + bandwidth.audio + &apos;\r\n&apos;);
        }

        if (bandwidth.screen) {
            sdp = sdp.replace(/a=mid:video\r\n/g, &apos;a=mid:video\r\nb=AS:&apos; + bandwidth.screen + &apos;\r\n&apos;);
        } else if (bandwidth.video) {
            sdp = sdp.replace(/a=mid:video\r\n/g, &apos;a=mid:video\r\nb=AS:&apos; + bandwidth.video + &apos;\r\n&apos;);
        }

        return sdp;
    }

    // Find the line in sdpLines that starts with |prefix|, and, if specified,
    // contains |substr| (case-insensitive search).
    function findLine(sdpLines, prefix, substr) {
        return findLineInRange(sdpLines, 0, -1, prefix, substr);
    }

    // Find the line in sdpLines[startLine...endLine - 1] that starts with |prefix|
    // and, if specified, contains |substr| (case-insensitive search).
    function findLineInRange(sdpLines, startLine, endLine, prefix, substr) {
        var realEndLine = endLine !== -1 ? endLine : sdpLines.length;
        for (var i = startLine; i &lt; realEndLine; ++i) {
            if (sdpLines[i].indexOf(prefix) === 0) {
                if (!substr ||
                    sdpLines[i].toLowerCase().indexOf(substr.toLowerCase()) !== -1) {
                    return i;
                }
            }
        }
        return null;
    }

    // Gets the codec payload type from an a=rtpmap:X line.
    function getCodecPayloadType(sdpLine) {
        var pattern = new RegExp(&apos;a=rtpmap:(\\d+) \\w+\\/\\d+&apos;);
        var result = sdpLine.match(pattern);
        return (result &amp;&amp; result.length === 2) ? result[1] : null;
    }

    function setVideoBitrates(sdp, params) {
        params = params || {};
        var xgoogle_min_bitrate = params.min;
        var xgoogle_max_bitrate = params.max;

        var sdpLines = sdp.split(&apos;\r\n&apos;);

        // VP8
        var vp8Index = findLine(sdpLines, &apos;a=rtpmap&apos;, &apos;VP8/90000&apos;);
        var vp8Payload;
        if (vp8Index) {
            vp8Payload = getCodecPayloadType(sdpLines[vp8Index]);
        }

        if (!vp8Payload) {
            return sdp;
        }

        var rtxIndex = findLine(sdpLines, &apos;a=rtpmap&apos;, &apos;rtx/90000&apos;);
        var rtxPayload;
        if (rtxIndex) {
            rtxPayload = getCodecPayloadType(sdpLines[rtxIndex]);
        }

        if (!rtxIndex) {
            return sdp;
        }

        var rtxFmtpLineIndex = findLine(sdpLines, &apos;a=fmtp:&apos; + rtxPayload.toString());
        if (rtxFmtpLineIndex !== null) {
            var appendrtxNext = &apos;\r\n&apos;;
            appendrtxNext += &apos;a=fmtp:&apos; + vp8Payload + &apos; x-google-min-bitrate=&apos; + (xgoogle_min_bitrate || &apos;228&apos;) + &apos;; x-google-max-bitrate=&apos; + (xgoogle_max_bitrate || &apos;228&apos;);
            sdpLines[rtxFmtpLineIndex] = sdpLines[rtxFmtpLineIndex].concat(appendrtxNext);
            sdp = sdpLines.join(&apos;\r\n&apos;);
        }

        return sdp;
    }

    function setOpusAttributes(sdp, params) {
        params = params || {};

        var sdpLines = sdp.split(&apos;\r\n&apos;);

        // Opus
        var opusIndex = findLine(sdpLines, &apos;a=rtpmap&apos;, &apos;opus/48000&apos;);
        var opusPayload;
        if (opusIndex) {
            opusPayload = getCodecPayloadType(sdpLines[opusIndex]);
        }

        if (!opusPayload) {
            return sdp;
        }

        var opusFmtpLineIndex = findLine(sdpLines, &apos;a=fmtp:&apos; + opusPayload.toString());
        if (opusFmtpLineIndex === null) {
            return sdp;
        }

        var appendOpusNext = &apos;&apos;;
        appendOpusNext += &apos;; stereo=&apos; + (typeof params.stereo != &apos;undefined&apos; ? params.stereo : &apos;1&apos;);
        appendOpusNext += &apos;; sprop-stereo=&apos; + (typeof params[&apos;sprop-stereo&apos;] != &apos;undefined&apos; ? params[&apos;sprop-stereo&apos;] : &apos;1&apos;);

        if (typeof params.maxaveragebitrate != &apos;undefined&apos;) {
            appendOpusNext += &apos;; maxaveragebitrate=&apos; + (params.maxaveragebitrate || 128 * 1024 * 8);
        }

        if (typeof params.maxplaybackrate != &apos;undefined&apos;) {
            appendOpusNext += &apos;; maxplaybackrate=&apos; + (params.maxplaybackrate || 128 * 1024 * 8);
        }

        if (typeof params.cbr != &apos;undefined&apos;) {
            appendOpusNext += &apos;; cbr=&apos; + (typeof params.cbr != &apos;undefined&apos; ? params.cbr : &apos;1&apos;);
        }

        if (typeof params.useinbandfec != &apos;undefined&apos;) {
            appendOpusNext += &apos;; useinbandfec=&apos; + params.useinbandfec;
        }

        if (typeof params.usedtx != &apos;undefined&apos;) {
            appendOpusNext += &apos;; usedtx=&apos; + params.usedtx;
        }

        if (typeof params.maxptime != &apos;undefined&apos;) {
            appendOpusNext += &apos;\r\na=maxptime:&apos; + params.maxptime;
        }

        sdpLines[opusFmtpLineIndex] = sdpLines[opusFmtpLineIndex].concat(appendOpusNext);

        sdp = sdpLines.join(&apos;\r\n&apos;);
        return sdp;
    }

    // forceStereoAudio =&gt; via webrtcexample.com
    // requires getUserMedia =&gt; echoCancellation:false
    function forceStereoAudio(sdp) {
        var sdpLines = sdp.split(&apos;\r\n&apos;);
        var fmtpLineIndex = null;
        for (var i = 0; i &lt; sdpLines.length; i++) {
            if (sdpLines[i].search(&apos;opus/48000&apos;) !== -1) {
                var opusPayload = extractSdp(sdpLines[i], /:(\d+) opus\/48000/i);
                break;
            }
        }
        for (var i = 0; i &lt; sdpLines.length; i++) {
            if (sdpLines[i].search(&apos;a=fmtp&apos;) !== -1) {
                var payload = extractSdp(sdpLines[i], /a=fmtp:(\d+)/);
                if (payload === opusPayload) {
                    fmtpLineIndex = i;
                    break;
                }
            }
        }
        if (fmtpLineIndex === null) return sdp;
        sdpLines[fmtpLineIndex] = sdpLines[fmtpLineIndex].concat(&apos;; stereo=1; sprop-stereo=1&apos;);
        sdp = sdpLines.join(&apos;\r\n&apos;);
        return sdp;
    }

    return {
        removeVPX: removeVPX,
        disableNACK: disableNACK,
        prioritize: prioritize,
        removeNonG722: removeNonG722,
        setApplicationSpecificBandwidth: function(sdp, bandwidth, isScreen) {
            return setBAS(sdp, bandwidth, isScreen);
        },
        setVideoBitrates: function(sdp, params) {
            return setVideoBitrates(sdp, params);
        },
        setOpusAttributes: function(sdp, params) {
            return setOpusAttributes(sdp, params);
        },
        preferVP9: function(sdp) {
            return preferCodec(sdp, &apos;vp9&apos;);
        },
        preferCodec: preferCodec,
        forceStereoAudio: forceStereoAudio
    };
})();

// backward compatibility
window.BandwidthHandler = CodecsHandler;
</code></pre>

</div>

<footer class="footer">
  Generated by <a href="https://esdoc.org">ESDoc<span data-ice="esdocVersion">(1.1.0)</span><img src="./image/esdoc-logo-mini-black.png"></a>
</footer>

<script src="script/search_index.js"></script>
<script src="script/search.js"></script>
<script src="script/pretty-print.js"></script>
<script src="script/inherited-summary.js"></script>
<script src="script/test-summary.js"></script>
<script src="script/inner-link.js"></script>
<script src="script/patch-for-local.js"></script>
</body>
</html>
