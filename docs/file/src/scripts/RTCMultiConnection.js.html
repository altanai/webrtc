<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <base data-ice="baseUrl" href="../../../">
  <title data-ice="title">src/scripts/RTCMultiConnection.js | webrtcdevelopment</title>
  <link type="text/css" rel="stylesheet" href="css/style.css">
  <link type="text/css" rel="stylesheet" href="css/prettify-tomorrow.css">
  <script src="script/prettify/prettify.js"></script>
  <script src="script/manual.js"></script>
<meta name="description" content="webrtc based communication and collaboration client. Contains lot of experiments modules "><meta property="twitter:card" content="summary"><meta property="twitter:title" content="webrtcdevelopment"><meta property="twitter:description" content="webrtc based communication and collaboration client. Contains lot of experiments modules "></head>
<body class="layout-container" data-ice="rootContainer">

<header>
  <a href="./">Home</a>
  
  <a href="identifiers.html">Reference</a>
  <a href="source.html">Source</a>
  
  <div class="search-box">
  <span>
    <img src="./image/search.png">
    <span class="search-input-edge"></span><input class="search-input"><span class="search-input-edge"></span>
  </span>
    <ul class="search-result"></ul>
  </div>
<a style="position:relative; top:3px;" href="https://github.com/altanai/webrtc"><img width="20px" src="./image/github.png"></a></header>

<nav class="navigation" data-ice="nav"><div>
  <ul>
    
  <li data-ice="doc"><a data-ice="dirPath" class="nav-dir-path" href="identifiers.html#scripts">scripts</a><span data-ice="kind" class="kind-typedef">T</span><span data-ice="name"><span><a href="typedef/index.html#static-typedef-CanvasRecorder">CanvasRecorder</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-typedef">T</span><span data-ice="name"><span><a href="typedef/index.html#static-typedef-GetRecorderType">GetRecorderType</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-typedef">T</span><span data-ice="name"><span><a href="typedef/index.html#static-typedef-GifRecorder">GifRecorder</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-typedef">T</span><span data-ice="name"><span><a href="typedef/index.html#static-typedef-MRecordRTC">MRecordRTC</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-typedef">T</span><span data-ice="name"><span><a href="typedef/index.html#static-typedef-MediaStreamRecorder">MediaStreamRecorder</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-typedef">T</span><span data-ice="name"><span><a href="typedef/index.html#static-typedef-RecordRTC">RecordRTC</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-typedef">T</span><span data-ice="name"><span><a href="typedef/index.html#static-typedef-RecordRTCConfiguration">RecordRTCConfiguration</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-typedef">T</span><span data-ice="name"><span><a href="typedef/index.html#static-typedef-StereoAudioRecorder">StereoAudioRecorder</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-typedef">T</span><span data-ice="name"><span><a href="typedef/index.html#static-typedef-Whammy">Whammy</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-typedef">T</span><span data-ice="name"><span><a href="typedef/index.html#static-typedef-WhammyRecorder">WhammyRecorder</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-typedef">T</span><span data-ice="name"><span><a href="typedef/index.html#static-typedef-createFileSharingDiv">createFileSharingDiv</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-typedef">T</span><span data-ice="name"><span><a href="typedef/index.html#static-typedef-_turn.js">_turn.js</a></span></span></li>
<li data-ice="doc"><a data-ice="dirPath" class="nav-dir-path" href="identifiers.html#scripts-rtcconn">scripts/rtcconn</a><span data-ice="kind" class="kind-typedef">T</span><span data-ice="name"><span><a href="typedef/index.html#static-typedef-Whammy">Whammy</a></span></span></li>
</ul>
</div>
</nav>

<div class="content" data-ice="content"><h1 data-ice="title">src/scripts/RTCMultiConnection.js</h1>
<pre class="source-code line-number raw-source-code"><code class="prettyprint linenums" data-ice="content">// Last time updated: 2016-08-12 5:21:05 AM UTC
// _____________________
// RTCMultiConnection-v3
// Open-Sourced: https://github.com/muaz-khan/RTCMultiConnection
// --------------------------------------------------
// Muaz Khan     - www.MuazKhan.com
// MIT License   - www.WebRTC-Experiment.com/licence
// --------------------------------------------------
&apos;use strict&apos;;
&quot;use strict&quot;;
!function() {
    function RTCMultiConnection(roomid, forceOptions) {
        function onUserLeft(remoteUserId) {
            connection.deletePeer(remoteUserId)
        }
        function connectSocket(connectCallback) {
            if (connection.socketAutoReConnect = !0,
            connection.socket)
                return void (connectCallback &amp;&amp; connectCallback(connection.socket));
            if (&quot;undefined&quot; == typeof SocketConnection)
                if (&quot;undefined&quot; != typeof FirebaseConnection)
                    window.SocketConnection = FirebaseConnection;
                else {
                    if (&quot;undefined&quot; == typeof PubNubConnection)
                        throw &quot;SocketConnection.js seems missed.&quot;;
                    window.SocketConnection = PubNubConnection
                }
            new SocketConnection(connection,function(s) {
                connectCallback &amp;&amp; connectCallback(connection.socket)
            }
            )
        }
        function beforeUnload(shiftModerationControlOnLeave, dontCloseSocket) {
            connection.closeBeforeUnload &amp;&amp; (connection.isInitiator === !0 &amp;&amp; connection.dontMakeMeModerator(),
            connection.peers.getAllParticipants().forEach(function(participant) {
                mPeer.onNegotiationNeeded({
                    userLeft: !0
                }, participant),
                connection.peers[participant] &amp;&amp; connection.peers[participant].peer &amp;&amp; connection.peers[participant].peer.close(),
                delete connection.peers[participant]
            }),
            dontCloseSocket || connection.closeSocket(),
            connection.broadcasters = [],
            connection.isInitiator = !1)
        }
        function applyConstraints(stream, mediaConstraints) {
            return stream ? (mediaConstraints.audio &amp;&amp; stream.getAudioTracks().forEach(function(track) {
                track.applyConstraints(mediaConstraints.audio)
            }),
            void (mediaConstraints.video &amp;&amp; stream.getVideoTracks().forEach(function(track) {
                track.applyConstraints(mediaConstraints.video)
            }))) : void (connection.enableLogs &amp;&amp; webrtcdev.error(&quot;No stream to applyConstraints.&quot;))
        }
        function replaceTrack(track, remoteUserId, isVideoTrack) {
            return remoteUserId ? void mPeer.replaceTrack(track, remoteUserId, isVideoTrack) : void connection.peers.getAllParticipants().forEach(function(participant) {
                mPeer.replaceTrack(track, participant, isVideoTrack)
            })
        }
        function keepNextBroadcasterOnServer() {
            if (connection.isInitiator &amp;&amp; !connection.session.oneway &amp;&amp; !connection.session.broadcast &amp;&amp; &quot;many-to-many&quot; === connection.direction) {
                var firstBroadcaster = connection.broadcasters[0]
                  , otherBroadcasters = [];
                connection.broadcasters.forEach(function(broadcaster) {
                    broadcaster !== firstBroadcaster &amp;&amp; otherBroadcasters.push(broadcaster)
                }),
                connection.autoCloseEntireSession || connection.shiftModerationControl(firstBroadcaster, otherBroadcasters, !0)
            }
        }
        forceOptions = forceOptions || {
            useDefaultDevices: !0
        };
        var connection = this;
        connection.channel = connection.sessionid = (roomid || location.href.replace(/\/|:|#|\?|\$|\^|%|\.|`|~|!|\+|@|\[|\||]|\|*. /g, &quot;&quot;).split(&quot;\n&quot;).join(&quot;&quot;).split(&quot;\r&quot;).join(&quot;&quot;)) + &quot;&quot;;
        var mPeer = new MultiPeers(connection);
        mPeer.onGettingLocalMedia = function(stream) {
            stream.type = &quot;local&quot;,
            connection.setStreamEndHandler(stream),
            getRMCMediaElement(stream, function(mediaElement) {
                mediaElement.id = stream.streamid,
                mediaElement.muted = !0,
                mediaElement.volume = 0,
                -1 === connection.attachStreams.indexOf(stream) &amp;&amp; connection.attachStreams.push(stream),
                &quot;undefined&quot; != typeof StreamsHandler &amp;&amp; StreamsHandler.setHandlers(stream, !0, connection),
                connection.streamEvents[stream.streamid] = {
                    stream: stream,
                    type: &quot;local&quot;,
                    mediaElement: mediaElement,
                    userid: connection.userid,
                    extra: connection.extra,
                    streamid: stream.streamid,
                    blobURL: mediaElement.src || URL.createObjectURL(stream),
                    isAudioMuted: !0
                },
                setHarkEvents(connection, connection.streamEvents[stream.streamid]),
                setMuteHandlers(connection, connection.streamEvents[stream.streamid]),
                connection.onstream(connection.streamEvents[stream.streamid])
            }, connection)
        }
        ,
        mPeer.onGettingRemoteMedia = function(stream, remoteUserId) {
            stream.type = &quot;remote&quot;,
            connection.setStreamEndHandler(stream, &quot;remote-stream&quot;),
            getRMCMediaElement(stream, function(mediaElement) {
                mediaElement.id = stream.streamid,
                &quot;undefined&quot; != typeof StreamsHandler &amp;&amp; StreamsHandler.setHandlers(stream, !1, connection),
                connection.streamEvents[stream.streamid] = {
                    stream: stream,
                    type: &quot;remote&quot;,
                    userid: remoteUserId,
                    extra: connection.peers[remoteUserId] ? connection.peers[remoteUserId].extra : {},
                    mediaElement: mediaElement,
                    streamid: stream.streamid,
                    blobURL: mediaElement.src || URL.createObjectURL(stream)
                },
                setMuteHandlers(connection, connection.streamEvents[stream.streamid]),
                connection.onstream(connection.streamEvents[stream.streamid])
            }, connection)
        }
        ,
        mPeer.onRemovingRemoteMedia = function(stream, remoteUserId) {
            var streamEvent = connection.streamEvents[stream.streamid];
            streamEvent || (streamEvent = {
                stream: stream,
                type: &quot;remote&quot;,
                userid: remoteUserId,
                extra: connection.peers[remoteUserId] ? connection.peers[remoteUserId].extra : {},
                streamid: stream.streamid,
                mediaElement: connection.streamEvents[stream.streamid] ? connection.streamEvents[stream.streamid].mediaElement : null
            }),
            connection.onstreamended(streamEvent),
            delete connection.streamEvents[stream.streamid]
        }
        ,
        mPeer.onNegotiationNeeded = function(message, remoteUserId, callback) {
            connectSocket(function() {
                connection.socket.emit(connection.socketMessageEvent, &quot;password&quot;in message ? message : {
                    remoteUserId: message.remoteUserId || remoteUserId,
                    message: message,
                    sender: connection.userid
                }, callback || function() {}
                )
            })
        }
        ,
        mPeer.onUserLeft = onUserLeft,
        mPeer.disconnectWith = function(remoteUserId, callback) {
            connection.socket &amp;&amp; connection.socket.emit(&quot;disconnect-with&quot;, remoteUserId, callback || function() {}
            ),
            connection.deletePeer(remoteUserId)
        }
        ,
        connection.broadcasters = [],
        connection.socketOptions = {
            transport: &quot;polling&quot;
        },
        connection.openOrJoin = function(localUserid, password) {
            connection.checkPresence(localUserid, function(isRoomExists, roomid) {
                if (&quot;function&quot; == typeof password &amp;&amp; (password(isRoomExists, roomid),
                password = null ),
                isRoomExists) {
                    connection.sessionid = roomid;
                    var localPeerSdpConstraints = !1
                      , remotePeerSdpConstraints = !1
                      , isOneWay = !!connection.session.oneway
                      , isDataOnly = isData(connection.session);
                    remotePeerSdpConstraints = {
                        OfferToReceiveAudio: connection.sdpConstraints.mandatory.OfferToReceiveAudio,
                        OfferToReceiveVideo: connection.sdpConstraints.mandatory.OfferToReceiveVideo
                    },
                    localPeerSdpConstraints = {
                        OfferToReceiveAudio: isOneWay ? !!connection.session.audio : connection.sdpConstraints.mandatory.OfferToReceiveAudio,
                        OfferToReceiveVideo: isOneWay ? !!connection.session.video || !!connection.session.screen : connection.sdpConstraints.mandatory.OfferToReceiveVideo
                    };
                    var connectionDescription = {
                        remoteUserId: connection.sessionid,
                        message: {
                            newParticipationRequest: !0,
                            isOneWay: isOneWay,
                            isDataOnly: isDataOnly,
                            localPeerSdpConstraints: localPeerSdpConstraints,
                            remotePeerSdpConstraints: remotePeerSdpConstraints
                        },
                        sender: connection.userid,
                        password: password || !1
                    };
                    return void mPeer.onNegotiationNeeded(connectionDescription)
                }
                connection.userid;
                connection.userid = connection.sessionid = localUserid || connection.sessionid,
                connection.userid += &quot;&quot;,
                connection.socket.emit(&quot;changed-uuid&quot;, connection.userid),
                password &amp;&amp; connection.socket.emit(&quot;set-password&quot;, password),
                connection.isInitiator = !0,
                isData(connection.session) || connection.captureUserMedia()
            })
        }
        ,
        connection.open = function(localUserid, isPublicModerator) {
            connection.userid;
            return connection.userid = connection.sessionid = localUserid || connection.sessionid,
            connection.userid += &quot;&quot;,
            connection.isInitiator = !0,
            connectSocket(function() {
                connection.socket.emit(&quot;changed-uuid&quot;, connection.userid),
                1 == isPublicModerator &amp;&amp; connection.becomePublicModerator()
            }),
            isData(connection.session) ? void (&quot;function&quot; == typeof isPublicModerator &amp;&amp; isPublicModerator()) : void connection.captureUserMedia(&quot;function&quot; == typeof isPublicModerator ? isPublicModerator : null )
        }
        ,
        connection.becomePublicModerator = function() {
            connection.isInitiator &amp;&amp; connection.socket.emit(&quot;become-a-public-moderator&quot;)
        }
        ,
        connection.dontMakeMeModerator = function() {
            connection.socket.emit(&quot;dont-make-me-moderator&quot;)
        }
        ,
        connection.deletePeer = function(remoteUserId) {
            if (remoteUserId) {
                if (connection.onleave({
                    userid: remoteUserId,
                    extra: connection.peers[remoteUserId] ? connection.peers[remoteUserId].extra : {}
                }),
                connection.peers[remoteUserId]) {
                    connection.peers[remoteUserId].streams.forEach(function(stream) {
                        stream.stop()
                    });
                    var peer = connection.peers[remoteUserId].peer;
                    if (peer &amp;&amp; &quot;closed&quot; !== peer.iceConnectionState)
                        try {
                            peer.close()
                        } catch (e) {}
                    connection.peers[remoteUserId] &amp;&amp; (connection.peers[remoteUserId].peer = null ,
                    delete connection.peers[remoteUserId])
                }
                if (-1 !== connection.broadcasters.indexOf(remoteUserId)) {
                    var newArray = [];
                    connection.broadcasters.forEach(function(broadcaster) {
                        broadcaster !== remoteUserId &amp;&amp; newArray.push(broadcaster)
                    }),
                    connection.broadcasters = newArray,
                    keepNextBroadcasterOnServer()
                }
            }
        }
        ,
        connection.rejoin = function(connectionDescription) {
            if (!connection.isInitiator &amp;&amp; connectionDescription &amp;&amp; Object.keys(connectionDescription).length) {
                var extra = {};
                connection.peers[connectionDescription.remoteUserId] &amp;&amp; (extra = connection.peers[connectionDescription.remoteUserId].extra,
                connection.deletePeer(connectionDescription.remoteUserId)),
                connectionDescription &amp;&amp; connectionDescription.remoteUserId &amp;&amp; (connection.join(connectionDescription.remoteUserId),
                connection.onReConnecting({
                    userid: connectionDescription.remoteUserId,
                    extra: extra
                }))
            }
        }
        ,
        connection.join = connection.connect = function(remoteUserId, options) {
            connection.sessionid = (remoteUserId ? remoteUserId.sessionid || remoteUserId.remoteUserId || remoteUserId : !1) || connection.sessionid,
            connection.sessionid += &quot;&quot;;
            var localPeerSdpConstraints = !1
              , remotePeerSdpConstraints = !1
              , isOneWay = !1
              , isDataOnly = !1;
            if (remoteUserId &amp;&amp; remoteUserId.session || !remoteUserId || &quot;string&quot; == typeof remoteUserId) {
                var session = remoteUserId ? remoteUserId.session || connection.session : connection.session;
                isOneWay = !!session.oneway,
                isDataOnly = isData(session),
                remotePeerSdpConstraints = {
                    OfferToReceiveAudio: connection.sdpConstraints.mandatory.OfferToReceiveAudio,
                    OfferToReceiveVideo: connection.sdpConstraints.mandatory.OfferToReceiveVideo
                },
                localPeerSdpConstraints = {
                    OfferToReceiveAudio: isOneWay ? !!connection.session.audio : connection.sdpConstraints.mandatory.OfferToReceiveAudio,
                    OfferToReceiveVideo: isOneWay ? !!connection.session.video || !!connection.session.screen : connection.sdpConstraints.mandatory.OfferToReceiveVideo
                }
            }
            options = options || {};
            var cb = function() {}
            ;
            &quot;function&quot; == typeof options &amp;&amp; (cb = options,
            options = {}),
            &quot;undefined&quot; != typeof options.localPeerSdpConstraints &amp;&amp; (localPeerSdpConstraints = options.localPeerSdpConstraints),
            &quot;undefined&quot; != typeof options.remotePeerSdpConstraints &amp;&amp; (remotePeerSdpConstraints = options.remotePeerSdpConstraints),
            &quot;undefined&quot; != typeof options.isOneWay &amp;&amp; (isOneWay = options.isOneWay),
            &quot;undefined&quot; != typeof options.isDataOnly &amp;&amp; (isDataOnly = options.isDataOnly);
            var connectionDescription = {
                remoteUserId: connection.sessionid,
                message: {
                    newParticipationRequest: !0,
                    isOneWay: isOneWay,
                    isDataOnly: isDataOnly,
                    localPeerSdpConstraints: localPeerSdpConstraints,
                    remotePeerSdpConstraints: remotePeerSdpConstraints
                },
                sender: connection.userid,
                password: !1
            };
            return connectSocket(function() {
                connection.peers[connection.sessionid] || (mPeer.onNegotiationNeeded(connectionDescription),
                cb())
            }),
            connectionDescription
        }
        ,
        connection.connectWithAllParticipants = function(remoteUserId) {
            mPeer.onNegotiationNeeded(&quot;connectWithAllParticipants&quot;, remoteUserId || connection.sessionid)
        }
        ,
        connection.removeFromBroadcastersList = function(remoteUserId) {
            mPeer.onNegotiationNeeded(&quot;removeFromBroadcastersList&quot;, remoteUserId || connection.sessionid),
            connection.peers.getAllParticipants(remoteUserId || connection.sessionid).forEach(function(participant) {
                mPeer.onNegotiationNeeded(&quot;dropPeerConnection&quot;, participant),
                connection.deletePeer(participant)
            }),
            connection.attachStreams.forEach(function(stream) {
                stream.stop()
            })
        }
        ,
        connection.getUserMedia = connection.captureUserMedia = function(callback, sessionForced) {
            callback = callback || function() {};
            var session = sessionForced || connection.session;
            return connection.dontCaptureUserMedia || isData(session) ? void callback() : void ((session.audio || session.video || session.screen) &amp;&amp; (session.screen ? connection.getScreenConstraints(function(error, screen_constraints) {
                if (error)
                    throw error;
                connection.invokeGetUserMedia({
                    audio: isAudioPlusTab(connection) ? getAudioScreenConstraints(screen_constraints) : !1,
                    video: screen_constraints,
                    isScreen: !0
                }, function(stream) {
                    if ((session.audio || session.video) &amp;&amp; !isAudioPlusTab(connection)) {
                        var nonScreenSession = {};
                        for (var s in session)
                            &quot;screen&quot; !== s &amp;&amp; (nonScreenSession[s] = session[s]);
                        return void connection.invokeGetUserMedia(sessionForced, callback, nonScreenSession)
                    }
                    callback(stream)
                })
            }) : (session.audio || session.video) &amp;&amp; connection.invokeGetUserMedia(sessionForced, callback, session)))
        }
        ,
        connection.closeBeforeUnload = !0,
        window.addEventListener(&quot;beforeunload&quot;, beforeUnload, !1),
        connection.userid = getRandomString(),
        connection.changeUserId = function(newUserId, callback) {
            connection.userid = newUserId || getRandomString(),
            connection.socket.emit(&quot;changed-uuid&quot;, connection.userid, callback || function() {}
            )
        }
        ,
        connection.extra = {},
        connection.attachStreams = [],
        connection.session = {
            audio: !0,
            video: !0
        },
        connection.enableFileSharing = !1,
        connection.bandwidth = {
            screen: 512,
            audio: 128,
            video: 512
        },
        connection.codecs = {
            audio: &quot;opus&quot;,
            video: &quot;VP9&quot;
        },
        connection.processSdp = function(sdp) {
            return isMobileDevice || isFirefox ? sdp : (sdp = CodecsHandler.setApplicationSpecificBandwidth(sdp, connection.bandwidth, !!connection.session.screen),
            sdp = CodecsHandler.setVideoBitrates(sdp, {
                min: 8 * connection.bandwidth.video * 1024,
                max: 8 * connection.bandwidth.video * 1024
            }),
            sdp = CodecsHandler.setOpusAttributes(sdp, {
                maxaveragebitrate: 8 * connection.bandwidth.audio * 1024,
                maxplaybackrate: 8 * connection.bandwidth.audio * 1024,
                stereo: 1,
                maxptime: 3
            }),
            &quot;VP9&quot; === connection.codecs.video &amp;&amp; (sdp = CodecsHandler.preferVP9(sdp)),
            &quot;H264&quot; === connection.codecs.video &amp;&amp; (sdp = CodecsHandler.removeVPX(sdp)),
            &quot;G722&quot; === connection.codecs.audio &amp;&amp; (sdp = CodecsHandler.removeNonG722(sdp)),
            sdp)
        }
        ,
        &quot;undefined&quot; != typeof CodecsHandler &amp;&amp; (connection.BandwidthHandler = connection.CodecsHandler = CodecsHandler),
        connection.mediaConstraints = {
            audio: {
                mandatory: {},
                optional: [{
                    bandwidth: 8 * connection.bandwidth.audio * 1024 || 1048576
                }]
            },
            video: {
                mandatory: {},
                optional: [{
                    bandwidth: 8 * connection.bandwidth.video * 1024 || 1048576
                }, {
                    facingMode: &quot;user&quot;
                }]
            }
        },
        isFirefox &amp;&amp; (connection.mediaConstraints = {
            audio: !0,
            video: !0
        }),
        forceOptions.useDefaultDevices || isMobileDevice || DetectRTC.load(function() {
            var lastAudioDevice, lastVideoDevice;
            if (DetectRTC.MediaDevices.forEach(function(device) {
                &quot;audioinput&quot; === device.kind &amp;&amp; connection.mediaConstraints.audio !== !1 &amp;&amp; (lastAudioDevice = device),
                &quot;videoinput&quot; === device.kind &amp;&amp; connection.mediaConstraints.video !== !1 &amp;&amp; (lastVideoDevice = device)
            }),
            lastAudioDevice) {
                if (isFirefox)
                    return void (connection.mediaConstraints.audio !== !0 ? connection.mediaConstraints.audio.deviceId = lastAudioDevice.id : connection.mediaConstraints.audio = {
                        deviceId: lastAudioDevice.id
                    });
                1 == connection.mediaConstraints.audio &amp;&amp; (connection.mediaConstraints.audio = {
                    mandatory: {},
                    optional: []
                }),
                connection.mediaConstraints.audio.optional || (connection.mediaConstraints.audio.optional = []);
                var optional = [{
                    sourceId: lastAudioDevice.id
                }];
                connection.mediaConstraints.audio.optional = optional.concat(connection.mediaConstraints.audio.optional)
            }
            if (lastVideoDevice) {
                if (isFirefox)
                    return void (connection.mediaConstraints.video !== !0 ? connection.mediaConstraints.video.deviceId = lastVideoDevice.id : connection.mediaConstraints.video = {
                        deviceId: lastVideoDevice.id
                    });
                1 == connection.mediaConstraints.video &amp;&amp; (connection.mediaConstraints.video = {
                    mandatory: {},
                    optional: []
                }),
                connection.mediaConstraints.video.optional || (connection.mediaConstraints.video.optional = []);
                var optional = [{
                    sourceId: lastVideoDevice.id
                }];
                connection.mediaConstraints.video.optional = optional.concat(connection.mediaConstraints.video.optional)
            }
        }),
        connection.sdpConstraints = {
            mandatory: {
                OfferToReceiveAudio: !0,
                OfferToReceiveVideo: !0
            },
            optional: [{
                VoiceActivityDetection: !1
            }]
        },
        connection.optionalArgument = {
            optional: [{
                DtlsSrtpKeyAgreement: !0
            }, {
                googImprovedWifiBwe: !0
            }, {
                googScreencastMinBitrate: 300
            }, {
                googIPv6: !0
            }, {
                googDscp: !0
            }, {
                googCpuUnderuseThreshold: 55
            }, {
                googCpuOveruseThreshold: 85
            }, {
                googSuspendBelowMinBitrate: !0
            }, {
                googCpuOveruseDetection: !0
            }],
            mandatory: {}
        },
        connection.iceServers = IceServersHandler.getIceServers(connection),
        connection.candidates = {
            host: !0,
            stun: !0,
            turn: !0
        },
        connection.iceProtocols = {
            tcp: !0,
            udp: !0
        },
        connection.onopen = function(event) {
            connection.enableLogs &amp;&amp; webrtcdev.info(&quot;Data connection has been opened between you &amp; &quot;, event.userid)
        }
        ,
        connection.onclose = function(event) {
            connection.enableLogs &amp;&amp; webrtcdev.warn(&quot;Data connection has been closed between you &amp; &quot;, event.userid)
        }
        ,
        connection.onerror = function(error) {
            webrtcdev.log(&quot;========================&quot; , error);
            connection.enableLogs &amp;&amp; webrtcdev.error(error.userid, &quot;data-error&quot;, error)
        }
        ,
        connection.onmessage = function(event) {
            connection.enableLogs &amp;&amp; webrtcdev.debug(&quot;data-message&quot;, event.userid, event.data)
        }
        ,
        connection.send = function(data, remoteUserId) {
            webrtcdev.log(&quot;connection send -&gt; connection.peers&quot; , connection.peers);
            connection.peers.send(data, remoteUserId)
        }
        ,
        connection.close = connection.disconnect = connection.leave = function() {
            beforeUnload(!1, !0)
        }
        ,
        connection.closeEntireSession = function(callback) {
            callback = callback || function() {}
            ,
            connection.socket.emit(&quot;close-entire-session&quot;, function looper() {
                return connection.getAllParticipants().length ? void setTimeout(looper, 100) : (connection.onEntireSessionClosed({
                    sessionid: connection.sessionid,
                    userid: connection.userid,
                    extra: connection.extra
                }),
                void connection.changeUserId(null , function() {
                    connection.close(),
                    callback()
                }))
            })
        }
        ,
        connection.onEntireSessionClosed = function(event) {
            connection.enableLogs &amp;&amp; webrtcdev.info(&quot;Entire session is closed: &quot;, event.sessionid, event.extra)
        }
        ,
        connection.onstream = function(e) {
            var parentNode = connection.videosContainer;
            parentNode.insertBefore(e.mediaElement, parentNode.firstChild),
            e.mediaElement.play(),
            setTimeout(function() {
                e.mediaElement.play()
            }, 5e3)
        }
        ,
        connection.onstreamended = function(e) {
            e.mediaElement || (e.mediaElement = document.getElementById(e.streamid)),
            e.mediaElement &amp;&amp; e.mediaElement.parentNode &amp;&amp; e.mediaElement.parentNode.removeChild(e.mediaElement)
        }
        ,
        connection.direction = &quot;many-to-many&quot;,
        connection.removeStream = function(streamid) {
            var stream;
            return connection.attachStreams.forEach(function(localStream) {
                localStream.id === streamid &amp;&amp; (stream = localStream)
            }),
            stream ? (connection.peers.getAllParticipants().forEach(function(participant) {
                var user = connection.peers[participant];
                try {
                    user.peer.removeStream(stream)
                } catch (e) {}
            }),
            void connection.renegotiate()) : void webrtcdev.warn(&quot;No such stream exists.&quot;, streamid)
        }
        ,
        connection.addStream = function(session, remoteUserId) {
            function gumCallback(stream) {
                session.streamCallback &amp;&amp; session.streamCallback(stream),
                connection.renegotiate(remoteUserId)
            }
            return session.getAudioTracks ? (-1 === connection.attachStreams.indexOf(session) &amp;&amp; (session.streamid || (session.streamid = session.id),
            connection.attachStreams.push(session)),
            void connection.renegotiate(remoteUserId)) : isData(session) ? void connection.renegotiate(remoteUserId) : void ((session.audio || session.video || session.screen) &amp;&amp; (session.screen ? connection.getScreenConstraints(function(error, screen_constraints) {
                return error ? alert(error) : void connection.invokeGetUserMedia({
                    audio: isAudioPlusTab(connection) ? getAudioScreenConstraints(screen_constraints) : !1,
                    video: screen_constraints,
                    isScreen: !0
                }, !session.audio &amp;&amp; !session.video || isAudioPlusTab(connection) ? gumCallback : connection.invokeGetUserMedia(null , gumCallback))
            }) : (session.audio || session.video) &amp;&amp; connection.invokeGetUserMedia(null , gumCallback)))
        }
        ,
        connection.invokeGetUserMedia = function(localMediaConstraints, callback, session) {
            session || (session = connection.session),
            localMediaConstraints || (localMediaConstraints = connection.mediaConstraints),
            getUserMediaHandler({
                onGettingLocalMedia: function(stream) {
                    var videoConstraints = localMediaConstraints.video;
                    videoConstraints &amp;&amp; (videoConstraints.mediaSource || videoConstraints.mozMediaSource ? stream.isScreen = !0 : videoConstraints.mandatory &amp;&amp; videoConstraints.mandatory.chromeMediaSource &amp;&amp; (stream.isScreen = !0)),
                    stream.isScreen || (stream.isVideo = stream.getVideoTracks().length,
                    stream.isAudio = !stream.isVideo &amp;&amp; stream.getAudioTracks().length),
                    mPeer.onGettingLocalMedia(stream),
                    callback &amp;&amp; callback(stream)
                },
                onLocalMediaError: function(error, constraints) {
                    mPeer.onLocalMediaError(error, constraints)
                },
                localMediaConstraints: localMediaConstraints || {
                    audio: session.audio ? localMediaConstraints.audio : !1,
                    video: session.video ? localMediaConstraints.video : !1
                }
            })
        }
        ,
        connection.applyConstraints = function(mediaConstraints, streamid) {
            if (!MediaStreamTrack || !MediaStreamTrack.prototype.applyConstraints)
                return void alert(&quot;track.applyConstraints is NOT supported in your browser.&quot;);
            if (streamid) {
                var stream;
                return connection.streamEvents[streamid] &amp;&amp; (stream = connection.streamEvents[streamid].stream),
                void applyConstraints(stream, mediaConstraints)
            }
            connection.attachStreams.forEach(function(stream) {
                applyConstraints(stream, mediaConstraints)
            })
        }
        ,
        connection.replaceTrack = function(session, remoteUserId, isVideoTrack) {
            function gumCallback(stream) {
                connection.replaceTrack(stream, remoteUserId, isVideoTrack || session.video || session.screen)
            }
            if (session = session || {},
            !RTCPeerConnection.prototype.getSenders)
                return void connection.addStream(session);
            if (session instanceof MediaStreamTrack)
                return void replaceTrack(session, remoteUserId, isVideoTrack);
            if (session instanceof MediaStream)
                return session.getVideoTracks().length &amp;&amp; replaceTrack(session.getVideoTracks()[0], remoteUserId, !0),
                void (session.getAudioTracks().length &amp;&amp; replaceTrack(session.getAudioTracks()[0], remoteUserId, !1));
            if (isData(session))
                throw &quot;connection.replaceTrack requires audio and/or video and/or screen.&quot;;
            (session.audio || session.video || session.screen) &amp;&amp; (session.screen ? connection.getScreenConstraints(function(error, screen_constraints) {
                return error ? alert(error) : void connection.invokeGetUserMedia({
                    audio: isAudioPlusTab(connection) ? getAudioScreenConstraints(screen_constraints) : !1,
                    video: screen_constraints,
                    isScreen: !0
                }, !session.audio &amp;&amp; !session.video || isAudioPlusTab(connection) ? gumCallback : connection.invokeGetUserMedia(null , gumCallback))
            }) : (session.audio || session.video) &amp;&amp; connection.invokeGetUserMedia(null , gumCallback))
        }
        ,
        connection.resetTrack = function(remoteUsersIds, isVideoTrack) {
            remoteUsersIds || (remoteUsersIds = connection.getAllParticipants()),
            &quot;string&quot; == typeof remoteUsersIds &amp;&amp; (remoteUsersIds = [remoteUsersIds]),
            remoteUsersIds.forEach(function(participant) {
                var peer = connection.peers[participant].peer;
                &quot;undefined&quot; != typeof isVideoTrack &amp;&amp; isVideoTrack !== !0 || !peer.lastVideoTrack || connection.replaceTrack(peer.lastVideoTrack, participant, !0),
                &quot;undefined&quot; != typeof isVideoTrack &amp;&amp; isVideoTrack !== !1 || !peer.lastAudioTrack || connection.replaceTrack(peer.lastAudioTrack, participant, !1)
            })
        }
        ,
        connection.renegotiate = function(remoteUserId) {
            return remoteUserId ? void mPeer.renegotiatePeer(remoteUserId) : void connection.peers.getAllParticipants().forEach(function(participant) {
                mPeer.renegotiatePeer(participant)
            })
        }
        ,
        connection.setStreamEndHandler = function(stream, isRemote) {
            stream &amp;&amp; stream.addEventListener &amp;&amp; (isRemote = !!isRemote,
            stream.alreadySetEndHandler || (stream.alreadySetEndHandler = !0,
            stream.addEventListener(&quot;ended&quot;, function() {
                stream.idInstance &amp;&amp; currentUserMediaRequest.remove(stream.idInstance),
                isRemote || delete connection.attachStreams[connection.attachStreams.indexOf(stream)];
                var streamEvent = connection.streamEvents[stream.streamid];
                streamEvent || (streamEvent = {
                    stream: stream,
                    streamid: stream.streamid,
                    type: isRemote ? &quot;remote&quot; : &quot;local&quot;,
                    userid: connection.userid,
                    extra: connection.extra,
                    mediaElement: connection.streamEvents[stream.streamid] ? connection.streamEvents[stream.streamid].mediaElement : null
                }),
                (streamEvent.userid !== connection.userid || &quot;remote&quot; !== streamEvent.type) &amp;&amp; (connection.onstreamended(streamEvent),
                delete connection.streamEvents[stream.streamid])
            }, !1)))
        }
        ,
        connection.onMediaError = function(error, constraints) {
            connection.enableLogs &amp;&amp; webrtcdev.error(error, constraints)
        }
        ,
        connection.addNewBroadcaster = function(broadcasterId, userPreferences) {
            connection.broadcasters.length &amp;&amp; setTimeout(function() {
                mPeer.connectNewParticipantWithAllBroadcasters(broadcasterId, userPreferences, connection.broadcasters.join(&quot;|-,-|&quot;))
            }, 1e4),
            connection.session.oneway || connection.session.broadcast || &quot;many-to-many&quot; !== connection.direction || -1 !== connection.broadcasters.indexOf(broadcasterId) || (connection.broadcasters.push(broadcasterId),
            keepNextBroadcasterOnServer())
        }
        ,
        connection.autoCloseEntireSession = !1,
        connection.filesContainer = connection.videosContainer = document.body || document.documentElement,
        connection.isInitiator = !1,
        connection.shareFile = mPeer.shareFile,
        &quot;undefined&quot; != typeof FileProgressBarHandler &amp;&amp; FileProgressBarHandler.handle(connection),
        &quot;undefined&quot; != typeof TranslationHandler &amp;&amp; TranslationHandler.handle(connection),
        connection.token = getRandomString,
        connection.onNewParticipant = function(participantId, userPreferences) {
            connection.acceptParticipationRequest(participantId, userPreferences)
        }
        ,
        connection.acceptParticipationRequest = function(participantId, userPreferences) {
            userPreferences.successCallback &amp;&amp; (userPreferences.successCallback(),
            delete userPreferences.successCallback),
            mPeer.createNewPeer(participantId, userPreferences)
        }
        ,
        connection.onShiftedModerationControl = function(sender, existingBroadcasters) {
            connection.acceptModerationControl(sender, existingBroadcasters)
        }
        ,
        connection.acceptModerationControl = function(sender, existingBroadcasters) {
            connection.isInitiator = !0,
            connection.broadcasters = existingBroadcasters,
            connection.peers.getAllParticipants().forEach(function(participant) {
                mPeer.onNegotiationNeeded({
                    changedUUID: sender,
                    oldUUID: connection.userid,
                    newUUID: sender
                }, participant)
            }),
            connection.userid = sender,
            connection.socket.emit(&quot;changed-uuid&quot;, connection.userid)
        }
        ,
        connection.shiftModerationControl = function(remoteUserId, existingBroadcasters, firedOnLeave) {
            mPeer.onNegotiationNeeded({
                shiftedModerationControl: !0,
                broadcasters: existingBroadcasters,
                firedOnLeave: !!firedOnLeave
            }, remoteUserId)
        }
        ,
        &quot;undefined&quot; != typeof StreamsHandler &amp;&amp; (connection.StreamsHandler = StreamsHandler),
        connection.onleave = function(userid) {}
        ,
        connection.invokeSelectFileDialog = function(callback) {
            var selector = new FileSelector;
            selector.selectSingleFile(callback)
        }
        ,
        connection.getPublicModerators = function(userIdStartsWith, callback) {
            &quot;function&quot; == typeof userIdStartsWith &amp;&amp; (callback = userIdStartsWith),
            connectSocket(function() {
                connection.socket.emit(&quot;get-public-moderators&quot;, &quot;string&quot; == typeof userIdStartsWith ? userIdStartsWith : &quot;&quot;, callback)
            })
        }
        ,
        connection.onmute = function(e) {
            e &amp;&amp; e.mediaElement &amp;&amp; (&quot;both&quot; === e.muteType || &quot;video&quot; === e.muteType ? (e.mediaElement.src = null ,
            e.mediaElement.pause(),
            e.mediaElement.poster = e.snapshot || &quot;https://cdn.webrtc-experiment.com/images/muted.png&quot;) : &quot;audio&quot; === e.muteType &amp;&amp; (e.mediaElement.muted = !0))
        }
        ,
        connection.onunmute = function(e) {
            e &amp;&amp; e.mediaElement &amp;&amp; e.stream &amp;&amp; (&quot;both&quot; === e.unmuteType || &quot;video&quot; === e.unmuteType ? (e.mediaElement.poster = null ,
            e.mediaElement.src = URL.createObjectURL(e.stream),
            e.mediaElement.play()) : &quot;audio&quot; === e.unmuteType &amp;&amp; (e.mediaElement.muted = !1))
        }
        ,
        connection.onExtraDataUpdated = function(event) {
            event.status = &quot;online&quot;,
            connection.onUserStatusChanged(event, !0)
        }
        ,
        connection.onJoinWithPassword = function(remoteUserId) {
            webrtcdev.warn(remoteUserId, &quot;is password protected. Please join with password.&quot;)
        }
        ,
        connection.onInvalidPassword = function(remoteUserId, oldPassword) {
            webrtcdev.warn(remoteUserId, &quot;is password protected. Please join with valid password. Your old password&quot;, oldPassword, &quot;is wrong.&quot;)
        }
        ,
        connection.onPasswordMaxTriesOver = function(remoteUserId) {
            webrtcdev.warn(remoteUserId, &quot;is password protected. Your max password tries exceeded the limit.&quot;)
        }
        ,
        connection.getAllParticipants = function(sender) {
            return connection.peers.getAllParticipants(sender)
        }
        ,
        &quot;undefined&quot; != typeof StreamsHandler &amp;&amp; (StreamsHandler.onSyncNeeded = function(streamid, action, type) {
            connection.peers.getAllParticipants().forEach(function(participant) {
                mPeer.onNegotiationNeeded({
                    streamid: streamid,
                    action: action,
                    streamSyncNeeded: !0,
                    type: type || &quot;both&quot;
                }, participant)
            })
        }
        ),
        connection.connectSocket = function(callback) {
            connectSocket(callback)
        }
        ,
        connection.socketAutoReConnect = !0,
        connection.closeSocket = function() {
            try {
                io.sockets = {}
            } catch (e) {}
            connection.socket &amp;&amp; (connection.socketAutoReConnect = !1,
            &quot;function&quot; == typeof connection.socket.disconnect &amp;&amp; connection.socket.disconnect(),
            connection.socket = null )
        }
        ,
        connection.getSocket = function(callback) {
            return connection.socket ? callback &amp;&amp; callback(connection.socket) : connectSocket(callback),
            connection.socket
        }
        ,
        connection.getRemoteStreams = mPeer.getRemoteStreams;
        var skipStreams = [&quot;selectFirst&quot;, &quot;selectAll&quot;, &quot;forEach&quot;];
        if (connection.streamEvents = {
            selectFirst: function(options) {
                if (!options) {
                    var firstStream;
                    for (var str in connection.streamEvents)
                        -1 !== skipStreams.indexOf(str) || firstStream || (firstStream = connection.streamEvents[str]);
                    return firstStream
                }
            },
            selectAll: function() {}
        },
        connection.socketURL = &quot;/&quot;,
        connection.socketMessageEvent = &quot;RTCMultiConnection-Message&quot;,
        connection.socketCustomEvent = &quot;RTCMultiConnection-Custom-Message&quot;,
        connection.DetectRTC = DetectRTC,
        connection.setCustomSocketEvent = function(customEvent) {
            customEvent &amp;&amp; (connection.socketCustomEvent = customEvent),
            connection.socket &amp;&amp; connection.socket.emit(&quot;set-custom-socket-event-listener&quot;, connection.socketCustomEvent)
        }
        ,
        connection.getNumberOfBroadcastViewers = function(broadcastId, callback) {
            connection.socket &amp;&amp; broadcastId &amp;&amp; callback &amp;&amp; connection.socket.emit(&quot;get-number-of-users-in-specific-broadcast&quot;, broadcastId, callback)
        }
        ,
        connection.onNumberOfBroadcastViewersUpdated = function(event) {
            connection.enableLogs &amp;&amp; connection.isInitiator &amp;&amp; webrtcdev.info(&quot;Number of broadcast (&quot;, event.broadcastId, &quot;) viewers&quot;, event.numberOfBroadcastViewers)
        }
        ,
        connection.onUserStatusChanged = function(event, dontWriteLogs) {
            connection.enableLogs &amp;&amp; !dontWriteLogs &amp;&amp; webrtcdev.info(event.userid, event.status)
        }
        ,
        connection.getUserMediaHandler = getUserMediaHandler,
        connection.multiPeersHandler = mPeer,
        connection.enableLogs = !0,
        connection.setCustomSocketHandler = function(customSocketHandler) {
            &quot;undefined&quot; != typeof SocketConnection &amp;&amp; (SocketConnection = customSocketHandler)
        }
        ,
        connection.chunkSize = 65 * 1000,
        connection.maxParticipantsAllowed = 50,
        connection.disconnectWith = mPeer.disconnectWith,
        connection.checkPresence = function(remoteUserId, callback) {
            return connection.socket ? void connection.socket.emit(&quot;check-presence&quot;, (remoteUserId || connection.sessionid) + &quot;&quot;, callback) : void connection.connectSocket(function() {
                connection.checkPresence(remoteUserId, callback)
            })
        }
        ,
        connection.onReadyForOffer = function(remoteUserId, userPreferences) {
            connection.multiPeersHandler.createNewPeer(remoteUserId, userPreferences)
        }
        ,
        connection.setUserPreferences = function(userPreferences) {
            return connection.dontAttachStream &amp;&amp; (userPreferences.dontAttachLocalStream = !0),
            connection.dontGetRemoteStream &amp;&amp; (userPreferences.dontGetRemoteStream = !0),
            userPreferences
        }
        ,
        connection.updateExtraData = function() {
            connection.socket.emit(&quot;extra-data-updated&quot;, connection.extra)
        }
        ,
        connection.enableScalableBroadcast = !1,
        connection.maxRelayLimitPerUser = 3,
        connection.dontCaptureUserMedia = !1,
        connection.dontAttachStream = !1,
        connection.dontGetRemoteStream = !1,
        connection.onReConnecting = function(event) {
            connection.enableLogs &amp;&amp; webrtcdev.info(&quot;ReConnecting with&quot;, event.userid, &quot;...&quot;)
        }
        ,
        connection.beforeAddingStream = function(stream) {
            return stream
        }
        ,
        connection.beforeRemovingStream = function(stream) {
            return stream
        }
        ,
        &quot;undefined&quot; != typeof isChromeExtensionAvailable &amp;&amp; (connection.checkIfChromeExtensionAvailable = isChromeExtensionAvailable),
        &quot;undefined&quot; != typeof isFirefoxExtensionAvailable &amp;&amp; (connection.checkIfChromeExtensionAvailable = isFirefoxExtensionAvailable),
        &quot;undefined&quot; != typeof getChromeExtensionStatus &amp;&amp; (connection.getChromeExtensionStatus = getChromeExtensionStatus),
        connection.getScreenConstraints = function(callback, audioPlusTab) {
            isAudioPlusTab(connection, audioPlusTab) &amp;&amp; (audioPlusTab = !0),
            getScreenConstraints(function(error, screen_constraints) {
                error || (screen_constraints = connection.modifyScreenConstraints(screen_constraints),
                callback(error, screen_constraints))
            }, audioPlusTab)
        }
        ,
        connection.modifyScreenConstraints = function(screen_constraints) {
            return screen_constraints
        }
        ,
        connection.onPeerStateChanged = function(state) {
            connection.enableLogs &amp;&amp; -1 !== state.iceConnectionState.search(/closed|failed/gi) &amp;&amp; webrtcdev.error(&quot;Peer connection is closed between you &amp; &quot;, state.userid, state.extra, &quot;state:&quot;, state.iceConnectionState)
        }
        ,
        connection.isOnline = !0,
        listenEventHandler(&quot;online&quot;, function() {
            connection.isOnline = !0
        }),
        listenEventHandler(&quot;offline&quot;, function() {
            connection.isOnline = !1
        }),
        connection.isLowBandwidth = !1,
        navigator &amp;&amp; navigator.connection &amp;&amp; navigator.connection.type &amp;&amp; (connection.isLowBandwidth = -1 !== navigator.connection.type.toString().toLowerCase().search(/wifi|cell/g),
        connection.isLowBandwidth)) {
            if (connection.bandwidth = {
                audio: 30,
                video: 30,
                screen: 30
            },
            connection.mediaConstraints.audio &amp;&amp; connection.mediaConstraints.audio.optional &amp;&amp; connection.mediaConstraints.audio.optional.length) {
                var newArray = [];
                connection.mediaConstraints.audio.optional.forEach(function(opt) {
                    &quot;undefined&quot; == typeof opt.bandwidth &amp;&amp; newArray.push(opt)
                }),
                connection.mediaConstraints.audio.optional = newArray
            }
            if (connection.mediaConstraints.video &amp;&amp; connection.mediaConstraints.video.optional &amp;&amp; connection.mediaConstraints.video.optional.length) {
                var newArray = [];
                connection.mediaConstraints.video.optional.forEach(function(opt) {
                    &quot;undefined&quot; == typeof opt.bandwidth &amp;&amp; newArray.push(opt)
                }),
                connection.mediaConstraints.video.optional = newArray
            }
        }
        connection.getExtraData = function(remoteUserId) {
            if (!remoteUserId)
                throw &quot;remoteUserId is required.&quot;;
            return connection.peers[remoteUserId] ? connection.peers[remoteUserId].extra : {}
        }
        ,
        forceOptions.autoOpenOrJoin &amp;&amp; connection.openOrJoin(connection.sessionid),
        connection.onUserIdAlreadyTaken = function(useridAlreadyTaken, yourNewUserId) {
            connection.enableLogs &amp;&amp; webrtcdev.warn(&quot;Userid already taken.&quot;, useridAlreadyTaken, &quot;Your new userid:&quot;, yourNewUserId),
            connection.join(useridAlreadyTaken)
        }
        ,
        connection.trickleIce = !0,
        connection.onSettingLocalDescription = function(event) {
            if (connection.enableLogs) {
                webrtcdev.info(&apos;Set local description for remote user&apos;, event.userid);
            }
        };
    }
    function SocketConnection(connection, connectCallback) {
        var parameters = &quot;&quot;;
        parameters += &quot;?userid=&quot; + connection.userid,
        parameters += &quot;&amp;msgEvent=&quot; + connection.socketMessageEvent,
        parameters += &quot;&amp;socketCustomEvent=&quot; + connection.socketCustomEvent,
        connection.enableScalableBroadcast &amp;&amp; (parameters += &quot;&amp;enableScalableBroadcast=true&quot;,
        parameters += &quot;&amp;maxRelayLimitPerUser=&quot; + (connection.maxRelayLimitPerUser || 2)),
        connection.socketCustomParameters &amp;&amp; (parameters += connection.socketCustomParameters);
        try {
            io.sockets = {}
        } catch (e) {}
        try {
            connection.socket = io((connection.socketURL || &quot;/&quot;) + parameters)
        } catch (e) {
            connection.socket = io.connect((connection.socketURL || &quot;/&quot;) + parameters, connection.socketOptions)
        }
        var mPeer = connection.multiPeersHandler;
        connection.socket.on(&quot;extra-data-updated&quot;, function(remoteUserId, extra) {
            connection.peers[remoteUserId] &amp;&amp; (connection.peers[remoteUserId].extra = extra,
            connection.onExtraDataUpdated({
                userid: remoteUserId,
                extra: extra
            }))
        }),
        connection.socket.on(connection.socketMessageEvent, function(message) {
            if (message.remoteUserId == connection.userid) {
                if (connection.peers[message.sender] &amp;&amp; connection.peers[message.sender].extra != message.message.extra &amp;&amp; (connection.peers[message.sender].extra = message.extra,
                connection.onExtraDataUpdated({
                    userid: message.sender,
                    extra: message.extra
                })),
                message.message.streamSyncNeeded &amp;&amp; connection.peers[message.sender]) {
                    var stream = connection.streamEvents[message.message.streamid];
                    if (!stream || !stream.stream)
                        return;
                    var action = message.message.action;
                    if (&quot;ended&quot; === action || &quot;stream-removed&quot; === action)
                        return void connection.onstreamended(stream);
                    var type = &quot;both&quot; != message.message.type ? message.message.type : null ;
                    return void stream.stream[action](type)
                }
                if (&quot;connectWithAllParticipants&quot; === message.message)
                    return -1 === connection.broadcasters.indexOf(message.sender) &amp;&amp; connection.broadcasters.push(message.sender),
                    void mPeer.onNegotiationNeeded({
                        allParticipants: connection.getAllParticipants(message.sender)
                    }, message.sender);
                if (&quot;removeFromBroadcastersList&quot; === message.message)
                    return void (-1 !== connection.broadcasters.indexOf(message.sender) &amp;&amp; (delete connection.broadcasters[connection.broadcasters.indexOf(message.sender)],
                    connection.broadcasters = removeNullEntries(connection.broadcasters)));
                if (&quot;dropPeerConnection&quot; === message.message)
                    return void connection.deletePeer(message.sender);
                if (message.message.allParticipants)
                    return -1 === message.message.allParticipants.indexOf(message.sender) &amp;&amp; message.message.allParticipants.push(message.sender),
                    void message.message.allParticipants.forEach(function(participant) {
                        mPeer[connection.peers[participant] ? &quot;renegotiatePeer&quot; : &quot;createNewPeer&quot;](participant, {
                            localPeerSdpConstraints: {
                                OfferToReceiveAudio: connection.sdpConstraints.mandatory.OfferToReceiveAudio,
                                OfferToReceiveVideo: connection.sdpConstraints.mandatory.OfferToReceiveVideo
                            },
                            remotePeerSdpConstraints: {
                                OfferToReceiveAudio: connection.session.oneway ? !!connection.session.audio : connection.sdpConstraints.mandatory.OfferToReceiveAudio,
                                OfferToReceiveVideo: connection.session.oneway ? !!connection.session.video || !!connection.session.screen : connection.sdpConstraints.mandatory.OfferToReceiveVideo
                            },
                            isOneWay: !!connection.session.oneway || &quot;one-way&quot; === connection.direction,
                            isDataOnly: isData(connection.session)
                        })
                    });
                if (message.message.newParticipant) {
                    if (message.message.newParticipant == connection.userid)
                        return;
                    if (connection.peers[message.message.newParticipant])
                        return;
                    return void mPeer.createNewPeer(message.message.newParticipant, message.message.userPreferences || {
                        localPeerSdpConstraints: {
                            OfferToReceiveAudio: connection.sdpConstraints.mandatory.OfferToReceiveAudio,
                            OfferToReceiveVideo: connection.sdpConstraints.mandatory.OfferToReceiveVideo
                        },
                        remotePeerSdpConstraints: {
                            OfferToReceiveAudio: connection.session.oneway ? !!connection.session.audio : connection.sdpConstraints.mandatory.OfferToReceiveAudio,
                            OfferToReceiveVideo: connection.session.oneway ? !!connection.session.video || !!connection.session.screen : connection.sdpConstraints.mandatory.OfferToReceiveVideo
                        },
                        isOneWay: !!connection.session.oneway || &quot;one-way&quot; === connection.direction,
                        isDataOnly: isData(connection.session)
                    })
                }
                if ((message.message.readyForOffer || message.message.addMeAsBroadcaster) &amp;&amp; connection.addNewBroadcaster(message.sender),
                message.message.newParticipationRequest &amp;&amp; message.sender !== connection.userid) {
                    connection.peers[message.sender] &amp;&amp; connection.deletePeer(message.sender);
                    var userPreferences = {
                        extra: message.extra || {},
                        localPeerSdpConstraints: message.message.remotePeerSdpConstraints || {
                            OfferToReceiveAudio: connection.sdpConstraints.mandatory.OfferToReceiveAudio,
                            OfferToReceiveVideo: connection.sdpConstraints.mandatory.OfferToReceiveVideo
                        },
                        remotePeerSdpConstraints: message.message.localPeerSdpConstraints || {
                            OfferToReceiveAudio: connection.session.oneway ? !!connection.session.audio : connection.sdpConstraints.mandatory.OfferToReceiveAudio,
                            OfferToReceiveVideo: connection.session.oneway ? !!connection.session.video || !!connection.session.screen : connection.sdpConstraints.mandatory.OfferToReceiveVideo
                        },
                        isOneWay: &quot;undefined&quot; != typeof message.message.isOneWay ? message.message.isOneWay : !!connection.session.oneway || &quot;one-way&quot; === connection.direction,
                        isDataOnly: &quot;undefined&quot; != typeof message.message.isDataOnly ? message.message.isDataOnly : isData(connection.session),
                        dontGetRemoteStream: &quot;undefined&quot; != typeof message.message.isOneWay ? message.message.isOneWay : !!connection.session.oneway || &quot;one-way&quot; === connection.direction,
                        dontAttachLocalStream: !!message.message.dontGetRemoteStream,
                        connectionDescription: message,
                        successCallback: function() {
                            (&quot;undefined&quot; != typeof message.message.isOneWay ? message.message.isOneWay : !!connection.session.oneway || &quot;one-way&quot; === connection.direction) &amp;&amp; connection.addNewBroadcaster(message.sender, userPreferences),
                            (connection.session.oneway || &quot;one-way&quot; === connection.direction || isData(connection.session)) &amp;&amp; connection.addNewBroadcaster(message.sender, userPreferences)
                        }
                    };
                    return void connection.onNewParticipant(message.sender, userPreferences)
                }
                return message.message.shiftedModerationControl ? void connection.onShiftedModerationControl(message.sender, message.message.broadcasters) : (message.message.changedUUID &amp;&amp; connection.peers[message.message.oldUUID] &amp;&amp; (connection.peers[message.message.newUUID] = connection.peers[message.message.oldUUID],
                delete connection.peers[message.message.oldUUID]),
                message.message.userLeft ? (mPeer.onUserLeft(message.sender),
                void (message.message.autoCloseEntireSession &amp;&amp; connection.leave())) : void mPeer.addNegotiatedMessage(message.message, message.sender))
            }
        }),
        connection.socket.on(&quot;user-left&quot;, function(userid) {
            onUserLeft(userid),
            connection.onUserStatusChanged({
                userid: userid,
                status: &quot;offline&quot;,
                extra: connection.peers[userid] ? connection.peers[userid].extra || {} : {}
            }),
            connection.onleave({
                userid: userid,
                extra: {}
            })
        }),
        connection.socket.on(&quot;connect&quot;, function() {
            return connection.socketAutoReConnect ? (connection.enableLogs &amp;&amp; webrtcdev.info(&quot;socket.io connection is opened.&quot;),
            connection.socket.emit(&quot;extra-data-updated&quot;, connection.extra),
            void (connectCallback &amp;&amp; connectCallback(connection.socket))) : void (connection.socket = null )
        }),
        connection.socket.on(&quot;disconnect&quot;, function() {
            return connection.socketAutoReConnect ? void (connection.enableLogs &amp;&amp; (webrtcdev.info(&quot;socket.io connection is closed&quot;),
            webrtcdev.warn(&quot;socket.io reconnecting&quot;))) : void (connection.socket = null )
        }),
        connection.socket.on(&quot;join-with-password&quot;, function(remoteUserId) {
            connection.onJoinWithPassword(remoteUserId)
        }),
        connection.socket.on(&quot;invalid-password&quot;, function(remoteUserId, oldPassword) {
            connection.onInvalidPassword(remoteUserId, oldPassword)
        }),
        connection.socket.on(&quot;password-max-tries-over&quot;, function(remoteUserId) {
            connection.onPasswordMaxTriesOver(remoteUserId)
        }),
        connection.socket.on(&quot;user-disconnected&quot;, function(remoteUserId) {
            remoteUserId !== connection.userid &amp;&amp; (connection.onUserStatusChanged({
                userid: remoteUserId,
                status: &quot;offline&quot;,
                extra: connection.peers[remoteUserId] ? connection.peers[remoteUserId].extra || {} : {}
            }),
            connection.deletePeer(remoteUserId))
        }),
        connection.socket.on(&quot;user-connected&quot;, function(userid) {
            userid !== connection.userid &amp;&amp; connection.onUserStatusChanged({
                userid: userid,
                status: &quot;online&quot;,
                extra: connection.peers[userid] ? connection.peers[userid].extra || {} : {}
            })
        }),
        connection.socket.on(&quot;closed-entire-session&quot;, function(sessionid, extra) {
            connection.leave(),
            connection.onEntireSessionClosed({
                sessionid: sessionid,
                userid: sessionid,
                extra: extra
            })
        }),
        connection.socket.on(&quot;userid-already-taken&quot;, function(useridAlreadyTaken, yourNewUserId) {
            connection.isInitiator = !1,
            connection.userid = yourNewUserId,
            connection.onUserIdAlreadyTaken(useridAlreadyTaken, yourNewUserId)
        }),
        connection.socket.on(&quot;logs&quot;, function(log) {
            connection.enableLogs &amp;&amp; webrtcdev.debug(&quot;server-logs&quot;, log)
        }),
        connection.socket.on(&quot;number-of-broadcast-viewers-updated&quot;, function(data) {
            connection.onNumberOfBroadcastViewersUpdated(data)
        })
    }
    function MultiPeers(connection) {
        function gumCallback(stream, message, remoteUserId) {
            var streamsToShare = {};
            connection.attachStreams.forEach(function(stream) {
                streamsToShare[stream.streamid] = {
                    isAudio: !!stream.isAudio,
                    isVideo: !!stream.isVideo,
                    isScreen: !!stream.isScreen
                }
            }),
            message.userPreferences.streamsToShare = streamsToShare,
            self.onNegotiationNeeded({
                readyForOffer: !0,
                userPreferences: message.userPreferences
            }, remoteUserId)
        }
        function initFileBufferReader() {
            connection.fbr = new FileBufferReader,
            connection.fbr.onProgress = function(chunk) {
                connection.onFileProgress(chunk)
            }
            ,
            connection.fbr.onBegin = function(file) {
                connection.onFileStart(file)
            }
            ,
            connection.fbr.onEnd = function(file) {
                connection.onFileEnd(file)
            }
        }
        var self = this
          , skipPeers = [&quot;getAllParticipants&quot;, &quot;getLength&quot;, &quot;selectFirst&quot;, &quot;streams&quot;, &quot;send&quot;, &quot;forEach&quot;];
        connection.peers = {
            getLength: function() {
                var numberOfPeers = 0;
                for (var peer in this) {
                    if (skipPeers.indexOf(peer) == -1) {
                        numberOfPeers++;
                    }
                }
                return numberOfPeers;
            },
            selectFirst: function() {
                var firstPeer;
                for (var peer in this) {
                    if (skipPeers.indexOf(peer) == -1) {
                        firstPeer = this[peer];
                    }
                }
                return firstPeer;
            },
            getAllParticipants: function(sender) {
                var allPeers = [];
                for (var peer in this) {
                    if (skipPeers.indexOf(peer) == -1 &amp;&amp; peer != sender) {
                        allPeers.push(peer);
                    }
                }
                return allPeers;
            },
            forEach: function(callbcak) {
                this.getAllParticipants().forEach(function(participant) {
                    callbcak(connection.peers[participant]);
                });
            },
            send: function(data, remoteUserId) {
                var that = this;

                if (!isNull(data.size) &amp;&amp; !isNull(data.type)) {
                    self.shareFile(data, remoteUserId);
                    return;
                }

                if (data.type !== &apos;text&apos; &amp;&amp; !(data instanceof ArrayBuffer) &amp;&amp; !(data instanceof DataView)) {
                    TextSender.send({
                        text: data,
                        channel: this,
                        connection: connection,
                        remoteUserId: remoteUserId
                    });
                    return;
                }

                if (data.type === &apos;text&apos;) {
                    data = JSON.stringify(data);
                }

                if (remoteUserId) {
                    var remoteUser = connection.peers[remoteUserId];
                    if (remoteUser) {
                        if (!remoteUser.channels.length) {
                            connection.peers[remoteUserId].createDataChannel();
                            connection.renegotiate(remoteUserId);
                            setTimeout(function() {
                                that.send(data, remoteUserId);
                            }, 3000);
                            return;
                        }

                        remoteUser.channels.forEach(function(channel) {
                            channel.send(data);
                        });
                        return;
                    }
                }

                this.getAllParticipants().forEach(function(participant) {
                    if (!that[participant].channels.length) {
                        connection.peers[participant].createDataChannel();
                        connection.renegotiate(participant);
                        setTimeout(function() {
                            that[participant].channels.forEach(function(channel) {
                                channel.send(data);
                            });
                        }, 3000);
                        return;
                    }

                    that[participant].channels.forEach(function(channel) {
                        channel.send(data);
                    });
                });
            }
        };

        this.uuid = connection.userid,
        this.getLocalConfig = function(remoteSdp, remoteUserId, userPreferences) {
            if (!userPreferences) {
                userPreferences = {};
            }

            return {
                streamsToShare: userPreferences.streamsToShare || {},
                rtcMultiConnection: connection,
                connectionDescription: userPreferences.connectionDescription,
                userid: remoteUserId,
                localPeerSdpConstraints: userPreferences.localPeerSdpConstraints,
                remotePeerSdpConstraints: userPreferences.remotePeerSdpConstraints,
                dontGetRemoteStream: !!userPreferences.dontGetRemoteStream,
                dontAttachLocalStream: !!userPreferences.dontAttachLocalStream,
                renegotiatingPeer: !!userPreferences.renegotiatingPeer,
                peerRef: userPreferences.peerRef,
                channels: userPreferences.channels || [],
                onLocalSdp: function(localSdp) {
                    self.onNegotiationNeeded(localSdp, remoteUserId);
                },
                onLocalCandidate: function(localCandidate) {
                    localCandidate = OnIceCandidateHandler.processCandidates(connection, localCandidate)
                    if (localCandidate) {
                        self.onNegotiationNeeded(localCandidate, remoteUserId);
                    }
                },
                remoteSdp: remoteSdp,
                onDataChannelMessage: function(message) {

                    if (!fbr &amp;&amp; connection.enableFileSharing) initFileBufferReader();

                    if (typeof message == &apos;string&apos; || !connection.enableFileSharing) {
                        self.onDataChannelMessage(message, remoteUserId);
                        return;
                    }

                    var that = this;

                    if (message instanceof ArrayBuffer || message instanceof DataView) {
                        fbr.convertToObject(message, function(object) {
                            that.onDataChannelMessage(object);
                        });
                        return;
                    }

                    if (message.readyForNextChunk) {
                        fbr.getNextChunk(message.uuid, function(nextChunk, isLastChunk) {
                            connection.peers[remoteUserId].channels.forEach(function(channel) {
                                channel.send(nextChunk);
                            });
                        }, remoteUserId);
                        return;
                    }

                    fbr.addChunk(message, function(promptNextChunk) {
                        connection.peers[remoteUserId].peer.channel.send(promptNextChunk);
                    });
                },
                onDataChannelError: function(error) {
                    self.onDataChannelError(error, remoteUserId);
                },
                onDataChannelOpened: function(channel) {
                    self.onDataChannelOpened(channel, remoteUserId);
                },
                onDataChannelClosed: function(event) {
                    self.onDataChannelClosed(event, remoteUserId);
                },
                onRemoteStream: function(stream) {
                    connection.peers[remoteUserId].streams.push(stream);

                    if (isPluginRTC &amp;&amp; window.PluginRTC) {
                        var mediaElement = document.createElement(&apos;video&apos;);
                        var body = connection.videosContainer;
                        body.insertBefore(mediaElement, body.firstChild);
                        setTimeout(function() {
                            window.PluginRTC.attachMediaStream(mediaElement, stream);
                        }, 3000);
                        return;
                    }

                    self.onGettingRemoteMedia(stream, remoteUserId);
                },
                onRemoteStreamRemoved: function(stream) {
                    self.onRemovingRemoteMedia(stream, remoteUserId);
                },
                onPeerStateChanged: function(states) {
                    self.onPeerStateChanged(states);

                    if (states.iceConnectionState === &apos;new&apos;) {
                        self.onNegotiationStarted(remoteUserId, states);
                    }

                    if (states.iceConnectionState === &apos;connected&apos;) {
                        self.onNegotiationCompleted(remoteUserId, states);
                    }

                    if (states.iceConnectionState.search(/closed|failed/gi) !== -1) {
                        self.onUserLeft(remoteUserId);
                        self.disconnectWith(remoteUserId);
                    }
                }
            };
        };

        this.createNewPeer = function(remoteUserId, userPreferences) {
            if (connection.maxParticipantsAllowed &lt;= connection.getAllParticipants().length) {
                return;
            }

            userPreferences = userPreferences || {};

            if (connection.isInitiator &amp;&amp; !!connection.session.audio &amp;&amp; connection.session.audio === &apos;two-way&apos; &amp;&amp; !userPreferences.streamsToShare) {
                userPreferences.isOneWay = false;
                userPreferences.isDataOnly = false;
                userPreferences.session = connection.session;
            }

            if (!userPreferences.isOneWay &amp;&amp; !userPreferences.isDataOnly) {
                userPreferences.isOneWay = true;
                this.onNegotiationNeeded({
                    enableMedia: true,
                    userPreferences: userPreferences
                }, remoteUserId);
                return;
            }

            userPreferences = connection.setUserPreferences(userPreferences, remoteUserId);

            var localConfig = this.getLocalConfig(null, remoteUserId, userPreferences);
            connection.peers[remoteUserId] = new PeerInitiator(localConfig);
        };

        this.createAnsweringPeer = function(remoteSdp, remoteUserId, userPreferences) {
            userPreferences = connection.setUserPreferences(userPreferences || {}, remoteUserId);

            var localConfig = this.getLocalConfig(remoteSdp, remoteUserId, userPreferences);
            connection.peers[remoteUserId] = new PeerInitiator(localConfig);
        };

        this.renegotiatePeer = function(remoteUserId, userPreferences, remoteSdp) {
            if (!connection.peers[remoteUserId]) {
                if (connection.enableLogs) {
                    webrtcdev.error(&apos;This peer (&apos; + remoteUserId + &apos;) does not exists. Renegotiation skipped.&apos;);
                }
                return;
            }

            if (!userPreferences) {
                userPreferences = {};
            }

            userPreferences.renegotiatingPeer = true;
            userPreferences.peerRef = connection.peers[remoteUserId].peer;
            userPreferences.channels = connection.peers[remoteUserId].channels;

            var localConfig = this.getLocalConfig(remoteSdp, remoteUserId, userPreferences);

            connection.peers[remoteUserId] = new PeerInitiator(localConfig);
        };

        this.replaceTrack = function(track, remoteUserId, isVideoTrack) {
            if (!connection.peers[remoteUserId]) {
                throw &apos;This peer (&apos; + remoteUserId + &apos;) does not exists.&apos;;
            }

            var peer = connection.peers[remoteUserId].peer;

            if (!!peer.getSenders &amp;&amp; typeof peer.getSenders === &apos;function&apos; &amp;&amp; peer.getSenders().length) {
                peer.getSenders().forEach(function(rtpSender) {
                    if (isVideoTrack &amp;&amp; rtpSender.track instanceof VideoStreamTrack) {
                        connection.peers[remoteUserId].peer.lastVideoTrack = rtpSender.track;
                        rtpSender.replaceTrack(track);
                    }

                    if (!isVideoTrack &amp;&amp; rtpSender.track instanceof AudioStreamTrack) {
                        connection.peers[remoteUserId].peer.lastAudioTrack = rtpSender.track;
                        rtpSender.replaceTrack(track);
                    }
                });
                return;
            }

            webrtcdev.warn(&apos;RTPSender.replaceTrack is NOT supported.&apos;);
            this.renegotiatePeer(remoteUserId);
        };

        this.onNegotiationNeeded = function(message, remoteUserId) {};
        this.addNegotiatedMessage = function(message, remoteUserId) {
            if (message.type &amp;&amp; message.sdp) {
                if (message.type == &apos;answer&apos;) {
                    if (connection.peers[remoteUserId]) {
                        connection.peers[remoteUserId].addRemoteSdp(message);
                    }
                }

                if (message.type == &apos;offer&apos;) {
                    if (message.renegotiatingPeer) {
                        this.renegotiatePeer(remoteUserId, null, message);
                    } else {
                        this.createAnsweringPeer(message, remoteUserId);
                    }
                }

                if (connection.enableLogs) {
                    webrtcdev.log(&apos;Remote peer\&apos;s sdp:&apos;, message.sdp);
                }
                return;
            }

            if (message.candidate) {
                if (connection.peers[remoteUserId]) {
                    connection.peers[remoteUserId].addRemoteCandidate(message);
                }

                if (connection.enableLogs) {
                    webrtcdev.log(&apos;Remote peer\&apos;s candidate pairs:&apos;, message.candidate);
                }
                return;
            }

            if (message.enableMedia) {
                if (connection.attachStreams.length || connection.dontCaptureUserMedia) {
                    var streamsToShare = {};
                    connection.attachStreams.forEach(function(stream) {
                        streamsToShare[stream.streamid] = {
                            isAudio: !!stream.isAudio,
                            isVideo: !!stream.isVideo,
                            isScreen: !!stream.isScreen
                        };
                    });
                    message.userPreferences.streamsToShare = streamsToShare;

                    self.onNegotiationNeeded({
                        readyForOffer: true,
                        userPreferences: message.userPreferences
                    }, remoteUserId);
                    return;
                }

                var localMediaConstraints = {};
                var userPreferences = message.userPreferences;
                if (userPreferences.localPeerSdpConstraints.OfferToReceiveAudio) {
                    localMediaConstraints.audio = connection.mediaConstraints.audio;
                }

                if (userPreferences.localPeerSdpConstraints.OfferToReceiveVideo) {
                    localMediaConstraints.video = connection.mediaConstraints.video;
                }

                var session = userPreferences.session || connection.session;

                if (session.oneway &amp;&amp; session.audio &amp;&amp; session.audio === &apos;two-way&apos;) {
                    session = {
                        audio: true
                    };
                }

                if (session.audio || session.video || session.screen) {
                    if (session.screen) {
                        connection.getScreenConstraints(function(error, screen_constraints) {
                            connection.invokeGetUserMedia({
                                audio: isAudioPlusTab(connection) ? getAudioScreenConstraints(screen_constraints) : false,
                                video: screen_constraints,
                                isScreen: true
                            }, (session.audio || session.video) &amp;&amp; !isAudioPlusTab(connection) ? connection.invokeGetUserMedia(null, cb) : cb);
                        });
                    } else if (session.audio || session.video) {
                        connection.invokeGetUserMedia(null, cb, session);
                    }
                }
            }

            if (message.readyForOffer) {
                connection.onReadyForOffer(remoteUserId, message.userPreferences);
            }

            function cb(stream) {
                gumCallback(stream, message, remoteUserId);
            }
        };

        function gumCallback(stream, message, remoteUserId) {
            var streamsToShare = {};
            connection.attachStreams.forEach(function(stream) {
                streamsToShare[stream.streamid] = {
                    isAudio: !!stream.isAudio,
                    isVideo: !!stream.isVideo,
                    isScreen: !!stream.isScreen
                };
            });
            message.userPreferences.streamsToShare = streamsToShare;

            self.onNegotiationNeeded({
                readyForOffer: true,
                userPreferences: message.userPreferences
            }, remoteUserId);
        }

        this.connectNewParticipantWithAllBroadcasters = function(newParticipantId, userPreferences, broadcastersList) {
            broadcastersList = broadcastersList.split(&apos;|-,-|&apos;);
            if (!broadcastersList.length) {
                return;
            }

            var firstBroadcaster = broadcastersList[0];

            self.onNegotiationNeeded({
                newParticipant: newParticipantId,
                userPreferences: userPreferences || false
            }, firstBroadcaster);

            delete broadcastersList[0];

            var array = [];
            broadcastersList.forEach(function(broadcaster) {
                if (broadcaster) {
                    array.push(broadcaster);
                }
            });

            setTimeout(function() {
                self.connectNewParticipantWithAllBroadcasters(newParticipantId, userPreferences, array.join(&apos;|-,-|&apos;));
            }, 10 * 1000);
        };

        this.onGettingRemoteMedia = function(stream, remoteUserId) {};
        this.onRemovingRemoteMedia = function(stream, remoteUserId) {};
        this.onGettingLocalMedia = function(localStream) {};
        this.onLocalMediaError = function(error, constraints) {
            connection.onMediaError(error, constraints);
        };

        var fbr;

        function initFileBufferReader() {
            fbr = new FileBufferReader();
            fbr.onProgress = function(chunk) {
                connection.onFileProgress(chunk);
            };
            fbr.onBegin = function(file) {
                connection.onFileStart(file);
            };
            fbr.onEnd = function(file) {
                connection.onFileEnd(file);
            };
        }

        this.shareFile = function(file, remoteUserId) {

            if (!connection.enableFileSharing) {
                throw &apos;&quot;connection.enableFileSharing&quot; is false.&apos;;
            }

            initFileBufferReader();
            fbr.readAsArrayBuffer(file, function(uuid) {
                var arrayOfUsers = connection.getAllParticipants();

                if (remoteUserId) {
                    arrayOfUsers = [remoteUserId];
                }

                arrayOfUsers.forEach(function(participant) {
                    fbr.getNextChunk(uuid, function(nextChunk) {
                        connection.peers[participant].channels.forEach(function(channel) {
                            // channel.send(nextChunk);

                            /* Altanai patch for trash on file upload 
                            */
                            for(x in webcallpeers){
                                if(webcallpeers[x].userid == selfuserid ){
                                    
                                    for( y in webcallpeers[x].filearray){
                                        if(webcallpeers[x].filearray[y].name == file.name &amp;&amp; webcallpeers[x].filearray[y].status ==&quot;progress&quot;) 
                                         {
                                            console.log(&quot;[ rtcMultiConnectionjs ] filename &quot; , webcallpeers[x].filearray[y].name , &quot; | status &quot; , webcallpeers[x].filearray[y].status);
                                            channel.send(nextChunk)
                                         }   
                                    }
                                }
                            }
                            /*Altanai patch for trash file share ends 
                            */

                        });
                    }, participant);
                });
            }, {
                userid: connection.userid,
                // extra: connection.extra,
                chunkSize: isFirefox ? 15 * 1000 : connection.chunkSize || 0
            });
        };

        if (typeof &apos;TextReceiver&apos; !== &apos;undefined&apos;) {
            var textReceiver = new TextReceiver(connection);
        }

        this.onDataChannelMessage = function(message, remoteUserId) {
            textReceiver.receive(JSON.parse(message), remoteUserId, connection.peers[remoteUserId] ? connection.peers[remoteUserId].extra : {});
        };

        this.onDataChannelClosed = function(event, remoteUserId) {
            event.userid = remoteUserId;
            event.extra = connection.peers[remoteUserId] ? connection.peers[remoteUserId].extra : {};
            connection.onclose(event);
        };

        this.onDataChannelError = function(error, remoteUserId) {
            error.userid = remoteUserId;
            event.extra = connection.peers[remoteUserId] ? connection.peers[remoteUserId].extra : {};
            connection.onerror(error);
        };

        this.onDataChannelOpened = function(channel, remoteUserId) {
            // keep last channel only; we are not expecting parallel/channels channels
            if (connection.peers[remoteUserId].channels.length) {
                connection.peers[remoteUserId].channels = [channel];
                return;
            }

            connection.peers[remoteUserId].channels.push(channel);
            connection.onopen({
                userid: remoteUserId,
                extra: connection.peers[remoteUserId] ? connection.peers[remoteUserId].extra : {},
                channel: channel
            });
        };

        this.onPeerStateChanged = function(state) {
            connection.onPeerStateChanged(state);
        };

        this.onNegotiationStarted = function(remoteUserId, states) {};
        this.onNegotiationCompleted = function(remoteUserId, states) {};

        this.getRemoteStreams = function(remoteUserId) {
            remoteUserId = remoteUserId || connection.peers.getAllParticipants()[0];
            return connection.peers[remoteUserId] ? connection.peers[remoteUserId].streams : [];
        };

        this.isPluginRTC = connection.isPluginRTC = isPluginRTC
    }
    function fireEvent(obj, eventName, args) {
        if (&quot;undefined&quot; != typeof CustomEvent) {
            var eventDetail = {
                arguments: args,
                __exposedProps__: args
            }
              , event = new CustomEvent(eventName,eventDetail);
            obj.dispatchEvent(event)
        }
    }
    function setHarkEvents(connection, streamEvent) {
        if (!connection || !streamEvent)
            throw &quot;Both arguments are required.&quot;;
        if (connection.onspeaking &amp;&amp; connection.onsilence) {
            if (&quot;undefined&quot; == typeof hark)
                throw &quot;hark.js not found.&quot;;
            hark(streamEvent.stream, {
                onspeaking: function() {
                    connection.onspeaking(streamEvent)
                },
                onsilence: function() {
                    connection.onsilence(streamEvent)
                },
                onvolumechange: function(volume, threshold) {
                    connection.onvolumechange &amp;&amp; connection.onvolumechange(merge({
                        volume: volume,
                        threshold: threshold
                    }, streamEvent))
                }
            })
        }
    }
    function setMuteHandlers(connection, streamEvent) {
        streamEvent.stream &amp;&amp; streamEvent.stream &amp;&amp; streamEvent.stream.addEventListener &amp;&amp; (streamEvent.stream.addEventListener(&quot;mute&quot;, function(event) {
            event = connection.streamEvents[streamEvent.streamid],
            event.session = {
                audio: &quot;audio&quot; === event.muteType,
                video: &quot;video&quot; === event.muteType
            },
            connection.onmute(event)
        }, !1),
        streamEvent.stream.addEventListener(&quot;unmute&quot;, function(event) {
            event = connection.streamEvents[streamEvent.streamid],
            event.session = {
                audio: &quot;audio&quot; === event.unmuteType,
                video: &quot;video&quot; === event.unmuteType
            },
            connection.onunmute(event)
        }, !1))
    }
    function getRandomString() {
        if (window.crypto &amp;&amp; window.crypto.getRandomValues &amp;&amp; -1 === navigator.userAgent.indexOf(&quot;Safari&quot;)) {
            for (var a = window.crypto.getRandomValues(new Uint32Array(3)), token = &quot;&quot;, i = 0, l = a.length; l &gt; i; i++)
                token += a[i].toString(36);
            return token
        }
        return (Math.random() * (new Date).getTime()).toString(36).replace(/\./g, &quot;&quot;)
    }
    function getRMCMediaElement(stream, callback, connection) {
        var isAudioOnly = !1;
        stream.getVideoTracks &amp;&amp; !stream.getVideoTracks().length &amp;&amp; (isAudioOnly = !0);
        var mediaElement = document.createElement(isAudioOnly ? &quot;audio&quot; : &quot;video&quot;);
        return isPluginRTC &amp;&amp; window.PluginRTC ? (connection.videosContainer.insertBefore(mediaElement, connection.videosContainer.firstChild),
        void setTimeout(function() {
            window.PluginRTC.attachMediaStream(mediaElement, stream),
            callback(mediaElement)
        }, 1e3)) : (mediaElement[isFirefox ? &quot;mozSrcObject&quot; : &quot;src&quot;] = isFirefox ? stream : window.URL.createObjectURL(stream),
        mediaElement.controls = !0,
        isFirefox &amp;&amp; mediaElement.addEventListener(&quot;ended&quot;, function() {
            if (currentUserMediaRequest.remove(stream.idInstance),
            &quot;local&quot; === stream.type) {
                StreamsHandler.onSyncNeeded(stream.streamid, &quot;ended&quot;),
                connection.attachStreams.forEach(function(aStream, idx) {
                    stream.streamid === aStream.streamid &amp;&amp; delete connection.attachStreams[idx]
                });
                var newStreamsArray = [];
                connection.attachStreams.forEach(function(aStream) {
                    aStream &amp;&amp; newStreamsArray.push(aStream)
                }),
                connection.attachStreams = newStreamsArray;
                var streamEvent = connection.streamEvents[stream.streamid];
                if (streamEvent)
                    return void connection.onstreamended(streamEvent);
                this.parentNode &amp;&amp; this.parentNode.removeChild(this)
            }
        }, !1),
        //mediaElement.play(),
        void callback(mediaElement))
    }
    function listenEventHandler(eventName, eventHandler) {
        window.removeEventListener(eventName, eventHandler),
        window.addEventListener(eventName, eventHandler, !1)
    }
    function removeNullEntries(array) {
        var newArray = [];
        return array.forEach(function(item) {
            item &amp;&amp; newArray.push(item)
        }),
        newArray
    }
    function isData(session) {
        return !session.audio &amp;&amp; !session.video &amp;&amp; !session.screen &amp;&amp; session.data
    }
    function isNull(obj) {
        return &quot;undefined&quot; == typeof obj
    }
    function isString(obj) {
        return &quot;string&quot; == typeof obj
    }
    function isAudioPlusTab(connection, audioPlusTab) {
        return connection.session.audio &amp;&amp; &quot;two-way&quot; === connection.session.audio ? !1 : isFirefox &amp;&amp; audioPlusTab !== !1 ? !0 : !isChrome || 50 &gt; chromeVersion ? !1 : typeof audioPlusTab === !0 ? !0 : &quot;undefined&quot; == typeof audioPlusTab &amp;&amp; connection.session.audio &amp;&amp; connection.session.screen &amp;&amp; !connection.session.video ? (audioPlusTab = !0,
        !0) : !1
    }
    function getAudioScreenConstraints(screen_constraints) {
        return isFirefox ? !0 : isChrome ? {
            mandatory: {
                chromeMediaSource: screen_constraints.mandatory.chromeMediaSource,
                chromeMediaSourceId: screen_constraints.mandatory.chromeMediaSourceId
            }
        } : !1
    }
    function setCordovaAPIs() {
        if (&quot;iOS&quot; === DetectRTC.osName &amp;&amp; &quot;undefined&quot; != typeof cordova &amp;&amp; &quot;undefined&quot; != typeof cordova.plugins &amp;&amp; &quot;undefined&quot; != typeof cordova.plugins.iosrtc) {
            var iosrtc = cordova.plugins.iosrtc;
            window.webkitRTCPeerConnection = iosrtc.RTCPeerConnection,
            window.RTCSessionDescription = iosrtc.RTCSessionDescription,
            window.RTCIceCandidate = iosrtc.RTCIceCandidate,
            window.MediaStream = iosrtc.MediaStream,
            window.MediaStreamTrack = iosrtc.MediaStreamTrack,
            navigator.getUserMedia = navigator.webkitGetUserMedia = iosrtc.getUserMedia,
            iosrtc.debug.enable(&quot;iosrtc*&quot;),
            iosrtc.registerGlobals()
        }
    }
    function setSdpConstraints(config) {
        var sdpConstraints, sdpConstraints_mandatory = {
            OfferToReceiveAudio: !!config.OfferToReceiveAudio,
            OfferToReceiveVideo: !!config.OfferToReceiveVideo
        };
        return sdpConstraints = {
            mandatory: sdpConstraints_mandatory,
            optional: [{
                VoiceActivityDetection: !1
            }]
        },
        navigator.mozGetUserMedia &amp;&amp; firefoxVersion &gt; 34 &amp;&amp; (sdpConstraints = {
            OfferToReceiveAudio: !!config.OfferToReceiveAudio,
            OfferToReceiveVideo: !!config.OfferToReceiveVideo
        }),
        sdpConstraints
    }
    function PeerInitiator(config) {
        if (!RTCPeerConnection) {
            throw &apos;WebRTC 1.0 (RTCPeerConnection) API are NOT available in this browser.&apos;;
        }

        var connection = config.rtcMultiConnection;

        this.extra = config.remoteSdp ? config.remoteSdp.extra : connection.extra;
        this.userid = config.userid;
        this.streams = [];
        this.channels = config.channels || [];
        this.connectionDescription = config.connectionDescription;

        var self = this;

        if (config.remoteSdp) {
            this.connectionDescription = config.remoteSdp.connectionDescription;
        }

        var allRemoteStreams = {};

        defaults.sdpConstraints = setSdpConstraints({
            OfferToReceiveAudio: true,
            OfferToReceiveVideo: true
        });

        var peer;

        var renegotiatingPeer = !!config.renegotiatingPeer;
        if (config.remoteSdp) {
            renegotiatingPeer = !!config.remoteSdp.renegotiatingPeer;
        }

        var localStreams = [];
        connection.attachStreams.forEach(function(stream) {
            if (!!stream) {
                localStreams.push(stream);
            }
        });

        if (!renegotiatingPeer) {
            var iceTransports = &apos;all&apos;;
            if (connection.candidates.turn || connection.candidates.relay) {
                if (!connection.candidates.stun &amp;&amp; !connection.candidates.reflexive &amp;&amp; !connection.candidates.host) {
                    iceTransports = &apos;relay&apos;;
                }
            }

            peer = new RTCPeerConnection(navigator.onLine ? {
                iceServers: connection.iceServers,
                iceTransportPolicy: connection.iceTransportPolicy || iceTransports,
               /* rtcpMuxPolicy: connection.rtcpMuxPolicy || &apos;negotiate&apos;*/
            } : null, window.PluginRTC ? null : connection.optionalArgument);

            if (!connection.iceServers.length) {
                peer = new RTCPeerConnection(null, null);
            }
        } else {
            peer = config.peerRef;
        }

        function getLocalStreams() {
            // if-block is temporarily disabled
            if (false &amp;&amp; &apos;getSenders&apos; in peer &amp;&amp; typeof peer.getSenders === &apos;function&apos;) {
                var streamObject2 = new MediaStream();
                peer.getSenders().forEach(function(sender) {
                    streamObject2.addTrack(sender.track);
                });
                return streamObject2;
            }
            return peer.getLocalStreams();
        }

        peer.onicecandidate = function(event) {
            if (!event.candidate) {
                if (!connection.trickleIce) {
                    var localSdp = peer.localDescription;
                    config.onLocalSdp({
                        type: localSdp.type,
                        sdp: localSdp.sdp,
                        remotePeerSdpConstraints: config.remotePeerSdpConstraints || false,
                        renegotiatingPeer: !!config.renegotiatingPeer || false,
                        connectionDescription: self.connectionDescription,
                        dontGetRemoteStream: !!config.dontGetRemoteStream,
                        extra: connection ? connection.extra : {},
                        streamsToShare: streamsToShare,
                        isFirefoxOffered: isFirefox
                    });
                }
                return;
            }

            if (!connection.trickleIce) return;
            config.onLocalCandidate({
                candidate: event.candidate.candidate,
                sdpMid: event.candidate.sdpMid,
                sdpMLineIndex: event.candidate.sdpMLineIndex
            });
        };

        var isFirefoxOffered = !isFirefox;
        if (config.remoteSdp &amp;&amp; config.remoteSdp.remotePeerSdpConstraints &amp;&amp; config.remoteSdp.remotePeerSdpConstraints.isFirefoxOffered) {
            isFirefoxOffered = true;
        }

        localStreams.forEach(function(localStream) {
            if (config.remoteSdp &amp;&amp; config.remoteSdp.remotePeerSdpConstraints &amp;&amp; config.remoteSdp.remotePeerSdpConstraints.dontGetRemoteStream) {
                return;
            }

            if (config.dontAttachLocalStream) {
                return;
            }

            localStream = connection.beforeAddingStream(localStream);

            if (!localStream) return;

            if (getLocalStreams().forEach) {
                getLocalStreams().forEach(function(stream) {
                    if (localStream &amp;&amp; stream.id == localStream.id) {
                        localStream = null;
                    }
                });
            }

            if (localStream) {
                peer.addStream(localStream);
            }
        });

        peer.oniceconnectionstatechange = peer.onsignalingstatechange = function() {
            var extra = self.extra;
            if (connection.peers[self.userid]) {
                extra = connection.peers[self.userid].extra || extra;
            }

            if (!peer) {
                return;
            }

            config.onPeerStateChanged({
                iceConnectionState: peer.iceConnectionState,
                iceGatheringState: peer.iceGatheringState,
                signalingState: peer.signalingState,
                extra: extra,
                userid: self.userid
            });
        };

        var sdpConstraints = {
            OfferToReceiveAudio: !!localStreams.length,
            OfferToReceiveVideo: !!localStreams.length
        };

        if (config.localPeerSdpConstraints) sdpConstraints = config.localPeerSdpConstraints;

        defaults.sdpConstraints = setSdpConstraints(sdpConstraints);

        var remoteStreamAddEvent = &apos;addstream&apos;;
        if (&apos;ontrack&apos; in peer) {
            // temporarily disabled
            // remoteStreamAddEvent = &apos;track&apos;;
        }

        var streamObject;
        peer.addEventListener(remoteStreamAddEvent, function(event) {
            if (!event) return;
            if (event.streams &amp;&amp; event.streams.length &amp;&amp; !event.stream) {
                if (!streamObject) {
                    streamObject = new MediaStream();
                    return;
                }

                event.streams.forEach(function(stream) {
                    if (stream.getVideoTracks().length) {
                        streamObject.addTrack(stream.getVideoTracks()[0]);
                    }
                    if (stream.getAudioTracks().length) {
                        streamObject.addTrack(stream.getAudioTracks()[0]);
                    }
                });
                event.stream = streamObject;

                if (connection.session.audio &amp;&amp; connection.session.video &amp;&amp; (!streamObject.getVideoTracks().length || !streamObject.getAudioTracks().length)) {
                    return;
                }

                streamObject = null;
            }

            var streamsToShare = {};
            if (config.remoteSdp &amp;&amp; config.remoteSdp.streamsToShare) {
                streamsToShare = config.remoteSdp.streamsToShare;
            } else if (config.streamsToShare) {
                streamsToShare = config.streamsToShare;
            }

            var streamToShare = streamsToShare[event.stream.id];
            if (streamToShare) {
                event.stream.isAudio = streamToShare.isAudio;
                event.stream.isVideo = streamToShare.isVideo;
                event.stream.isScreen = streamToShare.isScreen;
            }
            event.stream.streamid = event.stream.id;
            if (!event.stream.stop) {
                event.stream.stop = function() {
                    if (isFirefox) {
                        var streamEndedEvent = &apos;ended&apos;;

                        if (&apos;oninactive&apos; in event.stream) {
                            streamEndedEvent = &apos;inactive&apos;;
                        }
                        fireEvent(event.stream, streamEndedEvent);
                    }
                };
            }
            allRemoteStreams[event.stream.id] = event.stream;
            config.onRemoteStream(event.stream);
        }, false);

        peer.onremovestream = function(event) {
            event.stream.streamid = event.stream.id;

            if (allRemoteStreams[event.stream.id]) {
                delete allRemoteStreams[event.stream.id];
            }

            config.onRemoteStreamRemoved(event.stream);
        };

        this.addRemoteCandidate = function(remoteCandidate) {
            peer.addIceCandidate(new RTCIceCandidate(remoteCandidate));
        };

        this.addRemoteSdp = function(remoteSdp, cb) {
            remoteSdp.sdp = connection.processSdp(remoteSdp.sdp);
            peer.setRemoteDescription(new RTCSessionDescription(remoteSdp), cb || function() {}, function(error) {
                if (!!connection.enableLogs) {
                    webrtcdev.error(JSON.stringify(error, null, &apos;\t&apos;), &apos;\n&apos;, remoteSdp.type, remoteSdp.sdp);
                }
            });
        };

        var isOfferer = true;

        if (config.remoteSdp) {
            isOfferer = false;
        }

        this.createDataChannel = function() {
            var channel = peer.createDataChannel(&apos;sctp&apos;, {});
            setChannelEvents(channel);
        };

        if (connection.session.data === true &amp;&amp; !renegotiatingPeer) {
            if (!isOfferer) {
                peer.ondatachannel = function(event) {
                    var channel = event.channel;
                    setChannelEvents(channel);
                };
            } else {
                this.createDataChannel();
            }
        }

        if (config.remoteSdp) {
            if (config.remoteSdp.remotePeerSdpConstraints) {
                sdpConstraints = config.remoteSdp.remotePeerSdpConstraints;
            }
            defaults.sdpConstraints = setSdpConstraints(sdpConstraints);
            this.addRemoteSdp(config.remoteSdp, function() {
                createOfferOrAnswer(&apos;createAnswer&apos;);
            });
        }

        function setChannelEvents(channel) {
            // force ArrayBuffer in Firefox; which uses &quot;Blob&quot; by default.
            channel.binaryType = &apos;arraybuffer&apos;;

            channel.onmessage = function(event) {
                config.onDataChannelMessage(event.data);
            };

            channel.onopen = function() {
                config.onDataChannelOpened(channel);
            };

            channel.onerror = function(error) {
                config.onDataChannelError(error);
            };

            channel.onclose = function(event) {
                config.onDataChannelClosed(event);
            };

            channel.internalSend = channel.send;
            channel.send = function(data) {
                if (channel.readyState !== &apos;open&apos;) {
                    return;
                }

                channel.internalSend(data);
            };

            peer.channel = channel;
        }

        if (connection.session.audio == &apos;two-way&apos; || connection.session.video == &apos;two-way&apos; || connection.session.screen == &apos;two-way&apos;) {
            defaults.sdpConstraints = setSdpConstraints({
                OfferToReceiveAudio: connection.session.audio == &apos;two-way&apos; || (config.remoteSdp &amp;&amp; config.remoteSdp.remotePeerSdpConstraints &amp;&amp; config.remoteSdp.remotePeerSdpConstraints.OfferToReceiveAudio),
                OfferToReceiveVideo: connection.session.video == &apos;two-way&apos; || connection.session.screen == &apos;two-way&apos; || (config.remoteSdp &amp;&amp; config.remoteSdp.remotePeerSdpConstraints &amp;&amp; config.remoteSdp.remotePeerSdpConstraints.OfferToReceiveAudio)
            });
        }

        var streamsToShare = {};
        if (getLocalStreams().forEach) {
            getLocalStreams().forEach(function(stream) {
                streamsToShare[stream.streamid] = {
                    isAudio: !!stream.isAudio,
                    isVideo: !!stream.isVideo,
                    isScreen: !!stream.isScreen
                };
            });
        }

        function createOfferOrAnswer(_method) {
            peer[_method](function(localSdp) {
                localSdp.sdp = connection.processSdp(localSdp.sdp);
                peer.setLocalDescription(localSdp, function() {
                    if (!connection.trickleIce) return;
                    config.onLocalSdp({
                        type: localSdp.type,
                        sdp: localSdp.sdp,
                        remotePeerSdpConstraints: config.remotePeerSdpConstraints || false,
                        renegotiatingPeer: !!config.renegotiatingPeer || false,
                        connectionDescription: self.connectionDescription,
                        dontGetRemoteStream: !!config.dontGetRemoteStream,
                        extra: connection ? connection.extra : {},
                        streamsToShare: streamsToShare,
                        isFirefoxOffered: isFirefox
                    });

                    connection.onSettingLocalDescription(self);
                }, function(error) {
                    if (!connection.enableLogs) return;
                    webrtcdev.error(&apos;setLocalDescription error&apos;, error);
                });
            }, function(error) {
                if (!!connection.enableLogs) {
                    webrtcdev.error(&apos;sdp-error&apos;, error);
                }
            }, defaults.sdpConstraints);
        }

        if (isOfferer) {
            createOfferOrAnswer(&apos;createOffer&apos;);
        }

        peer.nativeClose = peer.close;
        peer.close = function() {
            if (!peer) {
                return;
            }

            try {
                if (peer.iceConnectionState.search(/closed|failed/gi) === -1) {
                    peer.getRemoteStreams().forEach(function(stream) {
                        stream.stop();
                    });
                }
                peer.nativeClose();
            } catch (e) {}

            peer = null;
            self.peer = null;
        };

        this.peer = peer;
    }
    function loadIceFrame(callback, skip) {
        if (!loadedIceFrame) {
            if (!skip)
                return loadIceFrame(callback, !0);
            loadedIceFrame = !0;
            var iframe = document.createElement(&quot;iframe&quot;);
            iframe.onload = function() {
                function iFrameLoaderCallback(event) {
                    event.data &amp;&amp; event.data.iceServers &amp;&amp; (callback(event.data.iceServers),
                    window.removeEventListener(&quot;message&quot;, iFrameLoaderCallback))
                }
                iframe.isLoaded = !0,
                listenEventHandler(&quot;message&quot;, iFrameLoaderCallback),
                iframe.contentWindow.postMessage(&quot;get-ice-servers&quot;, &quot;*&quot;)
            }
            ,
            iframe.src = &quot;https://cdn.webrtc-experiment.com/getIceServers/&quot;,
            iframe.style.display = &quot;none&quot;,
            (document.body || document.documentElement).appendChild(iframe)
        }
    }
    function getSTUNObj(stunStr) {
        var urlsParam = &quot;urls&quot;;
        isPluginRTC &amp;&amp; (urlsParam = &quot;url&quot;);
        var obj = {};
        return obj[urlsParam] = stunStr,
        obj
    }
    function getTURNObj(turnStr, username, credential) {
        var urlsParam = &quot;urls&quot;;
        isPluginRTC &amp;&amp; (urlsParam = &quot;url&quot;);
        var obj = {
            username: username,
            credential: credential
        };
        return obj[urlsParam] = turnStr,
        obj
    }
    function getExtenralIceFormatted() {
        var iceServers = [];
        return window.RMCExternalIceServers.forEach(function(ice) {
            ice.urls || (ice.urls = ice.url),
            -1 !== ice.urls.search(&quot;stun|stuns&quot;) &amp;&amp; iceServers.push(getSTUNObj(ice.urls)),
            -1 !== ice.urls.search(&quot;turn|turns&quot;) &amp;&amp; iceServers.push(getTURNObj(ice.urls, ice.username, ice.credential))
        }),
        iceServers
    }
    function setStreamType(constraints, stream) {
        constraints.mandatory &amp;&amp; constraints.mandatory.chromeMediaSource ? stream.isScreen = !0 : constraints.mozMediaSource || constraints.mediaSource ? stream.isScreen = !0 : constraints.video ? stream.isVideo = !0 : constraints.audio &amp;&amp; (stream.isAudio = !0)
    }
    function getUserMediaHandler(options) {
        function streaming(stream, returnBack) {
            setStreamType(options.localMediaConstraints, stream),
            options.onGettingLocalMedia(stream, returnBack),
            stream.addEventListener(&quot;ended&quot;, function() {
                delete currentUserMediaRequest.streams[idInstance],
                currentUserMediaRequest.mutex = !1,
                currentUserMediaRequest.queueRequests.indexOf(options) &amp;&amp; (delete currentUserMediaRequest.queueRequests[currentUserMediaRequest.queueRequests.indexOf(options)],
                currentUserMediaRequest.queueRequests = removeNullEntries(currentUserMediaRequest.queueRequests))
            }, !1),
            currentUserMediaRequest.streams[idInstance] = {
                stream: stream
            },
            currentUserMediaRequest.mutex = !1,
            currentUserMediaRequest.queueRequests.length &amp;&amp; getUserMediaHandler(currentUserMediaRequest.queueRequests.shift())
        }
        if (currentUserMediaRequest.mutex === !0)
            return void currentUserMediaRequest.queueRequests.push(options);
        currentUserMediaRequest.mutex = !0;
        var idInstance = JSON.stringify(options.localMediaConstraints);
        if (currentUserMediaRequest.streams[idInstance])
            streaming(currentUserMediaRequest.streams[idInstance].stream, !0);
        else {
            if (isPluginRTC &amp;&amp; window.PluginRTC) {
                document.createElement(&quot;video&quot;);
                return void window.PluginRTC.getUserMedia({
                    audio: !0,
                    video: !0
                }, function(stream) {
                    stream.streamid = stream.id || getRandomString(),
                    streaming(stream)
                }, function(error) {})
            }
            var isBlackBerry = !!/BB10|BlackBerry/i.test(navigator.userAgent || &quot;&quot;);
            if (isBlackBerry || &quot;undefined&quot; == typeof navigator.mediaDevices || &quot;function&quot; != typeof navigator.mediaDevices.getUserMedia)
                return navigator.getUserMedia = navigator.getUserMedia || navigator.webkitGetUserMedia || navigator.mozGetUserMedia,
                void navigator.getUserMedia(options.localMediaConstraints, function(stream) {
                    stream.streamid = stream.streamid || stream.id || getRandomString(),
                    stream.idInstance = idInstance,
                    streaming(stream)
                }, function(error) {
                    options.onLocalMediaError(error, options.localMediaConstraints)
                });
            navigator.mediaDevices.getUserMedia(options.localMediaConstraints).then(function(stream) {
                stream.streamid = stream.streamid || stream.id || getRandomString(),
                stream.idInstance = idInstance,
                streaming(stream)
            })[&quot;catch&quot;](function(error) {
                options.onLocalMediaError(error, options.localMediaConstraints)
            })
        }
    }
    function onMessageCallback(data) {
        if (&quot;PermissionDeniedError&quot; == data) {
            if (chromeMediaSource = &quot;PermissionDeniedError&quot;,
            screenCallback)
                return screenCallback(&quot;PermissionDeniedError&quot;);
            throw new Error(&quot;PermissionDeniedError&quot;)
        }
        &quot;rtcmulticonnection-extension-loaded&quot; == data &amp;&amp; (chromeMediaSource = &quot;desktop&quot;),
        data.sourceId &amp;&amp; screenCallback &amp;&amp; screenCallback(sourceId = data.sourceId)
    }
    function isChromeExtensionAvailable(callback) {
        if (callback) {
            if (isFirefox)
                return isFirefoxExtensionAvailable(callback);
            if (&quot;desktop&quot; == chromeMediaSource)
                return callback(!0);
            //window.postMessage(&quot;are-you-there&quot;, &quot;*&quot;),
            window.postMessage(&quot;webrtcdev-extension-presence&quot;, &quot;*&quot;),
            setTimeout(function() {
                callback(&quot;screen&quot; == chromeMediaSource ? !1 : !0)
            }, 2e3)
        }
    }
    function isFirefoxExtensionAvailable(callback) {
        function messageCallback(event) {
            var addonMessage = event.data;
            addonMessage &amp;&amp; &quot;undefined&quot; != typeof addonMessage.isScreenCapturingEnabled &amp;&amp; (isFirefoxAddonResponded = !0,
            callback(addonMessage.isScreenCapturingEnabled === !0 ? !0 : !1),
            window.removeEventListener(&quot;message&quot;, messageCallback, !1))
        }
        if (callback) {
            if (!isFirefox)
                return isChromeExtensionAvailable(callback);
            var isFirefoxAddonResponded = !1;
            window.addEventListener(&quot;message&quot;, messageCallback, !1),
            window.postMessage({
                checkIfScreenCapturingEnabled: !0,
                domains: [document.domain]
            }, &quot;*&quot;),
            setTimeout(function() {
                isFirefoxAddonResponded || callback(!0)
            }, 2e3)
        }
    }
/*  function getSourceId(callback, audioPlusTab) {
        alert(&quot; rtc getSourceId&quot;);
        if (!callback)
            throw &apos;&quot;callback&quot; parameter is mandatory.&apos;;
        return sourceId ? (callback(sourceId),
        void (sourceId = null )) : (screenCallback = callback,
        audioPlusTab ? void window.postMessage(&quot;audio-plus-tab&quot;, &quot;*&quot;) : void window.postMessage(&quot;get-sourceId&quot;, &quot;*&quot;))
    }*/
    function getChromeExtensionStatus(extensionid, callback) {
        if (2 != arguments.length &amp;&amp; (callback = extensionid,
        extensionid = window.RMCExtensionID || &quot;ajhifddimkapgcifgcodmmfdlknahffk&quot;),
        isFirefox)
            return callback(&quot;not-chrome&quot;);
        var image = document.createElement(&quot;img&quot;);
        image.src = &quot;chrome-extension://&quot; + extensionid + &quot;/icon.png&quot;,
        image.onload = function() {
            chromeMediaSource = &quot;screen&quot;,
            window.postMessage(&quot;are-you-there&quot;, &quot;*&quot;),
            setTimeout(function() {
                callback(&quot;screen&quot; == chromeMediaSource ? extensionid == extensionid ? &quot;installed-enabled&quot; : &quot;installed-disabled&quot; : &quot;installed-enabled&quot;)
            }, 2e3)
        }
        ,
        image.onerror = function() {
            callback(&quot;not-installed&quot;)
        }
    }
    function getScreenConstraints(callback, audioPlusTab) {
        var firefoxScreenConstraints = {
            mozMediaSource: &quot;window&quot;,
            mediaSource: &quot;window&quot;,
            width: 29999,
            height: 8640
        };
        return isFirefox ? callback(null , firefoxScreenConstraints) : void isChromeExtensionAvailable(function(isAvailable) {
            var screen_constraints = {
                mandatory: {
                    chromeMediaSource: chromeMediaSource,
                    maxWidth: 29999,
                    maxHeight: 8640,
                    minFrameRate: 30,
                    maxFrameRate: 128,
                    minAspectRatio: 1.77
                },
                optional: []
            };
            return &quot;desktop&quot; != chromeMediaSource || sourceId ? (&quot;desktop&quot; == chromeMediaSource &amp;&amp; (screen_constraints.mandatory.chromeMediaSourceId = sourceId),
            void callback(null , screen_constraints)) : void getSourceId(function() {
                screen_constraints.mandatory.chromeMediaSourceId = sourceId,
                callback(&quot;PermissionDeniedError&quot; == sourceId ? sourceId : null , screen_constraints),
                sourceId = null
            }, audioPlusTab)
        })
    }

    function TextReceiver(connection) {
        var content = {};

        function receive(data, userid, extra) {
            // uuid is used to uniquely identify sending instance
            var uuid = data.uuid;
            if (!content[uuid]) {
                content[uuid] = [];
            }

            content[uuid].push(data.message);

            if (data.last) {
                var message = content[uuid].join(&apos;&apos;);
                if (data.isobject) {
                    message = JSON.parse(message);
                }

                // latency detection
                var receivingTime = new Date().getTime();
                var latency = receivingTime - data.sendingTime;

                var e = {
                    data: message,
                    userid: userid,
                    extra: extra,
                    latency: latency
                };

                if (connection.autoTranslateText) {
                    e.original = e.data;
                    connection.Translator.TranslateText(e.data, function(translatedText) {
                        e.data = translatedText;
                        connection.onmessage(e);
                    });
                } else {
                    connection.onmessage(e);
                }

                delete content[uuid];
            }
        }

        return {
            receive: receive
        };
    }

    var isOpera = !!window.opera || navigator.userAgent.indexOf(&quot; OPR/&quot;) &gt;= 0
      , isFirefox = &quot;undefined&quot; != typeof window.InstallTrigger
      , isSafari = Object.prototype.toString.call(window.HTMLElement).indexOf(&quot;Constructor&quot;) &gt; 0
      , isChrome = !!window.chrome &amp;&amp; !isOpera
      , isIE = !!document.documentMode
      , isMobileDevice = !!navigator.userAgent.match(/Android|iPhone|iPad|iPod|BlackBerry|IEMobile/i);
    &quot;undefined&quot; != typeof cordova &amp;&amp; (isMobileDevice = !0,
    isChrome = !0),
    navigator &amp;&amp; navigator.userAgent &amp;&amp; -1 !== navigator.userAgent.indexOf(&quot;Crosswalk&quot;) &amp;&amp; (isMobileDevice = !0,
    isChrome = !0);
    var isPluginRTC = !isMobileDevice &amp;&amp; (isSafari || isIE);
    isPluginRTC &amp;&amp; &quot;undefined&quot; != typeof URL &amp;&amp; (URL.createObjectURL = function() {}
    );
    var chromeVersion = (!!(window.process &amp;&amp; &quot;object&quot; == typeof window.process &amp;&amp; window.process.versions &amp;&amp; window.process.versions[&quot;node-webkit&quot;]),
    50)
      , matchArray = navigator.userAgent.match(/Chrom(e|ium)\/([0-9]+)\./);
    isChrome &amp;&amp; matchArray &amp;&amp; matchArray[2] &amp;&amp; (chromeVersion = parseInt(matchArray[2], 10));
    var firefoxVersion = 50;
    matchArray = navigator.userAgent.match(/Firefox\/(.*)/),
    isFirefox &amp;&amp; matchArray &amp;&amp; matchArray[1] &amp;&amp; (firefoxVersion = parseInt(matchArray[1], 10)),
    window.addEventListener || (window.addEventListener = function(el, eventName, eventHandler) {
        el.attachEvent &amp;&amp; el.attachEvent(&quot;on&quot; + eventName, eventHandler)
    }
    ),
    window.attachEventListener = function(video, type, listener, useCapture) {
        video.addEventListener(type, listener, useCapture)
    }
    ;
    var MediaStream = window.MediaStream;
    &quot;undefined&quot; == typeof MediaStream &amp;&amp; &quot;undefined&quot; != typeof webkitMediaStream &amp;&amp; (MediaStream = webkitMediaStream),
    &quot;undefined&quot; != typeof MediaStream &amp;&amp; (&quot;getVideoTracks&quot;in MediaStream.prototype || (MediaStream.prototype.getVideoTracks = function() {
        if (!this.getTracks)
            return [];
        var tracks = [];
        return this.getTracks.forEach(function(track) {
            -1 !== track.kind.toString().indexOf(&quot;video&quot;) &amp;&amp; tracks.push(track)
        }),
        tracks
    }
    ,
    MediaStream.prototype.getAudioTracks = function() {
        if (!this.getTracks)
            return [];
        var tracks = [];
        return this.getTracks.forEach(function(track) {
            -1 !== track.kind.toString().indexOf(&quot;audio&quot;) &amp;&amp; tracks.push(track)
        }),
        tracks
    }
    ),
    &quot;stop&quot;in MediaStream.prototype || (MediaStream.prototype.stop = function() {
        this.getAudioTracks().forEach(function(track) {
            track.stop &amp;&amp; track.stop()
        }),
        this.getVideoTracks().forEach(function(track) {
            track.stop &amp;&amp; track.stop()
        })
    }
    )),
    function() {
        function getBrowserInfo() {
            var nameOffset, verOffset, ix, nAgt = (navigator.appVersion,
            navigator.userAgent), browserName = navigator.appName, fullVersion = &quot;&quot; + parseFloat(navigator.appVersion), majorVersion = parseInt(navigator.appVersion, 10);
            if (isOpera) {
                browserName = &quot;Opera&quot;;
                try {
                    fullVersion = navigator.userAgent.split(&quot;OPR/&quot;)[1].split(&quot; &quot;)[0],
                    majorVersion = fullVersion.split(&quot;.&quot;)[0]
                } catch (e) {
                    fullVersion = &quot;0.0.0.0&quot;,
                    majorVersion = 0
                }
            } else
                isIE ? (verOffset = nAgt.indexOf(&quot;MSIE&quot;),
                browserName = &quot;IE&quot;,
                fullVersion = nAgt.substring(verOffset + 5)) : isChrome ? (verOffset = nAgt.indexOf(&quot;Chrome&quot;),
                browserName = &quot;Chrome&quot;,
                fullVersion = nAgt.substring(verOffset + 7)) : isSafari ? (verOffset = nAgt.indexOf(&quot;Safari&quot;),
                browserName = &quot;Safari&quot;,
                fullVersion = nAgt.substring(verOffset + 7),
                -1 !== (verOffset = nAgt.indexOf(&quot;Version&quot;)) &amp;&amp; (fullVersion = nAgt.substring(verOffset + 8))) : isFirefox ? (verOffset = nAgt.indexOf(&quot;Firefox&quot;),
                browserName = &quot;Firefox&quot;,
                fullVersion = nAgt.substring(verOffset + 8)) : (nameOffset = nAgt.lastIndexOf(&quot; &quot;) + 1) &lt; (verOffset = nAgt.lastIndexOf(&quot;/&quot;)) &amp;&amp; (browserName = nAgt.substring(nameOffset, verOffset),
                fullVersion = nAgt.substring(verOffset + 1),
                browserName.toLowerCase() === browserName.toUpperCase() &amp;&amp; (browserName = navigator.appName));
            return isEdge &amp;&amp; (browserName = &quot;Edge&quot;,
            fullVersion = parseInt(navigator.userAgent.match(/Edge\/(\d+).(\d+)$/)[2], 10).toString()),
            -1 !== (ix = fullVersion.indexOf(&quot;;&quot;)) &amp;&amp; (fullVersion = fullVersion.substring(0, ix)),
            -1 !== (ix = fullVersion.indexOf(&quot; &quot;)) &amp;&amp; (fullVersion = fullVersion.substring(0, ix)),
            majorVersion = parseInt(&quot;&quot; + fullVersion, 10),
            isNaN(majorVersion) &amp;&amp; (fullVersion = &quot;&quot; + parseFloat(navigator.appVersion),
            majorVersion = parseInt(navigator.appVersion, 10)),
            {
                fullVersion: fullVersion,
                version: majorVersion,
                name: browserName,
                isPrivateBrowsing: !1
            }
        }
        function retry(isDone, next) {
            var currentTrial = 0
              , maxRetry = 50
              , isTimeout = !1
              , id = window.setInterval(function() {
                isDone() &amp;&amp; (window.clearInterval(id),
                next(isTimeout)),
                currentTrial++ &gt; maxRetry &amp;&amp; (window.clearInterval(id),
                isTimeout = !0,
                next(isTimeout))
            }, 10)
        }
        function isIE10OrLater(userAgent) {
            var ua = userAgent.toLowerCase();
            if (0 === ua.indexOf(&quot;msie&quot;) &amp;&amp; 0 === ua.indexOf(&quot;trident&quot;))
                return !1;
            var match = /(?:msie|rv:)\s?([\d\.]+)/.exec(ua);
            return match &amp;&amp; parseInt(match[1], 10) &gt;= 10 ? !0 : !1
        }
        function detectPrivateMode(callback) {
            var isPrivate;
            if (window.webkitRequestFileSystem)
                window.webkitRequestFileSystem(window.TEMPORARY, 1, function() {
                    isPrivate = !1
                }, function(e) {
                    webrtcdev.log(e),
                    isPrivate = !0
                });
            else if (window.indexedDB &amp;&amp; /Firefox/.test(window.navigator.userAgent)) {
                var db;
                try {
                    db = window.indexedDB.open(&quot;test&quot;)
                } catch (e) {
                    isPrivate = !0
                }
                &quot;undefined&quot; == typeof isPrivate &amp;&amp; retry(function() {
                    return &quot;done&quot; === db.readyState ? !0 : !1
                }, function(isTimeout) {
                    isTimeout || (isPrivate = db.result ? !1 : !0)
                })
            } else if (isIE10OrLater(window.navigator.userAgent)) {
                isPrivate = !1;
                try {
                    window.indexedDB || (isPrivate = !0)
                } catch (e) {
                    isPrivate = !0
                }
            } else if (window.localStorage &amp;&amp; /Safari/.test(window.navigator.userAgent)) {
                try {
                    window.localStorage.setItem(&quot;test&quot;, 1)
                } catch (e) {
                    isPrivate = !0
                }
                &quot;undefined&quot; == typeof isPrivate &amp;&amp; (isPrivate = !1,
                window.localStorage.removeItem(&quot;test&quot;))
            }
            retry(function() {
                return &quot;undefined&quot; != typeof isPrivate ? !0 : !1
            }, function(isTimeout) {
                callback(isPrivate)
            })
        }
        function detectDesktopOS() {
            var unknown = &quot;-&quot;
              , nVer = navigator.appVersion
              , nAgt = navigator.userAgent
              , os = unknown
              , clientStrings = [{
                s: &quot;Windows 10&quot;,
                r: /(Windows 10.0|Windows NT 10.0)/
            }, {
                s: &quot;Windows 8.1&quot;,
                r: /(Windows 8.1|Windows NT 6.3)/
            }, {
                s: &quot;Windows 8&quot;,
                r: /(Windows 8|Windows NT 6.2)/
            }, {
                s: &quot;Windows 7&quot;,
                r: /(Windows 7|Windows NT 6.1)/
            }, {
                s: &quot;Windows Vista&quot;,
                r: /Windows NT 6.0/
            }, {
                s: &quot;Windows Server 2003&quot;,
                r: /Windows NT 5.2/
            }, {
                s: &quot;Windows XP&quot;,
                r: /(Windows NT 5.1|Windows XP)/
            }, {
                s: &quot;Windows 2000&quot;,
                r: /(Windows NT 5.0|Windows 2000)/
            }, {
                s: &quot;Windows ME&quot;,
                r: /(Win 9x 4.90|Windows ME)/
            }, {
                s: &quot;Windows 98&quot;,
                r: /(Windows 98|Win98)/
            }, {
                s: &quot;Windows 95&quot;,
                r: /(Windows 95|Win95|Windows_95)/
            }, {
                s: &quot;Windows NT 4.0&quot;,
                r: /(Windows NT 4.0|WinNT4.0|WinNT|Windows NT)/
            }, {
                s: &quot;Windows CE&quot;,
                r: /Windows CE/
            }, {
                s: &quot;Windows 3.11&quot;,
                r: /Win16/
            }, {
                s: &quot;Android&quot;,
                r: /Android/
            }, {
                s: &quot;Open BSD&quot;,
                r: /OpenBSD/
            }, {
                s: &quot;Sun OS&quot;,
                r: /SunOS/
            }, {
                s: &quot;Linux&quot;,
                r: /(Linux|X11)/
            }, {
                s: &quot;iOS&quot;,
                r: /(iPhone|iPad|iPod)/
            }, {
                s: &quot;Mac OS X&quot;,
                r: /Mac OS X/
            }, {
                s: &quot;Mac OS&quot;,
                r: /(MacPPC|MacIntel|Mac_PowerPC|Macintosh)/
            }, {
                s: &quot;QNX&quot;,
                r: /QNX/
            }, {
                s: &quot;UNIX&quot;,
                r: /UNIX/
            }, {
                s: &quot;BeOS&quot;,
                r: /BeOS/
            }, {
                s: &quot;OS/2&quot;,
                r: /OS\/2/
            }, {
                s: &quot;Search Bot&quot;,
                r: /(nuhk|Googlebot|Yammybot|Openbot|Slurp|MSNBot|Ask Jeeves\/Teoma|ia_archiver)/
            }];
            for (var id in clientStrings) {
                var cs = clientStrings[id];
                if (cs.r.test(nAgt)) {
                    os = cs.s;
                    break
                }
            }
            var osVersion = unknown;
            switch (/Windows/.test(os) &amp;&amp; (/Windows (.*)/.test(os) &amp;&amp; (osVersion = /Windows (.*)/.exec(os)[1]),
            os = &quot;Windows&quot;),
            os) {
            case &quot;Mac OS X&quot;:
                /Mac OS X (10[\.\_\d]+)/.test(nAgt) &amp;&amp; (osVersion = /Mac OS X (10[\.\_\d]+)/.exec(nAgt)[1]);
                break;
            case &quot;Android&quot;:
                /Android ([\.\_\d]+)/.test(nAgt) &amp;&amp; (osVersion = /Android ([\.\_\d]+)/.exec(nAgt)[1]);
                break;
            case &quot;iOS&quot;:
                /OS (\d+)_(\d+)_?(\d+)?/.test(nAgt) &amp;&amp; (osVersion = /OS (\d+)_(\d+)_?(\d+)?/.exec(nVer),
                osVersion = osVersion[1] + &quot;.&quot; + osVersion[2] + &quot;.&quot; + (0 | osVersion[3]))
            }
            return {
                osName: os,
                osVersion: osVersion
            }
        }
        function DetectLocalIPAddress(callback) {
            DetectRTC.isWebRTCSupported &amp;&amp; (DetectRTC.isORTCSupported || getIPs(function(ip) {
                callback(ip.match(/^(192\.168\.|169\.254\.|10\.|172\.(1[6-9]|2\d|3[01]))/) ? &quot;Local: &quot; + ip : &quot;Public: &quot; + ip)
            }))
        }
        function getIPs(callback) {
            function handleCandidate(candidate) {
                var ipRegex = /([0-9]{1,3}(\.[0-9]{1,3}){3})/
                  , match = ipRegex.exec(candidate);
                if (!match)
                    return void webrtcdev.warn(&quot;Could not match IP address in&quot;, candidate);
                var ipAddress = match[1];
                void 0 === ipDuplicates[ipAddress] &amp;&amp; callback(ipAddress),
                ipDuplicates[ipAddress] = !0
            }
            var ipDuplicates = {}
              , RTCPeerConnection = window.RTCPeerConnection || window.mozRTCPeerConnection || window.webkitRTCPeerConnection
              , useWebKit = !!window.webkitRTCPeerConnection;
            if (!RTCPeerConnection) {
                var iframe = document.getElementById(&quot;iframe&quot;);
                if (!iframe)
                    throw &quot;NOTE: you need to have an iframe in the page right above the script tag.&quot;;
                var win = iframe.contentWindow;
                RTCPeerConnection = win.RTCPeerConnection || win.mozRTCPeerConnection || win.webkitRTCPeerConnection,
                useWebKit = !!win.webkitRTCPeerConnection
            }
            if (RTCPeerConnection) {
                var servers, mediaConstraints = {
                    optional: [{
                        RtpDataChannels: !0
                    }]
                };
                useWebKit &amp;&amp; (servers = {
                    iceServers: [{
                        urls: &quot;stun:stun.services.mozilla.com&quot;
                    }]
                },
                &quot;undefined&quot; != typeof DetectRTC &amp;&amp; DetectRTC.browser.isFirefox &amp;&amp; DetectRTC.browser.version &lt;= 38 &amp;&amp; (servers[0] = {
                    url: servers[0].urls
                }));
                var pc = new RTCPeerConnection(servers,mediaConstraints);
                pc.onicecandidate = function(ice) {
                    ice.candidate &amp;&amp; handleCandidate(ice.candidate.candidate)
                }
                ,
                pc.createDataChannel(&quot;&quot;),
                pc.createOffer(function(result) {
                    pc.setLocalDescription(result, function() {}, function() {})
                }, function() {}),
                setTimeout(function() {
                    var lines = pc.localDescription.sdp.split(&quot;\n&quot;);
                    lines.forEach(function(line) {
                        0 === line.indexOf(&quot;a=candidate:&quot;) &amp;&amp; handleCandidate(line)
                    })
                }, 1e3)
            }
        }
        function checkDeviceSupport(callback) {
            return canEnumerate ? (!navigator.enumerateDevices &amp;&amp; window.MediaStreamTrack &amp;&amp; window.MediaStreamTrack.getSources &amp;&amp; (navigator.enumerateDevices = window.MediaStreamTrack.getSources.bind(window.MediaStreamTrack)),
            !navigator.enumerateDevices &amp;&amp; navigator.enumerateDevices &amp;&amp; (navigator.enumerateDevices = navigator.enumerateDevices.bind(navigator)),
            navigator.enumerateDevices ? (MediaDevices = [],
            audioInputDevices = [],
            audioOutputDevices = [],
            videoInputDevices = [],
            void navigator.enumerateDevices(function(devices) {
                devices.forEach(function(_device) {
                    var device = {};
                    for (var d in _device)
                        device[d] = _device[d];
                    &quot;audio&quot; === device.kind &amp;&amp; (device.kind = &quot;audioinput&quot;),
                    &quot;video&quot; === device.kind &amp;&amp; (device.kind = &quot;videoinput&quot;);
                    var skip;
                    MediaDevices.forEach(function(d) {
                        d.id === device.id &amp;&amp; d.kind === device.kind &amp;&amp; (skip = !0)
                    }),
                    skip || (device.deviceId || (device.deviceId = device.id),
                    device.id || (device.id = device.deviceId),
                    device.label ? (&quot;videoinput&quot; !== device.kind || isWebsiteHasWebcamPermissions || (isWebsiteHasWebcamPermissions = !0),
                    &quot;audioinput&quot; !== device.kind || isWebsiteHasMicrophonePermissions || (isWebsiteHasMicrophonePermissions = !0)) : (device.label = &quot;Please invoke getUserMedia once.&quot;,
                    &quot;https:&quot; !== location.protocol &amp;&amp; document.domain.search &amp;&amp; -1 === document.domain.search(/localhost|127.0./g) &amp;&amp; (device.label = &quot;HTTPs is required to get label of this &quot; + device.kind + &quot; device.&quot;)),
                    &quot;audioinput&quot; === device.kind &amp;&amp; (hasMicrophone = !0,
                    -1 === audioInputDevices.indexOf(device) &amp;&amp; audioInputDevices.push(device)),
                    &quot;audiooutput&quot; === device.kind &amp;&amp; (hasSpeakers = !0,
                    -1 === audioOutputDevices.indexOf(device) &amp;&amp; audioOutputDevices.push(device)),
                    &quot;videoinput&quot; === device.kind &amp;&amp; (hasWebcam = !0,
                    -1 === videoInputDevices.indexOf(device) &amp;&amp; videoInputDevices.push(device)),
                    -1 === MediaDevices.indexOf(device) &amp;&amp; MediaDevices.push(device))
                }),
                &quot;undefined&quot; != typeof DetectRTC &amp;&amp; (DetectRTC.MediaDevices = MediaDevices,
                DetectRTC.hasMicrophone = hasMicrophone,
                DetectRTC.hasSpeakers = hasSpeakers,
                DetectRTC.hasWebcam = hasWebcam,
                DetectRTC.isWebsiteHasWebcamPermissions = isWebsiteHasWebcamPermissions,
                DetectRTC.isWebsiteHasMicrophonePermissions = isWebsiteHasMicrophonePermissions,
                DetectRTC.audioInputDevices = audioInputDevices,
                DetectRTC.audioOutputDevices = audioOutputDevices,
                DetectRTC.videoInputDevices = videoInputDevices),
                callback &amp;&amp; callback()
            })) : void (callback &amp;&amp; callback())) : void (callback &amp;&amp; callback())
        }
        var browserFakeUserAgent = &quot;Fake/5.0 (FakeOS) AppleWebKit/123 (KHTML, like Gecko) Fake/12.3.4567.89 Fake/123.45&quot;;
        !function(that) {
            &quot;undefined&quot; == typeof window &amp;&amp; (&quot;undefined&quot; == typeof window &amp;&amp; &quot;undefined&quot; != typeof global ? (global.navigator = {
                userAgent: browserFakeUserAgent,
                getUserMedia: function() {}
            },
            that.window = global) : &quot;undefined&quot; == typeof window,
            &quot;undefined&quot; == typeof document &amp;&amp; (that.document = {},
            document.createElement = document.captureStream = document.mozCaptureStream = function() {
                return {}
            }
            ),
            &quot;undefined&quot; == typeof location &amp;&amp; (that.location = {
                protocol: &quot;file:&quot;,
                href: &quot;&quot;,
                hash: &quot;&quot;
            }),
            &quot;undefined&quot; == typeof screen &amp;&amp; (that.screen = {
                width: 0,
                height: 0
            }))
        }(&quot;undefined&quot; != typeof global ? global : window);
        var navigator = window.navigator;
        &quot;undefined&quot; != typeof navigator ? (&quot;undefined&quot; != typeof navigator.webkitGetUserMedia &amp;&amp; (navigator.getUserMedia = navigator.webkitGetUserMedia),
        &quot;undefined&quot; != typeof navigator.mozGetUserMedia &amp;&amp; (navigator.getUserMedia = navigator.mozGetUserMedia)) : navigator = {
            getUserMedia: function() {},
            userAgent: browserFakeUserAgent
        };
        var isMobileDevice = !!/Android|webOS|iPhone|iPad|iPod|BB10|BlackBerry|IEMobile|Opera Mini|Mobile|mobile/i.test(navigator.userAgent || &quot;&quot;)
          , isEdge = !(-1 === navigator.userAgent.indexOf(&quot;Edge&quot;) || !navigator.msSaveOrOpenBlob &amp;&amp; !navigator.msSaveBlob)
          , isOpera = !!window.opera || navigator.userAgent.indexOf(&quot; OPR/&quot;) &gt;= 0
          , isFirefox = &quot;undefined&quot; != typeof window.InstallTrigger
          , isSafari = Object.prototype.toString.call(window.HTMLElement).indexOf(&quot;Constructor&quot;) &gt; 0
          , isChrome = !!window.chrome &amp;&amp; !isOpera
          , isIE = !!document.documentMode &amp;&amp; !isEdge
          , isMobile = {
            Android: function() {
                return navigator.userAgent.match(/Android/i)
            },
            BlackBerry: function() {
                return navigator.userAgent.match(/BlackBerry|BB10/i)
            },
            iOS: function() {
                return navigator.userAgent.match(/iPhone|iPad|iPod/i)
            },
            Opera: function() {
                return navigator.userAgent.match(/Opera Mini/i)
            },
            Windows: function() {
                return navigator.userAgent.match(/IEMobile/i)
            },
            any: function() {
                return isMobile.Android() || isMobile.BlackBerry() || isMobile.iOS() || isMobile.Opera() || isMobile.Windows()
            },
            getOsName: function() {
                var osName = &quot;Unknown OS&quot;;
                return isMobile.Android() &amp;&amp; (osName = &quot;Android&quot;),
                isMobile.BlackBerry() &amp;&amp; (osName = &quot;BlackBerry&quot;),
                isMobile.iOS() &amp;&amp; (osName = &quot;iOS&quot;),
                isMobile.Opera() &amp;&amp; (osName = &quot;Opera Mini&quot;),
                isMobile.Windows() &amp;&amp; (osName = &quot;Windows&quot;),
                osName
            }
        }
          , osName = &quot;Unknown OS&quot;
          , osVersion = &quot;Unknown OS Version&quot;;
        if (isMobile.any())
            osName = isMobile.getOsName();
        else {
            var osInfo = detectDesktopOS();
            osName = osInfo.osName,
            osVersion = osInfo.osVersion
        }
        var isCanvasSupportsStreamCapturing = !1
          , isVideoSupportsStreamCapturing = !1;
        [&quot;captureStream&quot;, &quot;mozCaptureStream&quot;, &quot;webkitCaptureStream&quot;].forEach(function(item) {
            !isCanvasSupportsStreamCapturing &amp;&amp; item in document.createElement(&quot;canvas&quot;) &amp;&amp; (isCanvasSupportsStreamCapturing = !0),
            !isVideoSupportsStreamCapturing &amp;&amp; item in document.createElement(&quot;video&quot;) &amp;&amp; (isVideoSupportsStreamCapturing = !0)
        });
        var MediaDevices = []
          , audioInputDevices = []
          , audioOutputDevices = []
          , videoInputDevices = [];
        navigator.mediaDevices &amp;&amp; navigator.mediaDevices.enumerateDevices &amp;&amp; (navigator.enumerateDevices = function(callback) {
            navigator.mediaDevices.enumerateDevices().then(callback)[&quot;catch&quot;](function() {
                callback([])
            })
        }
        );
        var canEnumerate = !1;
        &quot;undefined&quot; != typeof MediaStreamTrack &amp;&amp; &quot;getSources&quot;in MediaStreamTrack ? canEnumerate = !0 : navigator.mediaDevices &amp;&amp; navigator.mediaDevices.enumerateDevices &amp;&amp; (canEnumerate = !0);
        var hasMicrophone = !1
          , hasSpeakers = !1
          , hasWebcam = !1
          , isWebsiteHasMicrophonePermissions = !1
          , isWebsiteHasWebcamPermissions = !1;
        checkDeviceSupport();
        var DetectRTC = window.DetectRTC || {};
        DetectRTC.browser = getBrowserInfo(),
        detectPrivateMode(function(isPrivateBrowsing) {
            DetectRTC.browser.isPrivateBrowsing = !!isPrivateBrowsing
        }),
        DetectRTC.browser[&quot;is&quot; + DetectRTC.browser.name] = !0;
        var isWebRTCSupported = (!!(window.process &amp;&amp; &quot;object&quot; == typeof window.process &amp;&amp; window.process.versions &amp;&amp; window.process.versions[&quot;node-webkit&quot;]),
        !1);
        [&quot;RTCPeerConnection&quot;, &quot;webkitRTCPeerConnection&quot;, &quot;mozRTCPeerConnection&quot;, &quot;RTCIceGatherer&quot;].forEach(function(item) {
            isWebRTCSupported || item in window &amp;&amp; (isWebRTCSupported = !0)
        }),
        DetectRTC.isWebRTCSupported = isWebRTCSupported,
        DetectRTC.isORTCSupported = &quot;undefined&quot; != typeof RTCIceGatherer;
        var isScreenCapturingSupported = !1;
        DetectRTC.browser.isChrome &amp;&amp; DetectRTC.browser.version &gt;= 35 ? isScreenCapturingSupported = !0 : DetectRTC.browser.isFirefox &amp;&amp; DetectRTC.browser.version &gt;= 34 &amp;&amp; (isScreenCapturingSupported = !0),
        &quot;https:&quot; !== location.protocol &amp;&amp; (isScreenCapturingSupported = !1),
        DetectRTC.isScreenCapturingSupported = isScreenCapturingSupported;
        var webAudio = {
            isSupported: !1,
            isCreateMediaStreamSourceSupported: !1
        };
        [&quot;AudioContext&quot;, &quot;webkitAudioContext&quot;, &quot;mozAudioContext&quot;, &quot;msAudioContext&quot;].forEach(function(item) {
            webAudio.isSupported || item in window &amp;&amp; (webAudio.isSupported = !0,
            &quot;createMediaStreamSource&quot;in window[item].prototype &amp;&amp; (webAudio.isCreateMediaStreamSourceSupported = !0))
        }),
        DetectRTC.isAudioContextSupported = webAudio.isSupported,
        DetectRTC.isCreateMediaStreamSourceSupported = webAudio.isCreateMediaStreamSourceSupported;
        var isRtpDataChannelsSupported = !1;
        DetectRTC.browser.isChrome &amp;&amp; DetectRTC.browser.version &gt; 31 &amp;&amp; (isRtpDataChannelsSupported = !0),
        DetectRTC.isRtpDataChannelsSupported = isRtpDataChannelsSupported;
        var isSCTPSupportd = !1;
        DetectRTC.browser.isFirefox &amp;&amp; DetectRTC.browser.version &gt; 28 ? isSCTPSupportd = !0 : DetectRTC.browser.isChrome &amp;&amp; DetectRTC.browser.version &gt; 25 ? isSCTPSupportd = !0 : DetectRTC.browser.isOpera &amp;&amp; DetectRTC.browser.version &gt;= 11 &amp;&amp; (isSCTPSupportd = !0),
        DetectRTC.isSctpDataChannelsSupported = isSCTPSupportd,
        DetectRTC.isMobileDevice = isMobileDevice;
        var isGetUserMediaSupported = !1;
        navigator.getUserMedia ? isGetUserMediaSupported = !0 : navigator.mediaDevices &amp;&amp; navigator.mediaDevices.getUserMedia &amp;&amp; (isGetUserMediaSupported = !0),
        DetectRTC.browser.isChrome &amp;&amp; DetectRTC.browser.version &gt;= 46 &amp;&amp; &quot;https:&quot; !== location.protocol &amp;&amp; (DetectRTC.isGetUserMediaSupported = &quot;Requires HTTPs&quot;),
        DetectRTC.isGetUserMediaSupported = isGetUserMediaSupported,
        DetectRTC.osName = osName,
        DetectRTC.osVersion = osVersion;
        var displayResolution = &quot;&quot;;
        if (screen.width) {
            var width = screen.width ? screen.width : &quot;&quot;
              , height = screen.height ? screen.height : &quot;&quot;;
            displayResolution += &quot;&quot; + width + &quot; x &quot; + height
        }
        DetectRTC.displayResolution = displayResolution,
        DetectRTC.isCanvasSupportsStreamCapturing = isCanvasSupportsStreamCapturing,
        DetectRTC.isVideoSupportsStreamCapturing = isVideoSupportsStreamCapturing,
        DetectRTC.DetectLocalIPAddress = DetectLocalIPAddress,
        DetectRTC.isWebSocketsSupported = &quot;WebSocket&quot;in window &amp;&amp; 2 === window.WebSocket.CLOSING,
        DetectRTC.isWebSocketsBlocked = !DetectRTC.isWebSocketsSupported,
        DetectRTC.checkWebSocketsSupport = function(callback) {
            callback = callback || function() {}
            ;
            try {
                var websocket = new WebSocket(&quot;wss://echo.websocket.org:443/&quot;);
                websocket.onopen = function() {
                    DetectRTC.isWebSocketsBlocked = !1,
                    callback(),
                    websocket.close(),
                    websocket = null
                }
                ,
                websocket.onerror = function() {
                    DetectRTC.isWebSocketsBlocked = !0,
                    callback()
                }
            } catch (e) {
                DetectRTC.isWebSocketsBlocked = !0,
                callback()
            }
        }
        ,
        DetectRTC.load = function(callback) {
            callback = callback || function() {}
            ,
            checkDeviceSupport(callback)
        }
        ,
        DetectRTC.MediaDevices = MediaDevices,
        DetectRTC.hasMicrophone = hasMicrophone,
        DetectRTC.hasSpeakers = hasSpeakers,
        DetectRTC.hasWebcam = hasWebcam,
        DetectRTC.isWebsiteHasWebcamPermissions = isWebsiteHasWebcamPermissions,
        DetectRTC.isWebsiteHasMicrophonePermissions = isWebsiteHasMicrophonePermissions,
        DetectRTC.audioInputDevices = audioInputDevices,
        DetectRTC.audioOutputDevices = audioOutputDevices,
        DetectRTC.videoInputDevices = videoInputDevices;
        var isSetSinkIdSupported = !1;
        &quot;setSinkId&quot;in document.createElement(&quot;video&quot;) &amp;&amp; (isSetSinkIdSupported = !0),
        DetectRTC.isSetSinkIdSupported = isSetSinkIdSupported;
        var isRTPSenderReplaceTracksSupported = !1;
        DetectRTC.browser.isFirefox &amp;&amp; &quot;undefined&quot; != typeof mozRTCPeerConnection ? &quot;getSenders&quot;in mozRTCPeerConnection.prototype &amp;&amp; (isRTPSenderReplaceTracksSupported = !0) : DetectRTC.browser.isChrome &amp;&amp; &quot;undefined&quot; != typeof webkitRTCPeerConnection &amp;&amp; &quot;getSenders&quot;in webkitRTCPeerConnection.prototype &amp;&amp; (isRTPSenderReplaceTracksSupported = !0),
        DetectRTC.isRTPSenderReplaceTracksSupported = isRTPSenderReplaceTracksSupported;
        var isRemoteStreamProcessingSupported = !1;
        DetectRTC.browser.isFirefox &amp;&amp; DetectRTC.browser.version &gt; 38 &amp;&amp; (isRemoteStreamProcessingSupported = !0),
        DetectRTC.isRemoteStreamProcessingSupported = isRemoteStreamProcessingSupported;
        var isApplyConstraintsSupported = !1;
        &quot;undefined&quot; != typeof MediaStreamTrack &amp;&amp; &quot;applyConstraints&quot;in MediaStreamTrack.prototype &amp;&amp; (isApplyConstraintsSupported = !0),
        DetectRTC.isApplyConstraintsSupported = isApplyConstraintsSupported;
        var isMultiMonitorScreenCapturingSupported = !1;
        DetectRTC.browser.isFirefox &amp;&amp; DetectRTC.browser.version &gt;= 43 &amp;&amp; (isMultiMonitorScreenCapturingSupported = !0),
        DetectRTC.isMultiMonitorScreenCapturingSupported = isMultiMonitorScreenCapturingSupported,
        DetectRTC.isPromisesSupported = !!(&quot;Promise&quot;in window),
        &quot;undefined&quot; == typeof DetectRTC &amp;&amp; (window.DetectRTC = {});
        var MediaStream = window.MediaStream;
        &quot;undefined&quot; == typeof MediaStream &amp;&amp; &quot;undefined&quot; != typeof webkitMediaStream &amp;&amp; (MediaStream = webkitMediaStream),
        &quot;undefined&quot; != typeof MediaStream ? DetectRTC.MediaStream = Object.keys(MediaStream.prototype) : DetectRTC.MediaStream = !1,
        &quot;undefined&quot; != typeof MediaStreamTrack ? DetectRTC.MediaStreamTrack = Object.keys(MediaStreamTrack.prototype) : DetectRTC.MediaStreamTrack = !1;
        var RTCPeerConnection = window.RTCPeerConnection || window.mozRTCPeerConnection || window.webkitRTCPeerConnection;
        &quot;undefined&quot; != typeof RTCPeerConnection ? DetectRTC.RTCPeerConnection = Object.keys(RTCPeerConnection.prototype) : DetectRTC.RTCPeerConnection = !1,
        window.DetectRTC = DetectRTC,
        &quot;undefined&quot; != typeof module &amp;&amp; (module.exports = DetectRTC),
        &quot;function&quot; == typeof define &amp;&amp; define.amd &amp;&amp; define(&quot;DetectRTC&quot;, [], function() {
            return DetectRTC
        })
    }(),
    document.addEventListener(&quot;deviceready&quot;, setCordovaAPIs, !1),
    setCordovaAPIs();
    var RTCPeerConnection, defaults = {};
    &quot;undefined&quot; != typeof mozRTCPeerConnection ? RTCPeerConnection = mozRTCPeerConnection : &quot;undefined&quot; != typeof webkitRTCPeerConnection ? RTCPeerConnection = webkitRTCPeerConnection : &quot;undefined&quot; != typeof window.RTCPeerConnection &amp;&amp; (RTCPeerConnection = window.RTCPeerConnection);
    var RTCSessionDescription = window.RTCSessionDescription || window.mozRTCSessionDescription
      , RTCIceCandidate = window.RTCIceCandidate || window.mozRTCIceCandidate
      , MediaStreamTrack = window.MediaStreamTrack;
    window.onPluginRTCInitialized = function() {
        MediaStreamTrack = window.PluginRTC.MediaStreamTrack,
        RTCPeerConnection = window.PluginRTC.RTCPeerConnection,
        RTCIceCandidate = window.PluginRTC.RTCIceCandidate,
        RTCSessionDescription = window.PluginRTC.RTCSessionDescription
    }
    ,
    &quot;undefined&quot; != typeof window.PluginRTC &amp;&amp; window.onPluginRTCInitialized();
    var CodecsHandler = function() {
        function removeVPX(sdp) {
            if (!sdp || &quot;string&quot; != typeof sdp)
                throw &quot;Invalid arguments.&quot;;
            return sdp = sdp.replace(&quot;a=rtpmap:100 VP8/90000\r\n&quot;, &quot;&quot;),
            sdp = sdp.replace(&quot;a=rtpmap:101 VP9/90000\r\n&quot;, &quot;&quot;),
            sdp = sdp.replace(/m=video ([0-9]+) RTP\/SAVPF ([0-9 ]*) 100/g, &quot;m=video $1 RTP/SAVPF $2&quot;),
            sdp = sdp.replace(/m=video ([0-9]+) RTP\/SAVPF ([0-9 ]*) 101/g, &quot;m=video $1 RTP/SAVPF $2&quot;),
            sdp = sdp.replace(/m=video ([0-9]+) RTP\/SAVPF 100([0-9 ]*)/g, &quot;m=video $1 RTP/SAVPF$2&quot;),
            sdp = sdp.replace(/m=video ([0-9]+) RTP\/SAVPF 101([0-9 ]*)/g, &quot;m=video $1 RTP/SAVPF$2&quot;),
            sdp = sdp.replace(&quot;a=rtcp-fb:120 nack\r\n&quot;, &quot;&quot;),
            sdp = sdp.replace(&quot;a=rtcp-fb:120 nack pli\r\n&quot;, &quot;&quot;),
            sdp = sdp.replace(&quot;a=rtcp-fb:120 ccm fir\r\n&quot;, &quot;&quot;),
            sdp = sdp.replace(&quot;a=rtcp-fb:101 nack\r\n&quot;, &quot;&quot;),
            sdp = sdp.replace(&quot;a=rtcp-fb:101 nack pli\r\n&quot;, &quot;&quot;),
            sdp = sdp.replace(&quot;a=rtcp-fb:101 ccm fir\r\n&quot;, &quot;&quot;)
        }
        function disableNACK(sdp) {
            if (!sdp || &quot;string&quot; != typeof sdp)
                throw &quot;Invalid arguments.&quot;;
            return sdp = sdp.replace(&quot;a=rtcp-fb:126 nack\r\n&quot;, &quot;&quot;),
            sdp = sdp.replace(&quot;a=rtcp-fb:126 nack pli\r\n&quot;, &quot;a=rtcp-fb:126 pli\r\n&quot;),
            sdp = sdp.replace(&quot;a=rtcp-fb:97 nack\r\n&quot;, &quot;&quot;),
            sdp = sdp.replace(&quot;a=rtcp-fb:97 nack pli\r\n&quot;, &quot;a=rtcp-fb:97 pli\r\n&quot;)
        }
        function prioritize(codecMimeType, peer) {
            if (peer &amp;&amp; peer.getSenders &amp;&amp; peer.getSenders().length) {
                if (!codecMimeType || &quot;string&quot; != typeof codecMimeType)
                    throw &quot;Invalid arguments.&quot;;
                peer.getSenders().forEach(function(sender) {
                    for (var params = sender.getParameters(), i = 0; i &lt; params.codecs.length; i++)
                        if (params.codecs[i].mimeType == codecMimeType) {
                            params.codecs.unshift(params.codecs.splice(i, 1));
                            break
                        }
                    sender.setParameters(params)
                })
            }
        }
        function removeNonG722(sdp) {
            return sdp.replace(/m=audio ([0-9]+) RTP\/SAVPF ([0-9 ]*)/g, &quot;m=audio $1 RTP/SAVPF 9&quot;)
        }
        function setBAS(sdp, bandwidth, isScreen) {
            return bandwidth ? &quot;undefined&quot; != typeof isFirefox &amp;&amp; isFirefox ? sdp : isMobileDevice ? sdp : (isScreen &amp;&amp; (bandwidth.screen ? bandwidth.screen &lt; 300 &amp;&amp; webrtcdev.warn(&quot;It seems that you are using wrong bandwidth value for screen. Screen sharing is expected to fail.&quot;) : webrtcdev.warn(&quot;It seems that you are not using bandwidth for screen. Screen sharing is expected to fail.&quot;)),
            bandwidth.screen &amp;&amp; isScreen &amp;&amp; (sdp = sdp.replace(/b=AS([^\r\n]+\r\n)/g, &quot;&quot;),
            sdp = sdp.replace(/a=mid:video\r\n/g, &quot;a=mid:video\r\nb=AS:&quot; + bandwidth.screen + &quot;\r\n&quot;)),
            (bandwidth.audio || bandwidth.video || bandwidth.data) &amp;&amp; (sdp = sdp.replace(/b=AS([^\r\n]+\r\n)/g, &quot;&quot;)),
            bandwidth.audio &amp;&amp; (sdp = sdp.replace(/a=mid:audio\r\n/g, &quot;a=mid:audio\r\nb=AS:&quot; + bandwidth.audio + &quot;\r\n&quot;)),
            bandwidth.video &amp;&amp; (sdp = sdp.replace(/a=mid:video\r\n/g, &quot;a=mid:video\r\nb=AS:&quot; + (isScreen ? bandwidth.screen : bandwidth.video) + &quot;\r\n&quot;)),
            sdp) : sdp
        }
        function findLine(sdpLines, prefix, substr) {
            return findLineInRange(sdpLines, 0, -1, prefix, substr)
        }
        function findLineInRange(sdpLines, startLine, endLine, prefix, substr) {
            for (var realEndLine = -1 !== endLine ? endLine : sdpLines.length, i = startLine; realEndLine &gt; i; ++i)
                if (0 === sdpLines[i].indexOf(prefix) &amp;&amp; (!substr || -1 !== sdpLines[i].toLowerCase().indexOf(substr.toLowerCase())))
                    return i;
            return null
        }
        function getCodecPayloadType(sdpLine) {
            var pattern = new RegExp(&quot;a=rtpmap:(\\d+) \\w+\\/\\d+&quot;)
              , result = sdpLine.match(pattern);
            return result &amp;&amp; 2 === result.length ? result[1] : null
        }
        function setVideoBitrates(sdp, params) {
            if (isMobileDevice)
                return sdp;
            params = params || {};
            var vp8Payload, xgoogle_min_bitrate = params.min, xgoogle_max_bitrate = params.max, sdpLines = sdp.split(&quot;\r\n&quot;), vp8Index = findLine(sdpLines, &quot;a=rtpmap&quot;, &quot;VP8/90000&quot;);
            if (vp8Index &amp;&amp; (vp8Payload = getCodecPayloadType(sdpLines[vp8Index])),
            !vp8Payload)
                return sdp;
            var rtxPayload, rtxIndex = findLine(sdpLines, &quot;a=rtpmap&quot;, &quot;rtx/90000&quot;);
            if (rtxIndex &amp;&amp; (rtxPayload = getCodecPayloadType(sdpLines[rtxIndex])),
            !rtxIndex)
                return sdp;
            var rtxFmtpLineIndex = findLine(sdpLines, &quot;a=fmtp:&quot; + rtxPayload.toString());
            if (null !== rtxFmtpLineIndex) {
                var appendrtxNext = &quot;\r\n&quot;;
                appendrtxNext += &quot;a=fmtp:&quot; + vp8Payload + &quot; x-google-min-bitrate=&quot; + (xgoogle_min_bitrate || &quot;228&quot;) + &quot;; x-google-max-bitrate=&quot; + (xgoogle_max_bitrate || &quot;228&quot;),
                sdpLines[rtxFmtpLineIndex] = sdpLines[rtxFmtpLineIndex].concat(appendrtxNext),
                sdp = sdpLines.join(&quot;\r\n&quot;)
            }
            return sdp
        }
        function setOpusAttributes(sdp, params) {
            if (isMobileDevice)
                return sdp;
            params = params || {};
            var opusPayload, sdpLines = sdp.split(&quot;\r\n&quot;), opusIndex = findLine(sdpLines, &quot;a=rtpmap&quot;, &quot;opus/48000&quot;);
            if (opusIndex &amp;&amp; (opusPayload = getCodecPayloadType(sdpLines[opusIndex])),
            !opusPayload)
                return sdp;
            var opusFmtpLineIndex = findLine(sdpLines, &quot;a=fmtp:&quot; + opusPayload.toString());
            if (null === opusFmtpLineIndex)
                return sdp;
            var appendOpusNext = &quot;&quot;;
            return appendOpusNext += &quot;; stereo=&quot; + (&quot;undefined&quot; != typeof params.stereo ? params.stereo : &quot;1&quot;),
            appendOpusNext += &quot;; sprop-stereo=&quot; + (&quot;undefined&quot; != typeof params[&quot;sprop-stereo&quot;] ? params[&quot;sprop-stereo&quot;] : &quot;1&quot;),
            &quot;undefined&quot; != typeof params.maxaveragebitrate &amp;&amp; (appendOpusNext += &quot;; maxaveragebitrate=&quot; + (params.maxaveragebitrate || 1048576)),
            &quot;undefined&quot; != typeof params.maxplaybackrate &amp;&amp; (appendOpusNext += &quot;; maxplaybackrate=&quot; + (params.maxplaybackrate || 1048576)),
            &quot;undefined&quot; != typeof params.cbr &amp;&amp; (appendOpusNext += &quot;; cbr=&quot; + (&quot;undefined&quot; != typeof params.cbr ? params.cbr : &quot;1&quot;)),
            &quot;undefined&quot; != typeof params.useinbandfec &amp;&amp; (appendOpusNext += &quot;; useinbandfec=&quot; + params.useinbandfec),
            &quot;undefined&quot; != typeof params.usedtx &amp;&amp; (appendOpusNext += &quot;; usedtx=&quot; + params.usedtx),
            &quot;undefined&quot; != typeof params.maxptime &amp;&amp; (appendOpusNext += &quot;\r\na=maxptime:&quot; + params.maxptime),
            sdpLines[opusFmtpLineIndex] = sdpLines[opusFmtpLineIndex].concat(appendOpusNext),
            sdp = sdpLines.join(&quot;\r\n&quot;)
        }
        function preferVP9(sdp) {
            return -1 === sdp.indexOf(&quot;SAVPF 100 101&quot;) || -1 === sdp.indexOf(&quot;VP9/90000&quot;) ? sdp : sdp.replace(&quot;SAVPF 100 101&quot;, &quot;SAVPF 101 100&quot;)
        }
        function forceStereoAudio(sdp) {
            for (var sdpLines = sdp.split(&quot;\r\n&quot;), fmtpLineIndex = null , i = 0; i &lt; sdpLines.length; i++)
                if (-1 !== sdpLines[i].search(&quot;opus/48000&quot;)) {
                    var opusPayload = extractSdp(sdpLines[i], /:(\d+) opus\/48000/i);
                    break
                }
            for (var i = 0; i &lt; sdpLines.length; i++)
                if (-1 !== sdpLines[i].search(&quot;a=fmtp&quot;)) {
                    var payload = extractSdp(sdpLines[i], /a=fmtp:(\d+)/);
                    if (payload === opusPayload) {
                        fmtpLineIndex = i;
                        break
                    }
                }
            return null === fmtpLineIndex ? sdp : (sdpLines[fmtpLineIndex] = sdpLines[fmtpLineIndex].concat(&quot;; stereo=1; sprop-stereo=1&quot;),
            sdp = sdpLines.join(&quot;\r\n&quot;))
        }
        var isMobileDevice = !!navigator.userAgent.match(/Android|iPhone|iPad|iPod|BlackBerry|IEMobile/i);
        return &quot;undefined&quot; != typeof cordova &amp;&amp; (isMobileDevice = !0),
        navigator &amp;&amp; navigator.userAgent &amp;&amp; -1 !== navigator.userAgent.indexOf(&quot;Crosswalk&quot;) &amp;&amp; (isMobileDevice = !0),
        {
            removeVPX: removeVPX,
            disableNACK: disableNACK,
            prioritize: prioritize,
            removeNonG722: removeNonG722,
            setApplicationSpecificBandwidth: function(sdp, bandwidth, isScreen) {
                return setBAS(sdp, bandwidth, isScreen)
            },
            setVideoBitrates: function(sdp, params) {
                return setVideoBitrates(sdp, params)
            },
            setOpusAttributes: function(sdp, params) {
                return setOpusAttributes(sdp, params)
            },
            preferVP9: preferVP9,
            forceStereoAudio: forceStereoAudio
        }
    }();
    window.BandwidthHandler = CodecsHandler;
    var loadedIceFrame, OnIceCandidateHandler = function() {
        function processCandidates(connection, icePair) {
            var candidate = icePair.candidate
              , iceRestrictions = connection.candidates
              , stun = iceRestrictions.stun
              , turn = iceRestrictions.turn;
            if (isNull(iceRestrictions.reflexive) || (stun = iceRestrictions.reflexive),
            isNull(iceRestrictions.relay) || (turn = iceRestrictions.relay),
            (iceRestrictions.host || !candidate.match(/typ host/g)) &amp;&amp; (turn || !candidate.match(/typ relay/g)) &amp;&amp; (stun || !candidate.match(/typ srflx/g))) {
                var protocol = connection.iceProtocols;
                if ((protocol.udp || !candidate.match(/ udp /g)) &amp;&amp; (protocol.tcp || !candidate.match(/ tcp /g)))
                    return connection.enableLogs &amp;&amp; webrtcdev.debug(&quot;Your candidate pairs:&quot;, candidate),
                    {
                        candidate: candidate,
                        sdpMid: icePair.sdpMid,
                        sdpMLineIndex: icePair.sdpMLineIndex
                    }
            }
        }
        return {
            processCandidates: processCandidates
        }
    }();
    &quot;undefined&quot; != typeof window.getExternalIceServers &amp;&amp; 1 == window.getExternalIceServers &amp;&amp; loadIceFrame(function(externalIceServers) {
        externalIceServers &amp;&amp; externalIceServers.length &amp;&amp; (window.RMCExternalIceServers = externalIceServers,
        window.iceServersLoadCallback &amp;&amp; &quot;function&quot; == typeof window.iceServersLoadCallback &amp;&amp; window.iceServersLoadCallback(externalIceServers))
    });
    var IceServersHandler = function() {
        function getIceServers(connection) {
            var iceServers = [];
            return iceServers.push(getSTUNObj(&quot;stun:stun.l.google.com:19302&quot;)),
            iceServers.push(getTURNObj(&quot;turn:webrtcweb.com:80&quot;, &quot;muazkh&quot;, &quot;muazkh&quot;)),
            iceServers.push(getTURNObj(&quot;turn:webrtcweb.com:443&quot;, &quot;muazkh&quot;, &quot;muazkh&quot;)),
            window.RMCExternalIceServers ? iceServers = iceServers.concat(getExtenralIceFormatted()) : &quot;undefined&quot; != typeof window.getExternalIceServers &amp;&amp; 1 == window.getExternalIceServers &amp;&amp; (connection.iceServers = iceServers,
            window.iceServersLoadCallback = function() {
                connection.iceServers = connection.iceServers.concat(getExtenralIceFormatted())
            }
            ),
            iceServers
        }
        return {
            getIceServers: getIceServers
        }
    }()
      , currentUserMediaRequest = {
        streams: [],
        mutex: !1,
        queueRequests: [],
        remove: function(idInstance) {
            this.mutex = !1;
            var stream = this.streams[idInstance];
            if (stream) {
                stream = stream.stream;
                var options = stream.currentUserMediaRequestOptions;
                this.queueRequests.indexOf(options) &amp;&amp; (delete this.queueRequests[this.queueRequests.indexOf(options)],
                this.queueRequests = removeNullEntries(this.queueRequests)),
                this.streams[idInstance].stream = null ,
                delete this.streams[idInstance]
            }
        }
    }
      , StreamsHandler = function() {
        function handleType(type) {
            return type ? &quot;string&quot; == typeof type || &quot;undefined&quot; == typeof type ? type : type.audio &amp;&amp; type.video ? null : type.audio ? &quot;audio&quot; : type.video ? &quot;video&quot; : void 0 : void 0
        }
        function setHandlers(stream, syncAction, connection) {
            function graduallyIncreaseVolume() {
                if (connection.streamEvents[stream.streamid].mediaElement) {
                    var mediaElement = connection.streamEvents[stream.streamid].mediaElement;
                    mediaElement.volume = 0,
                    afterEach(200, 5, function() {
                        mediaElement.volume += .2
                    })
                }
            }
            stream &amp;&amp; stream.addEventListener &amp;&amp; ((&quot;undefined&quot; == typeof syncAction || 1 == syncAction) &amp;&amp; stream.addEventListener(&quot;ended&quot;, function() {
                StreamsHandler.onSyncNeeded(this.streamid, &quot;ended&quot;)
            }, !1),
            stream.mute = function(type, isSyncAction) {
                type = handleType(type),
                &quot;undefined&quot; != typeof isSyncAction &amp;&amp; (syncAction = isSyncAction),
                (&quot;undefined&quot; == typeof type || &quot;audio&quot; == type) &amp;&amp; stream.getAudioTracks().forEach(function(track) {
                    track.enabled = !1,
                    connection.streamEvents[stream.streamid].isAudioMuted = !0
                }),
                (&quot;undefined&quot; == typeof type || &quot;video&quot; == type) &amp;&amp; stream.getVideoTracks().forEach(function(track) {
                    track.enabled = !1
                }),
                (&quot;undefined&quot; == typeof syncAction || 1 == syncAction) &amp;&amp; StreamsHandler.onSyncNeeded(stream.streamid, &quot;mute&quot;, type),
                connection.streamEvents[stream.streamid].muteType = type || &quot;both&quot;,
                fireEvent(stream, &quot;mute&quot;, type)
            }
            ,
            stream.unmute = function(type, isSyncAction) {
                type = handleType(type),
                &quot;undefined&quot; != typeof isSyncAction &amp;&amp; (syncAction = isSyncAction),
                graduallyIncreaseVolume(),
                (&quot;undefined&quot; == typeof type || &quot;audio&quot; == type) &amp;&amp; stream.getAudioTracks().forEach(function(track) {
                    track.enabled = !0,
                    connection.streamEvents[stream.streamid].isAudioMuted = !1
                }),
                (&quot;undefined&quot; == typeof type || &quot;video&quot; == type) &amp;&amp; (stream.getVideoTracks().forEach(function(track) {
                    track.enabled = !0
                }),
                &quot;undefined&quot; != typeof type &amp;&amp; &quot;video&quot; == type &amp;&amp; connection.streamEvents[stream.streamid].isAudioMuted &amp;&amp; !function looper(times) {
                    times || (times = 0),
                    times++,
                    100 &gt; times &amp;&amp; connection.streamEvents[stream.streamid].isAudioMuted &amp;&amp; (stream.mute(&quot;audio&quot;),
                    setTimeout(function() {
                        looper(times)
                    }, 50))
                }()),
                (&quot;undefined&quot; == typeof syncAction || 1 == syncAction) &amp;&amp; StreamsHandler.onSyncNeeded(stream.streamid, &quot;unmute&quot;, type),
                connection.streamEvents[stream.streamid].unmuteType = type || &quot;both&quot;,
                fireEvent(stream, &quot;unmute&quot;, type)
            }
            )
        }
        function afterEach(setTimeoutInteval, numberOfTimes, callback, startedTimes) {
            startedTimes = (startedTimes || 0) + 1,
            startedTimes &gt;= numberOfTimes || setTimeout(function() {
                callback(),
                afterEach(setTimeoutInteval, numberOfTimes, callback, startedTimes)
            }, setTimeoutInteval)
        }
        return {
            setHandlers: setHandlers,
            onSyncNeeded: function(streamid, action, type) {}
        }
    }();
    window.addEventListener(&quot;message&quot;, function(event) {
        event.origin == window.location.origin &amp;&amp; onMessageCallback(event.data)
    });
    var sourceId, screenCallback, chromeMediaSource = &quot;screen&quot;;
    var TextSender = {
        send: function(config) {
            var connection = config.connection;

            var channel = config.channel,
                remoteUserId = config.remoteUserId,
                initialText = config.text,
                packetSize = connection.chunkSize || 1000,
                textToTransfer = &apos;&apos;,
                isobject = false;

            if (!isString(initialText)) {
                isobject = true;
                initialText = JSON.stringify(initialText);
            }

            // uuid is used to uniquely identify sending instance
            var uuid = getRandomString();
            var sendingTime = new Date().getTime();

            sendText(initialText);

            function sendText(textMessage, text) {
                var data = {
                    type: &apos;text&apos;,
                    uuid: uuid,
                    sendingTime: sendingTime
                };

                if (textMessage) {
                    text = textMessage;
                    data.packets = parseInt(text.length / packetSize);
                }

                if (text.length &gt; packetSize) {
                    data.message = text.slice(0, packetSize);
                } else {
                    data.message = text;
                    data.last = true;
                    data.isobject = isobject;
                }

                channel.send(data, remoteUserId);

                textToTransfer = text.slice(data.message.length);

                if (textToTransfer.length) {
                    setTimeout(function() {
                        sendText(null, textToTransfer);
                    }, connection.chunkInterval || 100);
                }
            }
        }
    },
    FileProgressBarHandler = function() {
        function handle(connection) {
            function updateLabel(progress, label) {
                if (-1 !== progress.position) {
                    var position = +progress.position.toFixed(2).split(&quot;.&quot;)[1] || 100;
                    label.innerHTML = position + &quot;%&quot;
                }
            }
            var progressHelper = {};
            connection.onFileStart = function(file) {
                var div = document.createElement(&quot;div&quot;);
                return div.title = file.name,
                div.innerHTML = &quot;&lt;label&gt;0%&lt;/label&gt; &lt;progress&gt;&lt;/progress&gt;&quot;,
                file.remoteUserId &amp;&amp; (div.innerHTML += &quot; (Sharing with:&quot; + file.remoteUserId + &quot;)&quot;),
                connection.filesContainer || (connection.filesContainer = document.body || document.documentElement),
                connection.filesContainer.insertBefore(div, connection.filesContainer.firstChild),
                file.remoteUserId ? (progressHelper[file.uuid] || (progressHelper[file.uuid] = {}),
                progressHelper[file.uuid][file.remoteUserId] = {
                    div: div,
                    progress: div.querySelector(&quot;progress&quot;),
                    label: div.querySelector(&quot;label&quot;)
                },
                void (progressHelper[file.uuid][file.remoteUserId].progress.max = file.maxChunks)) : (progressHelper[file.uuid] = {
                    div: div,
                    progress: div.querySelector(&quot;progress&quot;),
                    label: div.querySelector(&quot;label&quot;)
                },
                void (progressHelper[file.uuid].progress.max = file.maxChunks))
            }
            ,
            connection.onFileProgress = function(chunk) {
                var helper = progressHelper[chunk.uuid];
                helper &amp;&amp; (!chunk.remoteUserId || (helper = progressHelper[chunk.uuid][chunk.remoteUserId])) &amp;&amp; (helper.progress.value = chunk.currentPosition || chunk.maxChunks || helper.progress.max,
                updateLabel(helper.progress, helper.label))
            }
            ,
            connection.onFileEnd = function(file) {
                var helper = progressHelper[file.uuid];
                if (!helper)
                    return void webrtcdev.error(&quot;No such progress-helper element exists.&quot;, file);
                if (!file.remoteUserId || (helper = progressHelper[file.uuid][file.remoteUserId])) {
                    var div = helper.div;
                    -1 != file.type.indexOf(&quot;image&quot;) ? div.innerHTML = &apos;&lt;a href=&quot;&apos; + file.url + &apos;&quot; download=&quot;&apos; + file.name + &apos;&quot;&gt;Download &lt;strong style=&quot;color:red;&quot;&gt;&apos; + file.name + &apos;&lt;/strong&gt; &lt;/a&gt;&lt;br /&gt;&lt;img src=&quot;&apos; + file.url + &apos;&quot; title=&quot;&apos; + file.name + &apos;&quot; style=&quot;max-width: 80%;&quot;&gt;&apos; : div.innerHTML = &apos;&lt;a href=&quot;&apos; + file.url + &apos;&quot; download=&quot;&apos; + file.name + &apos;&quot;&gt;Download &lt;strong style=&quot;color:red;&quot;&gt;&apos; + file.name + &apos;&lt;/strong&gt; &lt;/a&gt;&lt;br /&gt;&lt;iframe src=&quot;&apos; + file.url + &apos;&quot; title=&quot;&apos; + file.name + &apos;&quot; style=&quot;width: 80%;border: 0;height: inherit;margin-top:1em;&quot;&gt;&lt;/iframe&gt;&apos;
                }
            }
        }
        return {
            handle: handle
        }
    }(), 
    TranslationHandler = function() {
        function handle(connection) {
            connection.autoTranslateText = !1,
            connection.language = &quot;en&quot;,
            connection.googKey = &quot;AIzaSyCgB5hmFY74WYB-EoWkhr9cAGr6TiTHrEE&quot;,
            connection.Translator = {
                TranslateText: function(text, callback) {
                    var newScript = document.createElement(&quot;script&quot;);
                    newScript.type = &quot;text/javascript&quot;;
                    var sourceText = encodeURIComponent(text)
                      , randomNumber = &quot;method&quot; + connection.token();
                    window[randomNumber] = function(response) {
                        response.data &amp;&amp; response.data.translations[0] &amp;&amp; callback &amp;&amp; callback(response.data.translations[0].translatedText),
                        response.error &amp;&amp; &quot;Daily Limit Exceeded&quot; === response.error.message &amp;&amp; (warn(&apos;Text translation failed. Error message: &quot;Daily Limit Exceeded.&quot;&apos;),
                        callback(text))
                    }
                    ;
                    var source = &quot;https://www.googleapis.com/language/translate/v2?key=&quot; + connection.googKey + &quot;&amp;target=&quot; + (connection.language || &quot;en-US&quot;) + &quot;&amp;callback=window.&quot; + randomNumber + &quot;&amp;q=&quot; + sourceText;
                    newScript.src = source,
                    document.getElementsByTagName(&quot;head&quot;)[0].appendChild(newScript)
                }
            }
        }
        return {
            handle: handle
        }
    }();
    window.RTCMultiConnection = RTCMultiConnection
}();
</code></pre>

</div>

<footer class="footer">
  Generated by <a href="https://esdoc.org">ESDoc<span data-ice="esdocVersion">(1.1.0)</span><img src="./image/esdoc-logo-mini-black.png"></a>
</footer>

<script src="script/search_index.js"></script>
<script src="script/search.js"></script>
<script src="script/pretty-print.js"></script>
<script src="script/inherited-summary.js"></script>
<script src="script/test-summary.js"></script>
<script src="script/inner-link.js"></script>
<script src="script/patch-for-local.js"></script>
</body>
</html>
