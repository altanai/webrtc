<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <base data-ice="baseUrl" href="../../../">
  <title data-ice="title">src/scripts/gumadapter.js | webrtcdevelopment</title>
  <link type="text/css" rel="stylesheet" href="css/style.css">
  <link type="text/css" rel="stylesheet" href="css/prettify-tomorrow.css">
  <script src="script/prettify/prettify.js"></script>
  <script src="script/manual.js"></script>
<meta name="description" content="webrtc based communication and collaboration client. Contains lot of experiments modules "><meta property="twitter:card" content="summary"><meta property="twitter:title" content="webrtcdevelopment"><meta property="twitter:description" content="webrtc based communication and collaboration client. Contains lot of experiments modules "></head>
<body class="layout-container" data-ice="rootContainer">

<header>
  <a href="./">Home</a>
  
  <a href="identifiers.html">Reference</a>
  <a href="source.html">Source</a>
  
  <div class="search-box">
  <span>
    <img src="./image/search.png">
    <span class="search-input-edge"></span><input class="search-input"><span class="search-input-edge"></span>
  </span>
    <ul class="search-result"></ul>
  </div>
<a style="position:relative; top:3px;" href="https://github.com/altanai/webrtc"><img width="20px" src="./image/github.png"></a></header>

<nav class="navigation" data-ice="nav"><div>
  <ul>
    
  <li data-ice="doc"><a data-ice="dirPath" class="nav-dir-path" href="identifiers.html#scripts">scripts</a><span data-ice="kind" class="kind-typedef">T</span><span data-ice="name"><span><a href="typedef/index.html#static-typedef-CanvasRecorder">CanvasRecorder</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-typedef">T</span><span data-ice="name"><span><a href="typedef/index.html#static-typedef-GetRecorderType">GetRecorderType</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-typedef">T</span><span data-ice="name"><span><a href="typedef/index.html#static-typedef-GifRecorder">GifRecorder</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-typedef">T</span><span data-ice="name"><span><a href="typedef/index.html#static-typedef-MRecordRTC">MRecordRTC</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-typedef">T</span><span data-ice="name"><span><a href="typedef/index.html#static-typedef-MediaStreamRecorder">MediaStreamRecorder</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-typedef">T</span><span data-ice="name"><span><a href="typedef/index.html#static-typedef-RecordRTC">RecordRTC</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-typedef">T</span><span data-ice="name"><span><a href="typedef/index.html#static-typedef-RecordRTCConfiguration">RecordRTCConfiguration</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-typedef">T</span><span data-ice="name"><span><a href="typedef/index.html#static-typedef-StereoAudioRecorder">StereoAudioRecorder</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-typedef">T</span><span data-ice="name"><span><a href="typedef/index.html#static-typedef-Whammy">Whammy</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-typedef">T</span><span data-ice="name"><span><a href="typedef/index.html#static-typedef-WhammyRecorder">WhammyRecorder</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-typedef">T</span><span data-ice="name"><span><a href="typedef/index.html#static-typedef-createFileSharingDiv">createFileSharingDiv</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-typedef">T</span><span data-ice="name"><span><a href="typedef/index.html#static-typedef-_turn.js">_turn.js</a></span></span></li>
<li data-ice="doc"><a data-ice="dirPath" class="nav-dir-path" href="identifiers.html#scripts-rtcconn">scripts/rtcconn</a><span data-ice="kind" class="kind-typedef">T</span><span data-ice="name"><span><a href="typedef/index.html#static-typedef-Whammy">Whammy</a></span></span></li>
</ul>
</div>
</nav>

<div class="content" data-ice="content"><h1 data-ice="title">src/scripts/gumadapter.js</h1>
<pre class="source-code line-number raw-source-code"><code class="prettyprint linenums" data-ice="content">    var getUserMedia = null;
    var webrtcDetectedBrowser = null;
    var webrtcDetectedVersion = null;
    var webrtcMinimumVersion = null;

    var webrtcUtils = window.webrtcUtils || {};
    if (!webrtcUtils.enableLogs) {
        webrtcUtils.enableLogs = true;
    }
    if (!webrtcUtils.log) {
        webrtcUtils.log = function() {
            if (!webrtcUtils.enableLogs) {
                return;
            }

            // suppress webrtcdev.log output when being included as a module.
            if (typeof module !== &apos;undefined&apos; ||
                typeof require === &apos;function&apos; &amp;&amp; typeof define === &apos;function&apos;) {
                return;
            }
            webrtcdev.log.apply(webrtcdev, arguments);
        };
    }

    if (!webrtcUtils.extractVersion) {
        webrtcUtils.extractVersion = function(uastring, expr, pos) {
            var match = uastring.match(expr);
            return match &amp;&amp; match.length &gt;= pos &amp;&amp; parseInt(match[pos], 10);
        };
    }

    if (typeof window === &apos;object&apos;) {
        if (window.HTMLMediaElement &amp;&amp;
            !(&apos;srcObject&apos; in window.HTMLMediaElement.prototype)) {
            // Shim the srcObject property, once, when HTMLMediaElement is found.
            Object.defineProperty(window.HTMLMediaElement.prototype, &apos;srcObject&apos;, {
                get: function() {
                    // If prefixed srcObject property exists, return it.
                    // Otherwise use the shimmed property, _srcObject
                    return &apos;mozSrcObject&apos; in this ? this.mozSrcObject : this._srcObject;
                },
                set: function(stream) {
                    if (&apos;mozSrcObject&apos; in this) {
                        this.mozSrcObject = stream;
                    } else {
                        // Use _srcObject as a private property for this shim
                        this._srcObject = stream;
                        // TODO: revokeObjectUrl(this.src) when !stream to release resources?
                        this.src = stream ? URL.createObjectURL(stream) : null;
                    }
                }
            });
        }

        // Proxy existing globals
        getUserMedia = window.navigator &amp;&amp; window.navigator.getUserMedia;
    }

    if (typeof window === &apos;undefined&apos; || !window.navigator) {
        webrtcDetectedBrowser = &apos;not a browser&apos;;
    } else if (navigator.mozGetUserMedia &amp;&amp; window.mozRTCPeerConnection) {
        webrtcDetectedBrowser = &apos;firefox&apos;;

        // the detected firefox version.
        webrtcDetectedVersion = webrtcUtils.extractVersion(navigator.userAgent,
            /Firefox\/([0-9]+)\./, 1);

        // the minimum firefox version still supported by adapter.
        webrtcMinimumVersion = 31;

        // getUserMedia constraints shim.
        getUserMedia = function(constraints, onSuccess, onError) {
            var constraintsToFF37 = function(c) {
                if (typeof c !== &apos;object&apos; || c.require) {
                    return c;
                }
                var require = [];
                Object.keys(c).forEach(function(key) {
                    if (key === &apos;require&apos; || key === &apos;advanced&apos; || key === &apos;mediaSource&apos;) {
                        return;
                    }
                    var r = c[key] = (typeof c[key] === &apos;object&apos;) ?
                        c[key] : {
                            ideal: c[key]
                        };
                    if (r.min !== undefined ||
                        r.max !== undefined || r.exact !== undefined) {
                        require.push(key);
                    }
                    if (r.exact !== undefined) {
                        if (typeof r.exact === &apos;number&apos;) {
                            r.min = r.max = r.exact;
                        } else {
                            c[key] = r.exact;
                        }
                        delete r.exact;
                    }
                    if (r.ideal !== undefined) {
                        c.advanced = c.advanced || [];
                        var oc = {};
                        if (typeof r.ideal === &apos;number&apos;) {
                            oc[key] = {
                                min: r.ideal,
                                max: r.ideal
                            };
                        } else {
                            oc[key] = r.ideal;
                        }
                        c.advanced.push(oc);
                        delete r.ideal;
                        if (!Object.keys(r).length) {
                            delete c[key];
                        }
                    }
                });
                if (require.length) {
                    c.require = require;
                }
                return c;
            };
            if (webrtcDetectedVersion &lt; 38) {
                webrtcUtils.log(&apos;spec: &apos; + JSON.stringify(constraints));
                if (constraints.audio) {
                    constraints.audio = constraintsToFF37(constraints.audio);
                }
                if (constraints.video) {
                    constraints.video = constraintsToFF37(constraints.video);
                }
                webrtcUtils.log(&apos;ff37: &apos; + JSON.stringify(constraints));
            }
            return navigator.mozGetUserMedia(constraints, onSuccess, onError);
        };

        navigator.getUserMedia = getUserMedia;

        // Shim for mediaDevices on older versions.
        if (!navigator.mediaDevices) {
            navigator.mediaDevices = {
                getUserMedia: requestUserMedia,
                addEventListener: function() {},
                removeEventListener: function() {}
            };
        }
        navigator.mediaDevices.enumerateDevices =
            navigator.mediaDevices.enumerateDevices || function() {
                return new Promise(function(resolve) {
                    var infos = [{
                        kind: &apos;audioinput&apos;,
                        deviceId: &apos;default&apos;,
                        label: &apos;&apos;,
                        groupId: &apos;&apos;
                    }, {
                        kind: &apos;videoinput&apos;,
                        deviceId: &apos;default&apos;,
                        label: &apos;&apos;,
                        groupId: &apos;&apos;
                    }];
                    resolve(infos);
                });
            };

        if (webrtcDetectedVersion &lt; 41) {
            // Work around http://bugzil.la/1169665
            var orgEnumerateDevices =
                navigator.mediaDevices.enumerateDevices.bind(navigator.mediaDevices);
            navigator.mediaDevices.enumerateDevices = function() {
                return orgEnumerateDevices().then(undefined, function(e) {
                    if (e.name === &apos;NotFoundError&apos;) {
                        return [];
                    }
                    throw e;
                });
            };
        }

    } else if (navigator.webkitGetUserMedia &amp;&amp; window.webkitRTCPeerConnection) {
        webrtcDetectedBrowser = &apos;chrome&apos;;

        webrtcDetectedVersion = webrtcUtils.extractVersion(navigator.userAgent,
            /Chrom(e|ium)\/([0-9]+)\./, 2);

        // the minimum chrome version still supported by adapter.
        webrtcMinimumVersion = 38;

        // getUserMedia constraints shim.
        var constraintsToChrome = function(c) {
            if (typeof c !== &apos;object&apos; || c.mandatory || c.optional) {
                return c;
            }
            var cc = {};
            Object.keys(c).forEach(function(key) {
                if (key === &apos;require&apos; || key === &apos;advanced&apos; || key === &apos;mediaSource&apos;) {
                    return;
                }
                var r = (typeof c[key] === &apos;object&apos;) ? c[key] : {
                    ideal: c[key]
                };
                if (r.exact !== undefined &amp;&amp; typeof r.exact === &apos;number&apos;) {
                    r.min = r.max = r.exact;
                }
                var oldname = function(prefix, name) {
                    if (prefix) {
                        return prefix + name.charAt(0).toUpperCase() + name.slice(1);
                    }
                    return (name === &apos;deviceId&apos;) ? &apos;sourceId&apos; : name;
                };
                if (r.ideal !== undefined) {
                    cc.optional = cc.optional || [];
                    var oc = {};
                    if (typeof r.ideal === &apos;number&apos;) {
                        oc[oldname(&apos;min&apos;, key)] = r.ideal;
                        cc.optional.push(oc);
                        oc = {};
                        oc[oldname(&apos;max&apos;, key)] = r.ideal;
                        cc.optional.push(oc);
                    } else {
                        oc[oldname(&apos;&apos;, key)] = r.ideal;
                        cc.optional.push(oc);
                    }
                }
                if (r.exact !== undefined &amp;&amp; typeof r.exact !== &apos;number&apos;) {
                    cc.mandatory = cc.mandatory || {};
                    cc.mandatory[oldname(&apos;&apos;, key)] = r.exact;
                } else {
                    [&apos;min&apos;, &apos;max&apos;].forEach(function(mix) {
                        if (r[mix] !== undefined) {
                            cc.mandatory = cc.mandatory || {};
                            cc.mandatory[oldname(mix, key)] = r[mix];
                        }
                    });
                }
            });
            if (c.advanced) {
                cc.optional = (cc.optional || []).concat(c.advanced);
            }
            return cc;
        };

        getUserMedia = function(constraints, onSuccess, onError) {
            if (constraints.audio) {
                constraints.audio = constraintsToChrome(constraints.audio);
            }
            if (constraints.video) {
                constraints.video = constraintsToChrome(constraints.video);
            }
            webrtcUtils.log(&apos;chrome: &apos; + JSON.stringify(constraints));
            return navigator.webkitGetUserMedia(constraints, onSuccess, onError);
        };
        navigator.getUserMedia = getUserMedia;

        if (!navigator.mediaDevices) {
            navigator.mediaDevices = {
                getUserMedia: requestUserMedia
            };
        }

        // A shim for getUserMedia method on the mediaDevices object.
        // TODO(KaptenJansson) remove once implemented in Chrome stable.
        if (!navigator.mediaDevices.getUserMedia) {
            navigator.mediaDevices.getUserMedia = function(constraints) {
                return requestUserMedia(constraints);
            };
        } else {
            // Even though Chrome 45 has navigator.mediaDevices and a getUserMedia
            // function which returns a Promise, it does not accept spec-style
            // constraints.
            var origGetUserMedia = navigator.mediaDevices.getUserMedia.
            bind(navigator.mediaDevices);
            navigator.mediaDevices.getUserMedia = function(c) {
                webrtcUtils.log(&apos;spec:   &apos; + JSON.stringify(c)); // whitespace for alignment
                c.audio = constraintsToChrome(c.audio);
                c.video = constraintsToChrome(c.video);
                webrtcUtils.log(&apos;chrome: &apos; + JSON.stringify(c));
                return origGetUserMedia(c);
            };
        }

        // Dummy devicechange event methods.
        // TODO(KaptenJansson) remove once implemented in Chrome stable.
        if (typeof navigator.mediaDevices.addEventListener === &apos;undefined&apos;) {
            navigator.mediaDevices.addEventListener = function() {
                webrtcUtils.log(&apos;Dummy mediaDevices.addEventListener called.&apos;);
            };
        }
        if (typeof navigator.mediaDevices.removeEventListener === &apos;undefined&apos;) {
            navigator.mediaDevices.removeEventListener = function() {
                webrtcUtils.log(&apos;Dummy mediaDevices.removeEventListener called.&apos;);
            };
        }

    } else if (navigator.mediaDevices &amp;&amp; navigator.userAgent.match(/Edge\/(\d+).(\d+)$/)) {
        webrtcUtils.log(&apos;This appears to be Edge&apos;);
        webrtcDetectedBrowser = &apos;edge&apos;;

        webrtcDetectedVersion = webrtcUtils.extractVersion(navigator.userAgent, /Edge\/(\d+).(\d+)$/, 2);

        // the minimum version still supported by adapter.
        webrtcMinimumVersion = 12;
    } else {
        webrtcUtils.log(&apos;Browser does not appear to be WebRTC-capable&apos;);
    }

    // Returns the result of getUserMedia as a Promise.
    function requestUserMedia(constraints) {
        return new Promise(function(resolve, reject) {
            getUserMedia(constraints, resolve, reject);
        });
    }

    if (typeof module !== &apos;undefined&apos;) {
        module.exports = {
            getUserMedia: getUserMedia,
            webrtcDetectedBrowser: webrtcDetectedBrowser,
            webrtcDetectedVersion: webrtcDetectedVersion,
            webrtcMinimumVersion: webrtcMinimumVersion,
            webrtcUtils: webrtcUtils
        };
    } else if ((typeof require === &apos;function&apos;) &amp;&amp; (typeof define === &apos;function&apos;)) {
        // Expose objects and functions when RequireJS is doing the loading.
        define([], function() {
            return {
                getUserMedia: getUserMedia,
                webrtcDetectedBrowser: webrtcDetectedBrowser,
                webrtcDetectedVersion: webrtcDetectedVersion,
                webrtcMinimumVersion: webrtcMinimumVersion,
                webrtcUtils: webrtcUtils
            };
        });
    }

    // getUserMediaHandler.js

    if (typeof webrtcUtils !== &apos;undefined&apos;) {
        webrtcUtils.enableLogs = false;
    }

    function setStreamType(constraints, stream) {
        if (constraints.mandatory &amp;&amp; constraints.mandatory.chromeMediaSource) {
            stream.isScreen = true;
        } else if (constraints.mozMediaSource || constraints.mediaSource) {
            stream.isScreen = true;
        } else if (constraints.video) {
            stream.isVideo = true;
        } else if (constraints.audio) {
            stream.isAudio = true;
        }
    }

    var currentUserMediaRequest = {
        streams: [],
        mutex: false,
        queueRequests: [],
        remove: function(idInstance) {
            this.mutex = false;

            var stream = this.streams[idInstance];
            if (!stream) {
                return;
            }

            stream = stream.stream;

            var options = stream.currentUserMediaRequestOptions;

            if (this.queueRequests.indexOf(options)) {
                delete this.queueRequests[this.queueRequests.indexOf(options)];
                this.queueRequests = removeNullEntries(this.queueRequests);
            }

            this.streams[idInstance].stream = null;
            delete this.streams[idInstance];
        }
    };

    function getUserMediaHandler(options) {
        if (currentUserMediaRequest.mutex === true) {
            currentUserMediaRequest.queueRequests.push(options);
            return;
        }
        currentUserMediaRequest.mutex = true;

        // easy way to match 
        var idInstance = JSON.stringify(options.localMediaConstraints);

        function streaming(stream, returnBack) {
            setStreamType(options.localMediaConstraints, stream);
            options.onGettingLocalMedia(stream, returnBack);

            stream.addEventListener(&apos;ended&apos;, function() {
                delete currentUserMediaRequest.streams[idInstance];

                currentUserMediaRequest.mutex = false;
                if (currentUserMediaRequest.queueRequests.indexOf(options)) {
                    delete currentUserMediaRequest.queueRequests[currentUserMediaRequest.queueRequests.indexOf(options)];
                    currentUserMediaRequest.queueRequests = removeNullEntries(currentUserMediaRequest.queueRequests);
                }
            }, false);

            currentUserMediaRequest.streams[idInstance] = {
                stream: stream
            };
            currentUserMediaRequest.mutex = false;

            if (currentUserMediaRequest.queueRequests.length) {
                getUserMediaHandler(currentUserMediaRequest.queueRequests.shift());
            }
        }

        if (currentUserMediaRequest.streams[idInstance]) {
            streaming(currentUserMediaRequest.streams[idInstance].stream, true);
        } else {
            if (isPluginRTC &amp;&amp; window.PluginRTC) {
                var mediaElement = document.createElement(&apos;video&apos;);
                window.PluginRTC.getUserMedia({
                    audio: true,
                    video: true
                }, function(stream) {
                    stream.streamid = stream.id || getRandomString();
                    streaming(stream);
                }, function(error) {});

                return;
            }

            navigator.mediaDevices.getUserMedia(options.localMediaConstraints).then(function(stream) {
                stream.streamid = stream.streamid || stream.id || getRandomString();
                stream.idInstance = idInstance;
                streaming(stream);
            }).catch(function(error) {
                options.onLocalMediaError(error, options.localMediaConstraints);
            });
        }
    }

    // StreamsHandler.js

    var StreamsHandler = (function() {
        function handleType(type) {
            if (!type) {
                return;
            }

            if (typeof type === &apos;string&apos; || typeof type === &apos;undefined&apos;) {
                return type;
            }

            if (type.audio &amp;&amp; type.video) {
                return null;
            }

            if (type.audio) {
                return &apos;audio&apos;;
            }

            if (type.video) {
                return &apos;video&apos;;
            }

            return;
        }

        function setHandlers(stream, syncAction, connection) {
            if (!stream || !stream.addEventListener) return;

            if (typeof syncAction == &apos;undefined&apos; || syncAction == true) {
                stream.addEventListener(&apos;ended&apos;, function() {
                    StreamsHandler.onSyncNeeded(this.streamid, &apos;ended&apos;);
                }, false);
            }

            stream.mute = function(type, isSyncAction) {
                type = handleType(type);

                if (typeof isSyncAction !== &apos;undefined&apos;) {
                    syncAction = isSyncAction;
                }

                if (typeof type == &apos;undefined&apos; || type == &apos;audio&apos;) {
                    stream.getAudioTracks().forEach(function(track) {
                        track.enabled = false;
                        connection.streamEvents[stream.streamid].isAudioMuted = true;
                    });
                }

                if (typeof type == &apos;undefined&apos; || type == &apos;video&apos;) {
                    stream.getVideoTracks().forEach(function(track) {
                        track.enabled = false;
                    });
                }

                if (typeof syncAction == &apos;undefined&apos; || syncAction == true) {
                    StreamsHandler.onSyncNeeded(stream.streamid, &apos;mute&apos;, type);
                }

                connection.streamEvents[stream.streamid].muteType = type || &apos;both&apos;;

                fireEvent(stream, &apos;mute&apos;, type);
            };

            stream.unmute = function(type, isSyncAction) {
                type = handleType(type);

                if (typeof isSyncAction !== &apos;undefined&apos;) {
                    syncAction = isSyncAction;
                }

                graduallyIncreaseVolume();

                if (typeof type == &apos;undefined&apos; || type == &apos;audio&apos;) {
                    stream.getAudioTracks().forEach(function(track) {
                        track.enabled = true;
                        connection.streamEvents[stream.streamid].isAudioMuted = false;
                    });
                }

                if (typeof type == &apos;undefined&apos; || type == &apos;video&apos;) {
                    stream.getVideoTracks().forEach(function(track) {
                        track.enabled = true;
                    });

                    // make sure that video unmute doesn&apos;t affects audio
                    if (typeof type !== &apos;undefined&apos; &amp;&amp; type == &apos;video&apos; &amp;&amp; connection.streamEvents[stream.streamid].isAudioMuted) {
                        (function looper(times) {
                            if (!times) {
                                times = 0;
                            }

                            times++;

                            // check until five-seconds
                            if (times &lt; 100 &amp;&amp; connection.streamEvents[stream.streamid].isAudioMuted) {
                                stream.mute(&apos;audio&apos;);

                                setTimeout(function() {
                                    looper(times);
                                }, 50);
                            }
                        })();
                    }
                }

                if (typeof syncAction == &apos;undefined&apos; || syncAction == true) {
                    StreamsHandler.onSyncNeeded(stream.streamid, &apos;unmute&apos;, type);
                }

                connection.streamEvents[stream.streamid].unmuteType = type || &apos;both&apos;;

                fireEvent(stream, &apos;unmute&apos;, type);
            };

            function graduallyIncreaseVolume() {
                if (!connection.streamEvents[stream.streamid].mediaElement) {
                    return;
                }

                var mediaElement = connection.streamEvents[stream.streamid].mediaElement;
                mediaElement.volume = 0;
                afterEach(200, 5, function() {
                    mediaElement.volume += .20;
                });
            }
        }

        function afterEach(setTimeoutInteval, numberOfTimes, callback, startedTimes) {
            startedTimes = (startedTimes || 0) + 1;
            if (startedTimes &gt;= numberOfTimes) return;

            setTimeout(function() {
                callback();
                afterEach(setTimeoutInteval, numberOfTimes, callback, startedTimes);
            }, setTimeoutInteval);
        }

        return {
            setHandlers: setHandlers,
            onSyncNeeded: function(streamid, action, type) {}
        };
    })();</code></pre>

</div>

<footer class="footer">
  Generated by <a href="https://esdoc.org">ESDoc<span data-ice="esdocVersion">(1.1.0)</span><img src="./image/esdoc-logo-mini-black.png"></a>
</footer>

<script src="script/search_index.js"></script>
<script src="script/search.js"></script>
<script src="script/pretty-print.js"></script>
<script src="script/inherited-summary.js"></script>
<script src="script/test-summary.js"></script>
<script src="script/inner-link.js"></script>
<script src="script/patch-for-local.js"></script>
</body>
</html>
