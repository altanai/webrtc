<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <base data-ice="baseUrl" href="../../../">
  <title data-ice="title">src/scripts/start.js | webrtcdevelopment</title>
  <link type="text/css" rel="stylesheet" href="css/style.css">
  <link type="text/css" rel="stylesheet" href="css/prettify-tomorrow.css">
  <script src="script/prettify/prettify.js"></script>
  <script src="script/manual.js"></script>
<meta name="description" content="webrtc based communication and collaboration client. Contains lot of experiments modules "><meta property="twitter:card" content="summary"><meta property="twitter:title" content="webrtcdevelopment"><meta property="twitter:description" content="webrtc based communication and collaboration client. Contains lot of experiments modules "></head>
<body class="layout-container" data-ice="rootContainer">

<header>
  <a href="./">Home</a>
  
  <a href="identifiers.html">Reference</a>
  <a href="source.html">Source</a>
  
  <div class="search-box">
  <span>
    <img src="./image/search.png">
    <span class="search-input-edge"></span><input class="search-input"><span class="search-input-edge"></span>
  </span>
    <ul class="search-result"></ul>
  </div>
<a style="position:relative; top:3px;" href="https://github.com/altanai/webrtc"><img width="20px" src="./image/github.png"></a></header>

<nav class="navigation" data-ice="nav"><div>
  <ul>
    
  <li data-ice="doc"><a data-ice="dirPath" class="nav-dir-path" href="identifiers.html#scripts">scripts</a><span data-ice="kind" class="kind-typedef">T</span><span data-ice="name"><span><a href="typedef/index.html#static-typedef-CanvasRecorder">CanvasRecorder</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-typedef">T</span><span data-ice="name"><span><a href="typedef/index.html#static-typedef-GetRecorderType">GetRecorderType</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-typedef">T</span><span data-ice="name"><span><a href="typedef/index.html#static-typedef-GifRecorder">GifRecorder</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-typedef">T</span><span data-ice="name"><span><a href="typedef/index.html#static-typedef-MRecordRTC">MRecordRTC</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-typedef">T</span><span data-ice="name"><span><a href="typedef/index.html#static-typedef-MediaStreamRecorder">MediaStreamRecorder</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-typedef">T</span><span data-ice="name"><span><a href="typedef/index.html#static-typedef-RecordRTC">RecordRTC</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-typedef">T</span><span data-ice="name"><span><a href="typedef/index.html#static-typedef-RecordRTCConfiguration">RecordRTCConfiguration</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-typedef">T</span><span data-ice="name"><span><a href="typedef/index.html#static-typedef-StereoAudioRecorder">StereoAudioRecorder</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-typedef">T</span><span data-ice="name"><span><a href="typedef/index.html#static-typedef-Whammy">Whammy</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-typedef">T</span><span data-ice="name"><span><a href="typedef/index.html#static-typedef-WhammyRecorder">WhammyRecorder</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-typedef">T</span><span data-ice="name"><span><a href="typedef/index.html#static-typedef-createFileSharingDiv">createFileSharingDiv</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-typedef">T</span><span data-ice="name"><span><a href="typedef/index.html#static-typedef-_turn.js">_turn.js</a></span></span></li>
<li data-ice="doc"><a data-ice="dirPath" class="nav-dir-path" href="identifiers.html#scripts-rtcconn">scripts/rtcconn</a><span data-ice="kind" class="kind-typedef">T</span><span data-ice="name"><span><a href="typedef/index.html#static-typedef-Whammy">Whammy</a></span></span></li>
</ul>
</div>
</nav>

<div class="content" data-ice="content"><h1 data-ice="title">src/scripts/start.js</h1>
<pre class="source-code line-number raw-source-code"><code class="prettyprint linenums" data-ice="content">// &apos;use strict&apos;;

// var inherits = require(&apos;util&apos;).inherits;
// var EventEmitter = require(&apos;events&apos;).EventEmitter;

/**************************************************************************************
        peerconnection 
****************************************************************************/

var channelpresence= false;
var localVideoStreaming= null;
var turn=&quot;none&quot;;
var localobj={}, remoteobj={};
    //instantiates event emitter
    // EventEmitter.call(this);

    // function handleError(error) {
    //   if (error.name === &apos;ConstraintNotSatisfiedError&apos;) {
    //     let v = constraints.video;
    //     webrtcdev.error(`The resolution ${v.width.exact}x${v.height.exact} px is not supported by your device.`);
    //   } else if (error.name === &apos;PermissionDeniedError&apos;) {
    //     webrtcdev.error(&apos;Permissions have not been granted to use your camera and &apos; +
    //       &apos;microphone, you need to allow the page access to your devices in &apos; +
    //       &apos;order for the demo to work.&apos;);
    //   }
    //   webrtcdev.error(`getUserMedia error: ${error.name}`, error);

    //   outgoingVideo = false;
    // }

    /**
     * Assigns ICE gateways and  widgets 
     * @constructor
          * @param {json} _localObj - local object.
     * @param {json} _remoteObj - remote object.
     * @param {json} incoming - incoming media stream.
     * @param {json} outgoing - outgoing media stream.
     * @param {json} session - session object.
     * @param {json} widgets - widgets object.
     */
    var WebRTCdev= function(_localobj , _remoteobj , incoming, outgoing , session, widgets){
        //try{
            sessionid  = session.sessionid;
            socketAddr = session.socketAddr;
            localobj = _localobj;
            remoteobj = _remoteobj;
            webrtcdev.log(&quot;WebRTCdev --&gt; Session &quot; , session);
        // }catch(e){
        //     webrtcdev.error(e);
        //     alert(&quot; Session object doesnt have all parameters &quot;);
        // }

        //try{
            turn    = (session.hasOwnProperty(&apos;turn&apos;)?session.turn:null);
            webrtcdev.log(&quot;WebRTCdev --&gt; TURN &quot;, turn);
            if(turn &amp;&amp; turn !=&quot;none&quot;){
                // getICEServer( turn.username ,turn.secretkey , turn.domain,
                //                 turn.application , turn.room , turn.secure); 
                getICEServer(); 
            }else{
                webrtcdev.log(&quot;WebRTCdev --&gt; TURN not applied &quot;);
            }
        // }catch(e){
        //     webrtcdev.error(e);
        //     alert(&quot; cannot get TURN &quot;);
        // }

        if(widgets){

            webrtcdev.log( &quot; WebRTCdev --&gt; widgets  &quot; , widgets);

            if(widgets.debug)           debug           = widgets.debug || false;

            if(widgets.chat)            chatobj         = widgets.chat || null;

            if(widgets.fileShare)       fileshareobj    = widgets.fileShare || null;

            if(widgets.screenrecord)    screenrecordobj = widgets.screenrecord || null;

            if(widgets.screenshare)     screenshareobj  = widgets.screenshare || null;

            if(widgets.snapshot)        snapshotobj     = widgets.snapshot || null;

            if(widgets.videoRecord)     videoRecordobj  = widgets.videoRecord || null;

            if(widgets.reconnect)       reconnectobj    = widgets.reconnect || null;

            if(widgets.drawCanvas)      drawCanvasobj   = widgets.drawCanvas || null;

            if(widgets.texteditor)      texteditorobj   = widgets.texteditor || null;

            if(widgets.codeeditor)      codeeditorobj   = widgets.codeeditor || null;

            if(widgets.mute)            muteobj         = widgets.mute || null;

            if(widgets.timer)           timerobj        = widgets.timer || null;

            if(widgets.listenin)        listeninobj     = widgets.listenin || null;

            if(widgets.cursor)          cursorobj       = widgets.cursor || null;

            if(widgets.minmax)          minmaxobj       = widgets.minmax || null;

            if(widgets.help)            helpobj         = widgets.help || null;

            if(widgets.statistics)      statisticsobj   = widgets.statistics || null;
        }

        return {
            sessionid : sessionid,
            socketAddr: socketAddr,
            turn : turn,
            widgets  : widgets,
            startwebrtcdev: funcStartWebrtcdev,
            rtcConn : rtcConn
        };
    };

function funcStartWebrtcdev(){

    webrtcdev.log(&quot; startwebrtcdev &quot;);
    return new Promise(function (resolve, reject) {
        // detectRTC = DetectRTC;

        // webrtcdev.log(&quot; [ startJS webrtcdom ] : DetectRTC &quot; , detectRTC)
        // // Cases around webcam malfunctiojn or absense 
        // if(!detectRTC.hasWebcam){
        //     shownotification(&quot; Your browser doesnt have webcam&quot; , &quot;warning&quot;);
        //     outgoing.video = false;
        // }
        // if(!detectRTC.isWebsiteHasWebcamPermissions){
        //     shownotification(&quot; Your browser doesnt have permission for accessing webcam&quot;, &quot;warning&quot;);
        //     outgoing.video = false;
        // }
        
        // //Cases around Miceohone malfunction or absense 
        // if(!detectRTC.hasMicrophone){
        //     shownotification(&quot; Your browser doesnt have microphone&quot;, &quot;warning&quot;);   
        //     outgoing.audio = false ;
        // }
        
        // if(!detectRTC.isWebsiteHasMicrophonePermissions){
        //     shownotification(&quot; Your browser doesnt have permission for accessing microphone&quot;, &quot;warning&quot;);
        //     outgoing.audio = false;
        // }
        
        // if(!detectRTC.hasSpeakers){
        //     shownotification(&quot; Your browser doesnt have speakers&quot;, &quot;warning&quot;);      
        // }

        resolve(&quot;done&quot;);
    }).then( navigator.mediaDevices.getUserMedia({audio: true,video: true })
    ).then( function(res){
        webrtcdev.log(&quot; [ startJS webrtcdom ] : localStorage  &quot; , localStorage);

        return new Promise(function (resolve , reject){
            if(localStorage.length&gt;1 &amp;&amp; localStorage.getItem(&quot;channel&quot;) != sessionid) clearCaches();
            else if(!localStorage.getItem(&quot;channel&quot;)) localStorage.setItem(&quot;channel&quot;, sessionid);
            else webrtcdev.log(&quot; no action taken on localStorage&quot;);
            resolve(&quot;done&quot;);
        })
    }).then(function(res){

        webrtcdev.log(&quot; [ startJS webrtcdom ] : incoming &quot; , incoming);
        webrtcdev.log(&quot; [ startJS webrtcdom ] : outgoing &quot; , outgoing);

        return new Promise(function (resolve , reject){
            if(incoming){
                incomingAudio = incoming.audio ; 
                incomingVideo = incoming.video ; 
                incomingData  = incoming.data  ;  
            }
            if(outgoing){
                outgoingAudio = outgoing.audio ; 
                outgoingVideo = outgoing.video ; 
                outgoingData  = outgoing.data ;
            }
            resolve(&quot;done&quot;);
        })
    }).then(function(res){

        webrtcdev.log(&quot; [ startJS webrtcdom ] : localobj &quot; , localobj);
        webrtcdev.log(&quot; [ startJS webrtcdom ] : remoteobj &quot; , remoteobj);

        return new Promise(function (resolve , reject){

            /* When user is single */
            localVideo = localobj.video;

            /* when user is in conference */
            let _remotearr=remoteobj.videoarr;
            /* first video container in remotearr belongs to user */
            if(outgoingVideo){
                selfVideo = _remotearr[0];
            }
            /* create arr for remote peers videos */
            if(!remoteobj.dynamicVideos){
                for(var x=1;x&lt;_remotearr.length;x++){
                    remoteVideos.push(_remotearr[x]);    
                }
            }
            resolve(&quot;done&quot;);
        })
    }).then(function(res){

        return new Promise(function (resolve , reject){

            if(localobj.hasOwnProperty(&apos;userdetails&apos;)){
                let obj      = localobj.userdetails;
                webrtcdev.info(&quot;localobj userdetails &quot; , obj);
                selfusername = obj.username  || &quot;LOCAL&quot;;
                selfcolor    = obj.usercolor || &quot;orange&quot;;
                selfemail    = obj.useremail || &quot;unknown&quot;;
                role         = obj.role      || &quot;participant&quot;;
            }else{
                webrtcdev.warning(&quot;localobj has no userdetails &quot;);
            }

            if(remoteobj.hasOwnProperty(&apos;userdetails&apos;)){
                let obj        = remoteobj.userdetails;
                webrtcdev.info(&quot;remoteobj userdetails &quot; , obj);
                remoteusername = obj.username  || &quot;REMOTE&quot;;
                remotecolor    = obj.usercolor || &quot;orange&quot;;
                remoteemail    = obj.useremail || &quot;unknown&quot;;
            }else{
                webrtcdev.warning(&quot;remoteobj has no userdetails &quot;);
            }
            resolve(&quot;done&quot;);
        })

    }).then( setRtcConn(sessionid)
    ).then( setWidgets(rtcConn)
    ).then( startSocketSession(rtcConn, socketAddr,  sessionid)
    ).catch( function (err) {
        webrtcdev.error(&quot; Promise rejected &quot; , err);
    });

}

/**
 * function to start session with socket
 * @method
 * @name startSession
 * @param {object} connection
 */
function startSocketSession(rtcConn , socketAddr , sessionid){

    webrtcdev.log(&quot;StartSession&quot; + sessionid);

    try {
        var addr = &quot;/&quot;;
        if (socketAddr != &quot;/&quot;) {
            addr = socketAddr;
        }
        socket = io.connect(addr ,{
                                  transports: [&apos;websocket&apos;]
        } );
       // socket.set(&apos;log level&apos;, 3);

    } catch (e) {
        webrtcdev.error(&quot; problem in socket connnection&quot;, e);
        alert(&quot; problem in socket connnection&quot;);
    }

    if (sessionid){
        shownotification(&quot; Checking status of  : &quot; + sessionid);
        socket.emit(&quot;presence&quot;, {
            channel: sessionid
        });

    } else{
        webrtcdev.error(&quot; Session id undefined &quot;);
        alert(&quot;rtcCon channel / session id undefined &quot;);
        return; 
    }

    socket.on(&quot;connect&quot;, function () {
        socket.on(&apos;disconnected&apos;, function () {
            shownotification(&quot;Disconnected from signaller &quot;);
        });
    });


    socket.on(&quot;presence&quot;, function (event) {
        webrtcdev.log(&quot;presence for sessionid &quot;, event);
        channelpresence = event;
        if(channelpresence) joinWebRTC(sessionid, selfuserid) ;
        else                openWebRTC(sessionid, selfuserid) ;
    });

    socket.on(&quot;open-channel-resp&quot;, function (event) {
        webrtcdev.log(&quot; opened-channel&quot;, event, event.status, event.channel == sessionid);
        if (event.status &amp;&amp; event.channel == sessionid) {

            let promise = new Promise(function(resolve, reject) {
                webrtcdev.log(&quot; [open-channel-resp ] &quot;,
                    &quot; Session video:&quot; ,  outgoingVideo,
                    &quot; audio: &quot; , outgoingAudio ,
                    &quot; data: &quot; , outgoingData , 
                    &quot; OfferToReceiveAudio: &quot; , incomingAudio,
                    &quot; OfferToReceiveVideo: &quot; , incomingVideo
                );

                rtcConn.connectionType = &quot;open&quot;,

                rtcConn.session = {
                    video: outgoingVideo,
                    audio: outgoingAudio,
                    data: outgoingData
                },

                rtcConn.sdpConstraints.mandatory = {
                    OfferToReceiveAudio: incomingAudio,
                    OfferToReceiveVideo: incomingVideo
                };
                resolve(); // immediately give the result: 123
            });

            promise.then(
                rtcConn.open(event.channel, function () {
                    if (selfuserid == null) {
                        selfuserid = rtcConn.userid;

                        if (tempuserid != selfuserid)
                            socket.emit(&quot;update-channel&quot;, {
                                type: &quot;change-userid&quot;,
                                channel: rtcConn.channel,
                                sender: selfuserid,
                                extra: {
                                    old: tempuserid,
                                    new: selfuserid
                                }
                            });
                    }
                })
            ).then(function(res){
                updatePeerInfo(selfuserid || rtcConn.userid , selfusername, selfcolor, selfemail, &quot;role&quot; , &quot;local&quot;);
                webrtcdev.info(&quot; Trying to open a channel on WebRTC SDP &quot;);
            }).then(
                getCamMedia()
            ).catch(
               (reason) =&gt; {
                    webrtcdev.error(&apos;Handle rejected promise (&apos;+reason+&apos;)&apos;);
                }
            );

        } else {
            alert(&quot; signaller doesnt allow channel open&quot;);
        }
        shownotification(event.msgtype + &quot; : &quot; + event.message);
    });

    socket.on(&quot;join-channel-resp&quot;, function (event) {
        webrtcdev.log(&quot;joined-channel&quot;, event);
        
        if (event.status &amp;&amp; event.channel == sessionid) {
        
            let promise = new Promise(function(resolve, reject) {

                webrtcdev.log(&quot; [ join-channel-resp ] &quot;,
                    &quot; Session video:&quot; ,  outgoingVideo,
                    &quot; audio: &quot; , outgoingAudio ,
                    &quot; data: &quot; , outgoingData , 
                    &quot; OfferToReceiveAudio: &quot; , incomingAudio,
                    &quot; OfferToReceiveVideo: &quot; , incomingVideo
                ); 

                rtcConn.connectionType = &quot;join&quot;,
                rtcConn.session = {
                    video: outgoingVideo,
                    audio: outgoingAudio,
                    data: outgoingData
                },
                rtcConn.sdpConstraints.mandatory = {
                    OfferToReceiveAudio: incomingAudio,
                    OfferToReceiveVideo: incomingVideo
                },
                rtcConn.remoteUsers = event.users;                        

                resolve(); // immediately give the result: 123
            });

            promise.then(
                rtcConn.connectionDescription = rtcConn.join(event.channel),
            ).then(
                updatePeerInfo(rtcConn.userid, selfusername, selfcolor, selfemail, role, &quot;local&quot;),
                webrtcdev.info(&quot; Trying to join a channel on WebRTC SDP &quot;)
            ).then(function(res){
                for (x in rtcConn.remoteUsers) {
                    updatePeerInfo(rtcConn.remoteUsers[x], remoteusername, remotecolor, remoteemail, &quot;participant&quot; , &quot;remote&quot;);
                    if (role == &quot;inspector&quot;) shownotificationWarning(&quot;This session is being inspected &quot;);
                }
            }).then(
                getCamMedia() 
            ).catch(
               (reason) =&gt; {
                    webrtcdev.error(&apos;Handle rejected promise (&apos;+reason+&apos;)&apos;);
                }
            );                    
        } else {
            alert(&quot; signaller doesnt allow channel Join&quot;);
        }
        shownotification(event.msgtype + &quot; : &quot; + event.message);
    });

    socket.on(&quot;channel-event&quot;, function (event) {
        webrtcdev.log(&quot;channel-event&quot;, event);
        if (event.type == &quot;new-join&quot;) {
            if (event.status) {
                var peerinfo = findPeerInfo(event.data.sender);
                if (!peerinfo) {
                    if (event.data.extra.name == &quot;LOCAL&quot;) {
                        event.data.extra.name = &quot;REMOTE&quot;;
                        event.data.extra.color = remotecolor;
                    }
                    updatePeerInfo(event.data.sender, event.data.extra.name, event.data.extra.color, event.data.extra.email, event.data.extra.role , &quot;remote&quot;);
                    shownotification( event.data.extra.role  + &quot;  &quot; +event.type);
                }
            } else {
                shownotification(event.msgtype + &quot; : &quot; + event.message);
            }
        }
    });
}


/*
set Rtc connection
*/
var setRtcConn = function ( sessionid) {

    return new Promise(function (resolve, reject) {

        webrtcdev.log(&quot;initiating RTcConn&quot;),

        rtcConn = new RTCMultiConnection(),

        rtcConn.onNewParticipant = function (participantId, userPreferences) {
            webrtcdev.log(&quot;onNewParticipant&quot;, participantId, userPreferences);
            shownotification(remoteusername + &quot; requests new participantion &quot;);
            if (webcallpeers.length &lt;= remoteobj.maxAllowed) {
                updatePeerInfo(participantId, remoteusername, remotecolor, &quot;&quot;, &quot;role&quot;, &quot;remote&quot;);
            } else {
                shownotification(&quot;Another user is trying to join this channel but max count [ &quot; + remoteobj.maxAllowed + &quot; ] is reached&quot;, &quot;warning&quot;);
            }
            rtcConn.acceptParticipationRequest(participantId, userPreferences);
        },

        rtcConn.onopen = function (event) {
            webrtcdev.log(&quot;rtcconn onopen &quot; + rtcConn.connectionType);
            try {
                if (rtcConn.connectionType == &quot;open&quot;)
                    connectWebRTC(&quot;open&quot;, sessionid, selfuserid, []);
                else if (rtcConn.connectionType == &quot;join&quot;){
                    connectWebRTC(&quot;join&quot;, sessionid, selfuserid, rtcConn.remoteUsers);
                }
                else
                    shownotification(&quot;connnection type is neither open nor join&quot;, &quot;warning&quot;);

                if (timerobj &amp;&amp; timerobj.active) {
                    startsessionTimer(timerobj);
                    shareTimePeer();
                }
                shownotification(event.extra.name + &quot; joined session &quot;, &quot;info&quot;);
                showdesktopnotification();
                
                onSessionConnect();
                //eventEmitter.emit(&apos;sessionconnected&apos;);        // Call Function just in case the client is implementing this

                if (statisticsobj &amp;&amp; statisticsobj.active) {
                    //populate RTP stats 
                    rtpstats();
                }

            } catch (e) {
                shownotification(&quot;problem in on session open &quot;+ e.message, &quot;warning&quot;);
                webrtcdev.error(&quot;problem in on session open&quot;, e);
            }
        },

        rtcConn.onMediaError = function (error, constraints) {
            webrtcdev.error(&quot;[startJS onMediaError] &quot;, error, constraints);
            shownotification(error.name + &quot; Joining without camera Stream &quot;, &quot;warning&quot;);
            localVideoStreaming = false;
            // For local Peer , if camera is nott allowed or not connected then put null in video containers 
            //for(x in webcallpeers){
                //if(!webcallpeers[x].stream &amp;&amp;  !webcallpeers[x].streamid){
                    var peerinfo = webcallpeers[0];
                    peerinfo.type = &quot;Local&quot;;
                    peerinfo.stream = null;
                    peerinfo.streamid = &quot;nothing01&quot;;
                    updateWebCallView(peerinfo);
                //}
            //}
            onLocalConnect() // event emitter for app client 
        },

        rtcConn.onstream = function (event) {
            webrtcdev.log(&quot;[startJs on stream ] on stream Started event &quot;, event);
            if(event.type==&quot;local&quot;) localVideoStreaming = true;

            var peerinfo = findPeerInfo(event.userid);
            if (!peerinfo ) {
                console.error(&quot; PeerInfo not present in webcallpeers &quot;, event.userid, rtcConn);
                alert(&quot; Cannot create session for Peer&quot;);
            } else {
                peerinfo.type = event.type;
                peerinfo.stream = event.stream;
                peerinfo.streamid = event.stream.streamid;
                updateWebCallView(peerinfo);
            }
            onLocalConnect() // event emitter for app client 
        },

        rtcConn.onstreamended = function (event) {
            webrtcdev.log(&quot; On streamEnded event &quot;, event);
            var mediaElement = document.getElementById(event.streamid);
            if (mediaElement) {
                mediaElement.parentNode.removeChild(mediaElement);
            }
        },

        rtcConn.chunkSize = 50 * 1000,

        rtcConn.onmessage = function (e) {
            webrtcdev.log(&quot; on message &quot;, e);
            if (e.data.typing) {
                updateWhotyping(e.extra.name + &quot; is typing ...&quot;);
            } else if (e.data.stoppedTyping) {
                updateWhotyping(&quot;&quot;);
            } else {
                switch (e.data.type) {
                    case &quot;screenshare&quot;:

                        if (e.data.message == &quot;stoppedscreenshare&quot;) {
                            shownotification(&quot;Screenshare has stopped : &quot; + e.data.screenStreamid);
                            //createScreenViewButton();
                            var button = document.getElementById(screenshareobj.button.shareButton.id);
                            button.className = screenshareobj.button.shareButton.class_off;
                            button.innerHTML = screenshareobj.button.shareButton.html_off;
                            button.disabled = false;

                            scrConn.onstreamended();
                            scrConn.removeStream(e.data.screenStreamid);
                            scrConn.close();
                        } else if (e.data.message == &quot;screenshareStartedViewing&quot;) {
                            screenshareNotification(&quot;&quot;, &quot;screenshareStartedViewing&quot;);
                        } else {
                            shownotification(&quot;screen is getting shared &quot; + e.data.screenid);
                            //createScreenViewButton();
                            var button = document.getElementById(screenshareobj.button.shareButton.id);
                            button.className = screenshareobj.button.shareButton.class_busy;
                            button.innerHTML = screenshareobj.button.shareButton.html_busy;
                            button.disabled = true;

                            screenRoomid = e.data.screenid;
                            var selfuserid = &quot;temp_&quot; + (new Date().getUTCMilliseconds());
                            webrtcdevPrepareScreenShare(function (screenRoomid) {
                                //scrConn.join(screenRoomid);  
                                connectScrWebRTC(&quot;join&quot;, screenRoomid, selfuserid, []);
                            });
                        }

                        break;
                    case &quot;chat&quot;:
                        updateWhotyping(e.extra.name + &quot; has send message&quot;);
                        /*var userinfo;
                        try{
                            userinfo=getUserinfo(rtcConn.blobURLs[e.userid], &quot;chat-message.png&quot;);
                        }catch(e){
                            userinfo=&quot;empty&quot;;
                        }*/
                        addNewMessage({
                            header: e.extra.name,
                            message: e.data.message,
                            userinfo: e.data.userinfo,
                            color: e.extra.color
                        });
                        break;
                    case &quot;imagesnapshot&quot;:
                        var peerinfo = findPeerInfo(e.userid);
                        displayList(null, peerinfo, e.data.message, e.data.name, &quot;imagesnapshot&quot;);
                        displayFile(null, peerinfo, e.data.message, e.data.name, &quot;imagesnapshot&quot;);
                        break;
                    case &quot;videoRecording&quot;:
                        var peerinfo = findPeerInfo(e.userid);
                        displayList(null, peerinfo, e.data.message, e.data.name, &quot;videoRecording&quot;);
                        displayFile(null, peerinfo, e.data.message, e.data.name, &quot;videoRecording&quot;);
                        break;
                    case &quot;videoScreenRecording&quot;:
                        var peerinfo = findPeerInfo(e.userid);
                        displayList(null, peerinfo, e.data.message, e.data.name, &quot;videoScreenRecording&quot;);
                        displayFile(null, peerinfo, e.data.message, e.data.name, &quot;videoScreenRecording&quot;);
                        break;
                    case &quot;file&quot;:
                        addNewMessage({
                            header: e.extra.name,
                            message: e.data.message,
                            userinfo: getUserinfo(rtcConn.blobURLs[e.userid], &quot;chat-message.png&quot;),
                            color: e.extra.color
                        });
                        break;
                    case &quot;canvas&quot;:
                        if (e.data.draw) {
                            CanvasDesigner.syncData(e.data.draw);
                        } else if (e.data.board) {
                            webrtcdev.log(&quot; Canvas : &quot;, e.data);
                            if (e.data.board.from == &quot;remote&quot;) {

                                if (e.data.board.event == &quot;open&quot; &amp;&amp; isDrawOpened != true)
                                    syncDrawBoard(e.data.board);
                                else if (e.data.board.event == &quot;close&quot; &amp;&amp; isDrawOpened == true)
                                    syncDrawBoard(e.data.board);
                            }
                        } else {
                            webrtcdev.warn(&quot; Board data mismatch&quot;, e.data);
                        }
                        break;
                    case &quot;texteditor&quot;:
                        receiveWebrtcdevTexteditorSync(e.data.data);
                        break;
                    case &quot;codeeditor&quot;:
                        receiveWebrtcdevCodeeditorSync(e.data.data);
                        break;
                    case &quot;pointer&quot;:
                        var elem = document.getElementById(&quot;cursor2&quot;);
                        if (elem) {
                            if (e.data.action == &quot;startCursor&quot;) {
                                elem.setAttribute(&quot;style&quot;, &quot;display:block&quot;);
                                placeCursor(elem, e.data.corX, e.data.corY);
                            } else if (e.data.action == &quot;stopCursor&quot;) {
                                elem.setAttribute(&quot;style&quot;, &quot;display:none&quot;);
                            }
                        } else {
                            alert(&quot; Cursor for remote is not present &quot;);
                        }

                        break;
                    case &quot;timer&quot;:
                        startPeersTime(e.data.time, e.data.zone);
                        break;
                    case &quot;buttonclick&quot;:
                        var buttonElement = document.getElementById(e.data.buttonName);
                        if (buttonElement.getAttribute(&quot;lastClickedBy&quot;) != rtcConn.userid) {
                            buttonElement.setAttribute(&quot;lastClickedBy&quot;, e.userid);
                            buttonElement.click();
                        }
                        break;
                    case &quot;syncOldFiles&quot;:
                        sendOldFiles();
                        break;
                    case &quot;shareFileRemove&quot;:
                        var progressdiv = e.data._element;
                        var filename = e.data._filename;
                        removeFile(progressdiv);
                        removeButton= &quot;removeButton&quot;+filename;
                        document.getElementById(removeButton).hidden = true;
                        break;
                    default:
                        webrtcdev.warn(&quot; unrecognizable message from peer  &quot;, e);
                        break;
                }
            }
            return;
        },

        rtcConn.sendMessage = function (event) {
            webrtcdev.log(&quot; sendMessage &quot;, event);
            event.userid = rtcConn.userid,
            event.extra = rtcConn.extra,
            rtcConn.sendCustomMessage(event)
        },

        rtcConn.onleave = function (e) {
            /*
            addNewMessage({
                header: e.extra.name,
                message: e.extra.name + &quot; left session.&quot;,
                userinfo: getUserinfo(rtcConn.blobURLs[e.userid], &quot;info.png&quot;),
                color: e.extra.color
            }), */

            var peerinfo = findPeerInfo(e.userid) ;

            webrtcdev.log(&quot; RTCConn onleave user&quot;, e , &quot; his peerinfo &quot; , peerinfo , &quot; rom webcallpeers &quot; , webcallpeers );
            if (e.extra.name != &quot;undefined&quot;)
                shownotification(e.extra.name + &quot;  left the conversation.&quot;);
            //rtcConn.playRoleOfInitiator()
            
            /*if(peerinfo){
                destroyWebCallView(peerinfo, function (result) {
                    if (result)
                        removePeerInfo(e.userid);
                });
            }*/
            //eventEmitter.emit(&apos;sessiondisconnected&apos;, peerinfo);
        },

        rtcConn.onclose = function (e) {
            webrtcdev.log(&quot; RTCConn on close conversation &quot;, e);
            /*alert(e.extra.name + &quot;closed &quot;);*/
        },

        rtcConn.onEntireSessionClosed = function (event) {
            rtcConn.attachStreams.forEach(function (stream) {
                stream.stop();
            });
            alert(&quot; Entire Session Disconneted &quot;);
            //eventEmitter.emit(&apos;sessiondisconnected&apos;, &apos;&apos;);
        },

        rtcConn.onFileStart = function (file) {
            webrtcdev.log(&quot;[start] on File start &quot; + file.name);
            webrtcdev.log(&quot;file description &quot;, file);

            var peerinfo = findPeerInfo(file.userid);
            if(peerinfo &amp;&amp; peerinfo.role ==&quot;inspector&quot;) return;
            addProgressHelper(file.uuid, peerinfo, file.name, file.maxChunks, &quot;fileBoxClass&quot;);
        },

        rtcConn.onFileProgress = function (e) {
            webrtcdev.log(&quot;[start] on File progress &quot;, e);
            try{
                var r = progressHelper[e.uuid];
                r &amp;&amp; (r.progress.value = e.currentPosition || e.maxChunks || r.progress.max, updateLabel(r.progress, r.label));
            }catch(e){
                webrtcdev.error(&quot; Prolem in progressHelper &quot; , e);
            }
        },

        rtcConn.onFileEnd = function (file) {
            var filename = file.name
            webrtcdev.log(&quot;[start] On file End &quot; + filename);

            //find duplicate file
            // for(x in webcallpeers){
            //     for (y in webcallpeers[x].filearray){
            //         webrtcdev.log(&quot; Duplicate find , Files shared  so far &quot; , webcallpeers[x].filearray[y].name);

            //         if(webcallpeers[x].filearray[y].name==filename){
            //             //discard file as duplicate
            //             webrtcdev.error(&quot;duplicate file shared &quot;);
            //             return;
            //         }
            //     }
            // }

            var peerinfo = findPeerInfo(file.userid); 
            //if (peerinfo != null)  peerinfo.filearray.push(file);
            if (peerinfo != null)  {
                for( f in peerinfo.filearray)
                    if(peerinfo.filearray[f].name == filename)
                        peerinfo.filearray[f].status = &quot;finished&quot;;
            }
            displayFile(file.uuid, peerinfo, file.url, filename, file.type);
            displayList(file.uuid, peerinfo, file.url, filename, file.type);
        },

        rtcConn.takeSnapshot = function (userid, callback) {
            takeSnapshot({
                userid: userid,
                connection: connection,
                callback: callback
            });
        },

        rtcConn.connectionType = null,
        rtcConn.remoteUsers = [],

        rtcConn.extra = {
            uuid: tempuserid,
            name: selfusername|| &quot;&quot;,
            color: selfcolor|| &quot;&quot;,
            email: selfemail || &quot;&quot;
        },

        rtcConn.channel = this.sessionid,
        rtcConn.socketURL = &quot;/&quot;,
        rtcConn.socketMessageEvent = &apos;RTCMultiConnection-Message&apos;,
        rtcConn.socketCustomEvent = &apos;RTCMultiConnection-Custom-Message&apos;,

        rtcConn.enableFileSharing = true,
        rtcConn.filesContainer = document.body || document.documentElement,

        rtcConn.dontCaptureUserMedia = true,

        tempuserid = supportSessionRefresh(),
        webrtcdev.log(&quot; RTCConn : &quot;, rtcConn);

        // if(this.turn!=null &amp;&amp; this.turn !=&quot;none&quot;){
        //     if (!webrtcdevIceServers) {
        //         return;
        //     }
        //     webrtcdev.info(&quot; WebRTC dev ICE servers &quot;, webrtcdevIceServers);
        //     rtcConn.iceServers = webrtcdevIceServers;
        //     window.clearInterval(repeatInitilization);
        // }

        if(rtcConn)
            resolve(rtcConn);
        else 
            reject(&quot;failed&quot;);
    });
}

    function supportSessionRefresh(){
        if(localStorage.getItem(&quot;channel&quot;) == rtcConn.channel &amp;&amp; localStorage.getItem(&quot;userid&quot;)){
            selfuserid = localStorage.getItem(&quot;userid&quot;);
            webrtcdev.log(&quot; [startJS ] check for supportSessionRefresh - user refreshed , old userid is  &quot; , selfuserid);
            return selfuserid;
        }
        return rtcConn.userid;;
    }

    function getCamMedia(){
        webrtcdev.log(&quot; [startJS] getCamMedia  role :&quot; , role , &quot; and outgoingVideo : &quot; , outgoingVideo);
        return new Promise(function (resolve, reject) {
            if( role == &quot;inspector&quot;){
                webrtcdev.log(&quot;Joining as inspector without camera Video&quot;);
            }else if(outgoingVideo || !outgoingVideo){
                webrtcdev.log(&quot;getCamMedia - Capture Media &quot;);
                rtcConn.dontCaptureUserMedia = false,
                rtcConn.getUserMedia();  // not wait for the rtc conn on media stream or on error 
            }else{
                webrtcdev.error(&quot; getCamMedia - dont Capture outgoing video &quot; , outgoingVideo);
                onNoCameraCard();
            }
            resolve(&quot;success&quot;)
        }).catch(
           (reason) =&gt; {
                webrtcdev.error(&apos;getCamMedia rejected promise (&apos;+reason+&apos;)&apos;);
        });
    }

    /**
     * set Widgets.
     */
    var setWidgets = function (rtcConn) {

     return new Promise (function(resolve, reject){
        if (chatobj.active) {

            if (chatobj.inputBox &amp;&amp; chatobj.inputBox.text_id &amp;&amp; document.getElementById(chatobj.inputBox.text_id)) {
                webrtcdev.log(&quot;Assign chat Box &quot;);
                assignChatBox(chatobj);
            } else {
                webrtcdev.log(&quot;Create chat Box &quot;);
                createChatBox(chatobj);
            }
            webrtcdev.log(&quot;chat widget loaded &quot;);
        } else {
            webrtcdev.log(&quot; chat widget not loaded &quot;);
        }

        if (screenrecordobj &amp;&amp; screenrecordobj.active) {

            detectExtension(screenshareobj.extensionID, function (status) {
                extensioninstalled = status;
                webrtcdev.log(&quot;is screenshareobj extension installed  ? &quot;, status);

                if (status == &apos;not-installed&apos;) {
                    shownotification(&quot; Sessions recoridng cannot start as there is not extension installed &quot;, &quot;warning&quot;);
                    createExtensionInstallWindow();
                } else if (status == &apos;installed-enabled&apos;) {
                    if (screenrecordobj.button.id &amp;&amp; document.getElementById(screenrecordobj.button.id)) {
                        webrtcdev.log(&quot;Assign Record Button &quot;);
                        assignScreenRecordButton(screenrecordobj);
                    } else {
                        webrtcdev.log(&quot;Create Record Button &quot;);
                        createScreenRecordButton(screenrecordobj);
                    }
                } else if (extensioninstalled == &apos;installed-disabled&apos;) {
                    shownotification(&quot;chrome extension is installed but disabled.&quot; , &quot;warning&quot;);
                    if (screenrecordobj.button.id &amp;&amp; document.getElementById(screenrecordobj.button.id)) {
                        assignScreenRecordButton(screenrecordobj);
                        webrtcdev.log(&quot;Assign Record Button &quot;);
                    } else {
                        webrtcdev.log(&quot;Create Record Button &quot;);
                        createScreenRecordButton(screenrecordobj);
                    }
                } else if (extensioninstalled == &apos;not-chrome&apos;) {
                    // using non-chrome browser
                } else{
                     webrtcdev.error(&quot; screen record extension&apos;s state is undefined &quot;);
                }

            });

            webrtcdev.log(&quot; screen record widget loaded &quot;);

        } else if (screenrecordobj &amp;&amp; !screenrecordobj.active) {
            if (screenrecordobj.button.id &amp;&amp; document.getElementById(screenrecordobj.button.id)) {
                document.getElementById(screenrecordobj.button.id).className = &quot;inactiveButton&quot;;
            }
            webrtcdev.log(&quot; screen record widget not loaded &quot;);
        }

        if (screenshareobj.active) {

            detectExtension(screenshareobj.extensionID, function (status) {
                webrtcdev.log(&quot;is screenshareobj extension installed  ? &quot;, status);
                if (status == &apos;installed-enabled&apos;) {
                    var screenShareButton = createOrAssignScreenshareButton(screenshareobj);
                    hideScreenInstallButton();
                } else if (status == &apos;installed-disabled&apos;) {
                    shownotification(&quot;chrome extension is installed but disabled.&quot;);
                    var screenShareButton = createOrAssignScreenshareButton(screenshareobj);
                    hideScreenInstallButton();
                } else if (status == &apos;not-installed&apos;) {

                    //document.getElementById(&quot;screensharedialog&quot;).showModal();
                    $(&quot;#screensharedialog&quot;).modal(&quot;show&quot;);
                    hideScreenShareButton();

                    if (screenshareobj.button.installButton.id &amp;&amp; document.getElementById(screenshareobj.button.installButton.id)) {
                        assignScreenInstallButton(screenshareobj.extensionID);
                    } else {
                        createScreenInstallButton(screenshareobj.extensionID);
                    }
                } else if (status == &apos;not-chrome&apos;) {
                    // using non-chrome browser
                    alert(&quot; Screen share extension only works in Chrome for now &quot;);
                } else{
                    webrtcdev.error(&quot; screen share extension&apos;s state is undefined &quot;);
                }
            });

            webrtcdev.log(&quot; screen share widget loaded &quot;);
        } else {
            webrtcdev.log(&quot; screen share widget not loaded &quot;);
        }

        if (reconnectobj &amp;&amp; reconnectobj.active) {
            if (reconnectobj.button.id &amp;&amp; document.getElementById(reconnectobj.button.id)) {
                webrtcdev.log(&quot;Rconnect Button Assigned&quot;);
                assignButtonRedial(reconnectobj.button.id);
            } else {
                webrtcdev.log(&quot;Rconnect Button created&quot;);
                createButtonRedial(reconnectobj);
            }
            webrtcdev.log(&quot; reconnect widget loacded &quot;);
        } else if (reconnectobj &amp;&amp; !reconnectobj.active) {
            if (reconnectobj.button.id &amp;&amp; document.getElementById(reconnectobj.button.id)) {
                document.getElementById(reconnectobj.button.id).className = &quot;inactiveButton&quot;;
            }
            webrtcdev.log(&quot; reconnect widget not loaded &quot;);
        }

        if (cursorobj.active) {
            document.getElementById(&quot;cursor1&quot;).setAttribute(&quot;style&quot;, &quot;display:none&quot;);
            document.getElementById(&quot;cursor2&quot;).setAttribute(&quot;style&quot;, &quot;display:none&quot;);
        }

        if (listeninobj &amp;&amp; listeninobj.active) {
            if (listeninobj.button.id &amp;&amp; document.getElementById(listeninobj.button.id)) {
                //assignButtonRedial(reconnectobj.button.id);
            } else {
                //createButtonRedial();
            }
            webrtcdev.log(&quot; listen in widget loaded &quot;);
        } else if (listeninobj &amp;&amp; !listeninobj.active) {
            if (listeninobj.button.id &amp;&amp; document.getElementById(listeninobj.button.id)) {
                document.getElementById(listeninobj.button.id).className = &quot;inactiveButton&quot;;
            }
            webrtcdev.log(&quot; listenein widget not loaded &quot;);
        }

        if (timerobj &amp;&amp; timerobj.active) {
            startTime();
            timeZone();
            activateBttons(timerobj);
            document.getElementById(timerobj.container.id).hidden = true;
        } else if (timerobj &amp;&amp; !timerobj.active) {
            if (timerobj.button.id &amp;&amp; document.getElementById(timerobj.button.id)) {
                document.getElementById(timerobj.button.id).className = &quot;inactiveButton&quot;;
            }
        }

        if (drawCanvasobj &amp;&amp; drawCanvasobj.active) {
            if (drawCanvasobj.container &amp;&amp; drawCanvasobj.container.id &amp;&amp; document.getElementById(drawCanvasobj.container.id)) {
                document.getElementById(drawCanvasobj.container.id).hidden = true;
            }
            if (drawCanvasobj.button.id &amp;&amp; document.getElementById(drawCanvasobj.button.id)) {
                assigndrawButton(drawCanvasobj);
            } else {
                createdrawButton(drawCanvasobj);
            }

            CanvasDesigner = (function () {
                var iframe;
                var tools = {
                    line: true,
                    pencil: true,
                    dragSingle: true,
                    dragMultiple: true,
                    eraser: true,
                    rectangle: true,
                    arc: true,
                    bezier: true,
                    quadratic: true,
                    text: true
                };

                var selectedIcon = &apos;pencil&apos;;

                function syncData(data) {
                    if (!iframe) return;

                    iframe.contentWindow.postMessage({
                        canvasDesignerSyncData: data
                    }, &apos;*&apos;);
                }

                var syncDataListener = function (data) {
                    webrtcdev.log(&quot;syncDataListener&quot;, data);
                };

                function onMessage() {
                    if (!event.data || !event.data.canvasDesignerSyncData) return;
                    syncDataListener(event.data.canvasDesignerSyncData);
                }

                /*window.addEventListener(&apos;message&apos;, onMessage, false);*/

                var eventMethod = window.addEventListener ? &quot;addEventListener&quot; : &quot;attachEvent&quot;;
                var eventer = window[eventMethod];
                var messageEvent = eventMethod == &quot;attachEvent&quot; ? &quot;onmessage&quot; : &quot;message&quot;;

                // Listen to message from child window
                eventer(messageEvent, function (e) {
                    webrtcdev.log(&quot;CanvasDesigner parent received message : &quot;, e.data);

                    if (e.data.modalpopup) {
                        saveButtonCanvas.click();
                        //return;
                    } else if (e.data || e.data.canvasDesignerSyncData) {
                        syncDataListener(e.data.canvasDesignerSyncData);
                    } else if (!e.data || !e.data.canvasDesignerSyncData) {
                        webrtcdev.log(&quot;parent received unexpected message&quot;);
                        //return;
                    }

                }, false);

                return {
                    appendTo: function (parentNode) {
                        iframe = document.createElement(&apos;iframe&apos;);
                        iframe.id = &quot;drawboard&quot;;
                        iframe.src = &apos;widget.html?tools=&apos; + JSON.stringify(tools) + &apos;&amp;selectedIcon=&apos; + selectedIcon;
                        iframe.style.width = &quot;100%&quot;;
                        iframe.style.height = &quot;100%&quot;;
                        iframe.style.border = 0;
                        parentNode.appendChild(iframe);
                    },
                    destroy: function () {
                        if (iframe) {
                            iframe.parentNode.removeChild(iframe);
                        }
                        window.removeEventListener(&apos;message&apos;, onMessage);
                    },
                    addSyncListener: function (callback) {
                        syncDataListener = callback;
                    },
                    syncData: syncData,
                    setTools: function (_tools) {
                        tools = _tools;
                    },
                    setSelected: function (icon) {
                        if (typeof tools[icon] !== &apos;undefined&apos;) {
                            selectedIcon = icon;
                        }
                    }
                };
            })();
            webrtcdev.log(&quot; draw widget loaded &quot;);
        } else if (drawCanvasobj &amp;&amp; !drawCanvasobj.active) {
            if (drawCanvasobj.button.id &amp;&amp; document.getElementById(drawCanvasobj.button.id)) {
                document.getElementById(drawCanvasobj.button.id).className = &quot;inactiveButton&quot;;
            }
            webrtcdev.log(&quot; draw widget not loaded &quot;);
        }

        if (texteditorobj.active) {
            createTextEditorButton();
        }

        if (codeeditorobj.active) {
            createCodeEditorButton();
        }

        if (fileshareobj.active) {

            webrtcdev.log(&quot; fileshareobj - rtcConn &quot;, rtcConn),

            rtcConn.enableFileSharing = true;
            // //rtcConn.filesContainer = document.body || document.documentElement;
            // /*setFileProgressBarHandlers(rtcConn);*/
            rtcConn.filesContainer = document.getElementById(fileshareobj.fileShareContainer);
            if (fileshareobj.button.id &amp;&amp; document.getElementById(fileshareobj.button.id)) {
                assignFileShareButton(fileshareobj);
            } else {
                createFileShareButton(fileshareobj);
            }
            webrtcdev.log(&quot; File sharing widget loaded &quot;);
        } else {
            webrtcdev.log(&quot; File sharing widget not loaded &quot;);
        }

        if(statisticsobj &amp;&amp; statisticsobj.active){
            try{
                document.getElementById(statisticsobj.statsConainer).innerHTML=&quot;&quot;;
            }catch(e){
                webrtcdev.error(&quot; statisticsobj statsConainer not found&quot; , e );
            }
        }

        if(helpobj &amp;&amp; helpobj.active){
            try{
                document.getElementById(helpobj.helpContainer).innerHTML=&quot;&quot;;
            }catch(e){
                webrtcdev.error(&quot; helpobj helpContainer not found&quot; , e );
            }
        }
        resolve(&quot;success&quot;);
    })

    }


    /**
     * Update local cache of user sesssion based object called peerinfo
     * @method
     * @name updateWebCallView
     * @param {json} peerInfo
     */
    function updateWebCallView(peerInfo){
        webrtcdev.log(&quot;updateWebCallView - start with peerInfo&quot; , peerInfo , &quot; || role is &quot;, role ,
         &quot; ||  indexOf &quot;, peerInfo.vid.indexOf(&quot;videoundefined&quot;) );
        try{
            switch(role){
                case &quot;inspector&quot;:
                    var vi=0;
                    for(var v=0; v&lt;remoteVideos.length; v++){
                        webrtcdev.log(&quot;Remote Video index array &quot; , v , &quot; || &quot;, remoteVideos[v] , 
                            document.getElementsByName(remoteVideos[v])  , 
                            document.getElementsByName(remoteVideos[v]).src);
                        if(remoteVideos[v].src){
                            vi++;
                        }
                    }

                    var remvid;
                    var video = document.createElement(&apos;video&apos;);
                    //video.autoplay = &quot;autoplay&quot;;
                    remoteVideos[vi] = video;
                    document.getElementById(remoteobj.videoContainer).appendChild(video);
                    remvid = remoteVideos[vi];

                    webrtcdev.log(&quot; [start.js - updateWebCallView] inspector role , attaching stream&quot; , remvid, peerInfo.stream );
                    attachMediaStream(remvid, peerInfo.stream);
                    if(remvid.hidden) removid.hidden = false;
                    remvid.id = peerInfo.videoContainer;
                    remvid.className = remoteobj.videoClass;
                    attachControlButtons(remvid, peerInfo); 

                    if(remoteobj.userDisplay &amp;&amp; peerInfo.name ){
                        attachUserDetails( remvid, peerInfo); 
                    }
                    
                    if(remoteobj.userMetaDisplay &amp;&amp; peerInfo.userid){
                        attachMetaUserDetails( remvid, peerInfo ); 
                    }

                    //Hide the unsed video for Remote
                    var _templ=document.getElementsByName(localVideo)[0];
                    _templ.setAttribute(&quot;style&quot;,&quot;display:none&quot;);
                    var _templ2=document.getElementsByName(selfVideo)[0];
                    _templ2.setAttribute(&quot;style&quot;,&quot;display:none&quot;);
                break;

                case &quot;user&quot;:
                case &quot;participant&quot;:

                    if(peerInfo.vid.indexOf(&quot;videolocal&quot;) &gt; -1 ){
                        webrtcdev.info(&quot; updateWebCallView - PeerInfo Vid is Local&quot;);

                        // when video is local
                        if(localVideo &amp;&amp; document.getElementsByName(localVideo)[0]){
                            var vid = document.getElementsByName(localVideo)[0];
                            vid.muted = true;
                            vid.className = localobj.videoClass;
                            attachMediaStream(vid, peerInfo.stream);

                            if(localobj.userDisplay &amp;&amp; peerInfo.name)
                                attachUserDetails( vid, peerInfo ); 
                            
                            if(localobj.userMetaDisplay &amp;&amp; peerInfo.userid)
                                attachMetaUserDetails( vid , peerInfo ); 

                            webrtcdev.info(&quot; User is alone in the session  , hiding remote video container&quot; , 
                            &quot;showing users single video conrainer and attaching attachMediaStream and attachUserDetails &quot;);

                        }else{
                            alert(&quot; Please Add a video container in config for single&quot;);
                            webrtcdev.error(&quot; No local video conatainer in localobj -&gt; &quot; , localobj);
                        }

                    } else if(peerInfo.vid.indexOf(&quot;videoremote&quot;) &gt; -1) {

                        webrtcdev.info(&quot; updateWebCallView - PeerInfo Vid is Remote&quot;);

                        //when video is remote 

                        /* handling local video transistion to active */
                        if( outgoingVideo &amp;&amp; localVideo &amp;&amp; selfVideo ){
                            /*chk if local video is added to conf , else adding local video to index 0 */
                            //localvid : video container before p2p session 
                            var localvid = document.getElementsByName(localVideo)[0];
                            // selfvid : local video in a p2p session
                            var selfvid = document.getElementsByName(selfVideo)[0];
                            
                            if(selfvid.played.length==0){
                                if(localvid.played.lebth&gt;0){
                                    reattachMediaStream(selfvid, localvid);
                                }else{
                                    attachMediaStream(selfvid, webcallpeers[0].stream);
                                }
                                selfvid.id = webcallpeers[0].videoContainer;
                                selfvid.className = remoteobj.videoClass;
                                selfvid.muted = true;
                                attachControlButtons( selfvid, webcallpeers[0]); 

                                if(localobj.userDisplay &amp;&amp; webcallpeers[0].name){
                                    attachUserDetails( selfvid, webcallpeers[0] );
                                } 

                                if(localobj.userMetaDisplay &amp;&amp; webcallpeers[0].userid){
                                    attachMetaUserDetails( selfvid, webcallpeers[0] ); 
                                }
                            }else{
                                webrtcdev.log(&quot; not uppdating self video as it is already playing &quot;);
                            }

                            webrtcdev.info(&quot; User is joined by a remote peer , hiding local video container&quot; , 
                            &quot;showing users conf video container and attaching attachMediaStream and attachUserDetails &quot;);

                        }else if(!outgoingVideo){
                            webrtcdev.error(&quot; Outgoing Local video is &quot; , outgoingVideo);
                        }else{
                            alert(&quot; Please Add a video container in config for video call &quot;);
                            webrtcdev.error(&quot; Local video container not defined &quot;);
                        }


                        // handling remote video addition 
                        if(remoteVideos){

                            /*get the next empty index of video and pointer in remote video array */
                            var vi=0;
                            for(var v=0; v&lt;remoteVideos.length; v++){
                                webrtcdev.log(&quot;Remote Video index array &quot; , v , &quot; || &quot;, remoteVideos[v] , 
                                    document.getElementsByName(remoteVideos[v]),  document.getElementsByName(remoteVideos[v]).src);
                                if(document.getElementsByName(remoteVideos[v])[0] &amp;&amp; document.getElementsByName(remoteVideos[v])[0].src){
                                    vi++;
                                }else if(remoteVideos[v].video &amp;&amp; remoteVideos[v].video){
                                    vi++;
                                }
                            }

                            try{

                                if(remoteobj.maxAllowed==&quot;unlimited&quot;){
                                    webrtcdev.log(&quot;remote video is unlimited , creating video for remoteVideos array &quot;);
                                    var video = document.createElement(&apos;video&apos;);
                                    //video.autoplay = &quot;autoplay&quot;;
                                    remoteVideos[vi] = {
                                        &quot;userid&quot;: peerInfo.userid, 
                                        &quot;video&quot; : video
                                    };
                                    document.getElementById(remoteobj.dynamicVideos.videoContainer).appendChild(video);
                                }else{
                                    webrtcdev.log(&quot;remote video is limited to size maxAllowed , current index &quot;, vi);
                                    webrtcdev.log(&quot;searching for video with index &quot;, vi , &quot; in remote video : &quot; , document.getElementsByName(remoteVideos[vi])[0] );
                                    if(document.getElementsByName(remoteVideos[vi])[0]){
                                        remoteVideos[vi] = { 
                                            &quot;userid&quot;: peerInfo.userid, 
                                            &quot;video&quot; : document.getElementsByName(remoteVideos[vi])[0] 
                                        };
                                    }else{
                                        webrtcdev.error(&quot; document.getElementsByName(remoteVideos[vi])[0] doest exist for vi &quot; , vi);
                                    }
                                }

                                attachMediaStream(remoteVideos[vi].video, peerInfo.stream);
                                if(remoteVideos[vi].video.hidden) remoteVideos[vi].video.hidden = false;
                                remoteVideos[vi].video.id = peerInfo.videoContainer;
                                remoteVideos[vi].video.className = remoteobj.videoClass;
                                attachControlButtons(remoteVideos[vi].video, peerInfo); 

                                if(remoteobj.userDisplay &amp;&amp; peerInfo.name ) {
                                    attachUserDetails( remoteVideos[vi].video, peerInfo); 
                                }
                                
                                if(remoteobj.userMetaDisplay &amp;&amp; peerInfo.userid) {
                                    attachMetaUserDetails( remoteVideos[vi].video, peerInfo ); 
                                }
                            
                            }catch(e){
                                webrtcdev.error(e);
                            }

                        }else{
                            alert(&quot;remote Video containers not defined&quot;);
                        }
                    
                    } else {
                        webrtcdev.error(&quot; PeerInfo vid didnt match either case &quot;);
                    }
                break;

                default:
                    webrtcdev.log(&quot; Switch default case&quot;);
            }


        }catch(e){
            webrtcdev.error(&quot;[ start.js - update call view ]&quot; , e);
        }

        webrtcdev.log(&quot; updateWebCallView - finish&quot;);
    }
  
    /********************************************************************************** 
            Session call and Updating Peer Info
    ************************************************************************************/
    var repeatInitilization = null;

    /**
     * start a call 
     * @method
     * @name startCall
     * @param {json} obj
     */
    function startCall(obj){
        webrtcdev.log(&quot; startCall obj&quot; , obj);
        webrtcdev.log(&quot; TURN &quot; , turn);
        //if(turn==&apos;none&apos;){
            obj.startwebrtcdev();
        // }else if(turn!=null){
        //     repeatInitilization = window.setInterval(obj.startwebrtcdev, 2000);     
        // }
        return;
    }

    /**
     * stop a call
     * @method
     * @name stopCall
     */
    function stopCall(){
        webrtcdev.log(&quot; stopCall &quot;);
        rtcConn.closeEntireSession();

        if(!localStorage.getItem(&quot;channel&quot;))
            localStorage.removeItem(&quot;channel&quot;);

        if(!localStorage.getItem(&quot;userid&quot;))
            localStorage.removeItem(&quot;userid&quot;);
        
        if(!localStorage.getItem(&quot;remoteUsers&quot;))
            localStorage.removeItem(&quot;remoteUsers&quot;);

        return;
    }

    /**
     * update info about a peer in list of peers (webcallpeers)
     * @method
     * @name updatePeerInfo
     * @param {string} userid
     * @param {string} username
     * @param {string} usercolor
     * @param {string} type
     */
    function updatePeerInfo(userid , username , usecolor , useremail, userrole ,  type ){
        webrtcdev.log(&quot;updating peerInfo: &quot; , userid , username , usecolor , useremail, userrole ,  type);
        for(x in webcallpeers){
            if(webcallpeers[x].userid==userid) {
                webrtcdev.log(&quot;UserID is already existing , webcallpeers&quot;);
                return;
            }
        }

        peerInfo={ 
            videoContainer : &quot;video&quot;+userid,
            videoHeight : null,
            videoClassName: null,
            userid : userid , 
            name  :  username,
            color : usecolor,
            email : useremail,
            role : userrole,
            controlBarName: &quot;control-video&quot;+userid,
            filearray : [],
            vid : &quot;video&quot;+type+&quot;_&quot;+userid
        };
     
        if(fileshareobj.active ){

            if(fileshareobj.props.fileShare==&quot;single&quot;){
                peerInfo.fileShare={
                    outerbox: &quot;widget-filesharing-box&quot;,
                    container : &quot;widget-filesharing-container&quot;,
                    minButton: &quot;widget-filesharing-minbutton&quot;,
                    maxButton: &quot;widget-filesharing-maxbutton&quot;,
                    closeButton: &quot;widget-filesharing-closebutton&quot;
                };
            }else{
                peerInfo.fileShare={
                    outerbox: &quot;widget-filesharing-box&quot;+userid,
                    container : &quot;widget-filesharing-container&quot;+userid,
                    minButton: &quot;widget-filesharing-minbutton&quot;+userid,
                    maxButton: &quot;widget-filesharing-maxbutton&quot;+userid,
                    closeButton: &quot;widget-filesharing-closebutton&quot;+userid
                };
            }

            if(fileshareobj.props.fileList==&quot;single&quot;){
                peerInfo.fileList={
                    outerbox: &quot;widget-filelisting-box&quot;,
                    container : &quot;widget-filelisting-container&quot;
                };
            }else{
                peerInfo.fileList={
                    outerbox: &quot;widget-filelisting-box&quot;+userid,
                    container : &quot;widget-filelisting-container&quot;+userid
                };
            }

        }
        webrtcdev.log(&quot;updated peerInfo: &quot; ,peerInfo);
        webcallpeers.push(peerInfo);

        // Update the web call view 
        // updateWebCallView(peerInfo);
    }

    /**
     * update info about a peer in list of peers (webcallpeers)
     * @method
     * @name removePeerInfo
     * @param {string} userid
     * @param {string} usernamess
     * @param {string} usercolor
     * @param {string} type
     */
    function removePeerInfo(userid){
        webrtcdev.log(&quot; [removePeerInfo] Before  &quot; , webcallpeers);
        webrtcdev.log(&quot; [removePeerInfo] Removing peerInfo: &quot; , userid);
        webcallpeers.splice(userid, 1);
        webrtcdev.log(&quot; [removePeerInfo] After removing peerInfo&quot; , webcallpeers);
    }

    function destroyWebCallView(peerInfo , callback){
        webrtcdev.log(&quot; [destroyWebCallView] peerInfo&quot; , peerInfo);
        if( peerInfo.videoContainer &amp;&amp; document.getElementById(peerInfo.videoContainer))
            document.getElementById(peerInfo.videoContainer).src=&quot;&quot;;
        
        /*if(fileshareobj.active){
            if(fileshareobj.props.fileShare){
                if(fileshareobj.props.fileShare==&quot;divided&quot;)
                    webrtcdev.log(&quot;dont remove it now &quot;);
                    //createFileSharingDiv(peerInfo);
                else if(fileshareobj.props.fileShare==&quot;single&quot;)
                    webrtcdev.log(&quot;No Seprate div created for this peer  s fileshare container is single&quot;);
                else
                    webrtcdev.log(&quot;props undefined &quot;);
            }
        }*/

        callback(true);
    }

    /**
     * find information about a peer form array of peers based on userid
     * @method
     * @name findPeerInfo
     * @param {string} userid
     */
    var findPeerInfo = function (userid){
        var peerInfo;
        /*    
        if(rtcConn.userid==userid){
            webrtcdev.log(&quot;PeerInfo is found for initiator&quot;, webcallpeers[0]);
            return webcallpeers[0];
        }
        */
        for(x in webcallpeers){
            if(webcallpeers[x].userid==userid) {
                return webcallpeers[x];
            }
        }
        return null;
    }


    /**
     * Open a WebRTC socket channel
     * @method
     * @name opneWebRTC
     * @param {string} channel
     * @param {string} userid
     */
    var openWebRTC = function(channel , userid){
        webrtcdev.info(&quot; [openWebRTC] channel: &quot; , channel);

         socket.emit(&quot;open-channel&quot;, {
            channel    : channel,
            sender     : tempuserid,
            maxAllowed : remoteobj.maxAllowed
        });
        
        shownotification(&quot; Making a new session &quot;);
    }


    /**
     * connect to a webrtc socket channel
     * @method
     * @name connectWebRTC
     * @param {string} type
     * @param {string} channel
     * @param {string} userid
     * @param {string} remoteUsers
     */
    var connectWebRTC=function(type, channel, userid ,remoteUsers){
        webrtcdev.info(&quot; [start ConnectWebRTC ] type : &quot; , type , &quot; , Channel :&quot; , channel , 
                                        &quot; , Userid : &quot; ,  userid , &quot; , remote users : &quot; , remoteUsers);
        /*void(document.title = channel);*/
        if(fileshareobj.active){
            
            //Do not create file share and file viewer for inspector&apos;s own session 
            var selfpeerinfo = findPeerInfo(userid);

            if(fileshareobj.props.fileShare==&quot;single&quot;){
                createFileSharingDiv(selfpeerinfo);
                document.getElementById(peerInfo.fileShare.outerbox).style.width=&quot;100%&quot;;
            } else if(fileshareobj.props.fileShare==&quot;divided&quot;){
                
                // create local File sharing window 
                if(role!=&quot;inspector&quot;) {
                    webrtcdev.log(&quot; [start connectWebRTC] creating local file sharing&quot;);
                    createFileSharingDiv(selfpeerinfo);
                }else{
                    webrtcdev.log(&quot; [start] Since it is an inspectors own session , not creating local File viewer and list&quot;);
                }
                
                // create remotes File sharing window 
                for(x in webcallpeers){
                    if(webcallpeers[x].userid != userid &amp;&amp; webcallpeers[x].role != &quot;inspector&quot;){
                        webrtcdev.log(&quot; [start connectWebRTC] creating remote file sharing &quot;);
                        createFileSharingDiv(webcallpeers[x]);
                    }
                }

                if(!localStorage.getItem(&quot;userid&quot;))
                    localStorage.setItem(&quot;userid&quot;, selfuserid);
                
                if(!localStorage.getItem(&quot;remoteUsers&quot;))
                    localStorage.setItem(&quot;remoteUsers&quot;, remoteUsers);
                
                // on connect webrtc request old file from peerconnection session
                requestOldFiles();

            }else{
                webrtcdev.error(&quot;fileshareobj.props.fileShare undefined &quot;);
            }
            

            if(fileshareobj.props.fileList==&quot;single&quot;){
                document.getElementById(peerInfo.fileList.outerbox).style.width=&quot;100%&quot;;
            }else if(fileshareobj.props.fileShare!=&quot;single&quot;){
                webrtcdev.log(&quot;No Seprate div created for this peer since fileshare container is single&quot;);
            }else{
                webrtcdev.error(&quot;fileshareobj.props.fileShare undefined &quot;);
            }

        }

    }


    /**
     * function to join w webrtc socket channel
     * @method
     * @name joinWebRTC
     * @param {string} channel
     * @param {string} userid
     */
    var joinWebRTC = function(channel , userid){
        shownotification(&quot;Joining an existing session &quot; + channel);
        webrtcdev.info(&quot; [joinWebRTC] channel: &quot; , channel);
        
        if (selfuserid == null)
            selfuserid = tempuserid;

        socket.emit(&quot;join-channel&quot;, {
            channel: channel,
            sender: selfuserid,
            extra: {
                userid  : selfuserid,
                name    : selfusername,
                color   : selfcolor,
                email   : selfemail,
                role    : role
            }
        });
    }

    /**
     * function to leave a webrtc socket channel
     * @method
     * @name leaveWebRTC
     */
    var leaveWebRTC=function(){
        shownotification(&quot;Leaving the session &quot;);
    }

    /*window.onload=function(){
        webrtcdev.log( &quot;Local Storage Channel &quot; ,  localStorage.getItem(&quot;channel&quot;));
    };
    */
    window.onunload=function(){
        webrtcdev.log( localStorage.getItem(&quot;channel&quot;));
        alert(&quot; Refreshing the Page will loose the session data&quot;);
    };

    /**
     * function to interact with background script of chrome extension
     * @call
     * @name addeventlistener
     */
    window.addEventListener(&apos;message&apos;, function(event){
        webrtcdev.log(&quot;------ message from Extension &quot; , event);
        if (event.data.type) {
            if(event.data.type==&quot;screenshare&quot;){
                onScreenshareExtensionCallback(event);
            }else if(event.data.type==&quot;screenrecord&quot;){
                onScreenrecordExtensionCallback(event);
            }
        }else if(event.data==&quot;webrtcdev-extension-getsourceId-audio-plus-tab&quot;){
            onScreenrecordExtensionCallback(event);
        }else{
            onScreenshareExtensionCallback(event);
        }
    }); 

    function clearCaches(){
        localStorage.clear();
    }</code></pre>

</div>

<footer class="footer">
  Generated by <a href="https://esdoc.org">ESDoc<span data-ice="esdocVersion">(1.1.0)</span><img src="./image/esdoc-logo-mini-black.png"></a>
</footer>

<script src="script/search_index.js"></script>
<script src="script/search.js"></script>
<script src="script/pretty-print.js"></script>
<script src="script/inherited-summary.js"></script>
<script src="script/test-summary.js"></script>
<script src="script/inner-link.js"></script>
<script src="script/patch-for-local.js"></script>
</body>
</html>
